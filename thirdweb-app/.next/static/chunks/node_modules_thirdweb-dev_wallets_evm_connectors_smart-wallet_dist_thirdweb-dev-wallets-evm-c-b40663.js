"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_thirdweb-dev_wallets_evm_connectors_smart-wallet_dist_thirdweb-dev-wallets-evm-c-b40663"],{

/***/ "./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SmartWalletConnector: function() { return /* binding */ SmartWalletConnector; }\n/* harmony export */ });\n/* harmony import */ var _dist_connector_05689d68_browser_esm_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../dist/connector-05689d68.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/connector-05689d68.browser.esm.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/url-a45219bd.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _dist_headers_0db6302a_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../dist/headers-0db6302a.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/headers-0db6302a.browser.esm.js\");\n/* harmony import */ var _dist_constants_509940c0_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../dist/constants-509940c0.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/constants-509940c0.browser.esm.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @account-abstraction/contracts */ \"./node_modules/@account-abstraction/contracts/dist/index.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../dist/defineProperty-350fc508.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/defineProperty-350fc508.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @thirdweb-dev/sdk */ \"./node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js\");\n/* harmony import */ var _wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @thirdweb-dev/chains */ \"./node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@thirdweb-dev/wallets/node_modules/eventemitter3/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\nasync function hexlifyUserOp(op) {\n  const userOp = await ethers__WEBPACK_IMPORTED_MODULE_3__.utils.resolveProperties(op);\n  return Object.keys(userOp).map(key => {\n    let val = userOp[key];\n    if (typeof val !== \"string\" || !val.startsWith(\"0x\")) {\n      val = ethers__WEBPACK_IMPORTED_MODULE_3__.utils.hexValue(val);\n    }\n    return [key, val];\n  }).reduce((set, _ref) => {\n    let [k, v] = _ref;\n    return {\n      ...set,\n      [k]: v\n    };\n  }, {});\n}\n\n// v0.6 userOpHash calculation\nasync function getUserOpHashV06(userOp, entryPoint, chainId) {\n  const op = await ethers__WEBPACK_IMPORTED_MODULE_3__.utils.resolveProperties(userOp);\n  const hashedUserOp = {\n    sender: op.sender,\n    nonce: op.nonce,\n    initCodeHash: ethers__WEBPACK_IMPORTED_MODULE_3__.utils.keccak256(op.initCode),\n    callDataHash: ethers__WEBPACK_IMPORTED_MODULE_3__.utils.keccak256(op.callData),\n    callGasLimit: op.callGasLimit,\n    verificationGasLimit: op.verificationGasLimit,\n    preVerificationGas: op.preVerificationGas,\n    maxFeePerGas: op.maxFeePerGas,\n    maxPriorityFeePerGas: op.maxPriorityFeePerGas,\n    paymasterAndDataHash: ethers__WEBPACK_IMPORTED_MODULE_3__.utils.keccak256(op.paymasterAndData)\n  };\n  const userOpType = {\n    components: [{\n      type: \"address\",\n      name: \"sender\"\n    }, {\n      type: \"uint256\",\n      name: \"nonce\"\n    }, {\n      type: \"bytes32\",\n      name: \"initCodeHash\"\n    }, {\n      type: \"bytes32\",\n      name: \"callDataHash\"\n    }, {\n      type: \"uint256\",\n      name: \"callGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"verificationGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"preVerificationGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxFeePerGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxPriorityFeePerGas\"\n    }, {\n      type: \"bytes32\",\n      name: \"paymasterAndDataHash\"\n    }],\n    name: \"hashedUserOp\",\n    type: \"tuple\"\n  };\n  const encoded = ethers__WEBPACK_IMPORTED_MODULE_3__.utils.defaultAbiCoder.encode([userOpType], [{\n    ...hashedUserOp\n  }]);\n  // remove leading word (total length) and trailing word (zero-length signature)\n\n  const userOpHash = ethers__WEBPACK_IMPORTED_MODULE_3__.utils.keccak256(encoded);\n  const enc = ethers__WEBPACK_IMPORTED_MODULE_3__.utils.defaultAbiCoder.encode([\"bytes32\", \"address\", \"uint256\"], [userOpHash, entryPoint, chainId]);\n  return ethers__WEBPACK_IMPORTED_MODULE_3__.utils.keccak256(enc);\n}\nconst generateRandomUint192 = () => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;\n};\nconst randomNonce = () => {\n  let hexString = generateRandomUint192().toString(16);\n  if (hexString.length % 2 !== 0) {\n    hexString = \"0\" + hexString;\n  }\n  hexString = \"0x\" + hexString;\n  return ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(ethers__WEBPACK_IMPORTED_MODULE_3__.utils.concat([hexString, \"0x0000000000000000\"]));\n};\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * an API to external a UserOperation with paymaster info\n */\nclass PaymasterAPI {}\n\nconst DEBUG = false; // TODO set as public flag\n\nclass HttpRpcClient {\n  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {\n    this.bundlerUrl = bundlerUrl;\n    this.entryPointAddress = entryPointAddress;\n    this.chainId = chainId;\n    const headers = {};\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.i)(this.bundlerUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (secretKey) {\n        headers[\"x-secret-key\"] = secretKey;\n      } else if (clientId) {\n        headers[\"x-client-id\"] = clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_0db6302a_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.s)(headers);\n    }\n    this.userOpJsonRpcProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.providers.StaticJsonRpcProvider({\n      url: this.bundlerUrl,\n      headers\n    }, {\n      name: \"Connected bundler network\",\n      chainId\n    });\n    this.initializing = this.validateChainId();\n  }\n  async validateChainId() {\n    // validate chainId is in sync with expected chainid\n    const chain = await this.userOpJsonRpcProvider.send(\"eth_chainId\", []);\n    const bundlerChain = parseInt(chain);\n    if (bundlerChain !== this.chainId) {\n      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);\n    }\n  }\n\n  /**\n   * send a UserOperation to the bundler\n   * @param userOp1 - The UserOperation to send\n   * @returns userOpHash the id of this operation, for getUserOperationTransaction\n   */\n  async sendUserOpToBundler(userOp1) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp1);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_sendUserOperation\", jsonRequestData);\n    return await this.userOpJsonRpcProvider.send(\"eth_sendUserOperation\", [hexifiedUserOp, this.entryPointAddress]);\n  }\n  async estimateUserOpGas(userOp) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_estimateUserOperationGas\", jsonRequestData);\n    const data = await this.userOpJsonRpcProvider.send(\"eth_estimateUserOperationGas\", [hexifiedUserOp, this.entryPointAddress]);\n    // adds gas buffer to callGasLimit to account for ManagedAccountFactory delegate calls\n    return {\n      preVerificationGas: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(data.preVerificationGas),\n      verificationGas: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(data.verificationGas),\n      verificationGasLimit: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(data.verificationGasLimit),\n      callGasLimit: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(data.callGasLimit).add(_dist_constants_509940c0_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.M)\n    };\n  }\n  async getUserOperationGasPrice() {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"thirdweb_getUserOperationGasPrice\", []);\n  }\n  async getUserOperationReceipt(userOpHash) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"eth_getUserOperationReceipt\", [userOpHash]);\n  }\n  async printUserOperation(method, _ref) {\n    {\n      return;\n    }\n  }\n}\n\nclass VerifyingPaymasterAPI extends PaymasterAPI {\n  constructor(paymasterUrl, entryPoint, clientId, secretKey) {\n    super();\n    this.paymasterUrl = paymasterUrl;\n    this.entryPoint = entryPoint;\n    this.clientId = clientId;\n    this.secretKey = secretKey;\n  }\n  async getPaymasterAndData(userOp) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.i)(this.paymasterUrl)) {\n      if (this.secretKey && this.clientId) {\n        throw new Error(\"Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.\");\n      }\n      if (this.secretKey) {\n        headers[\"x-secret-key\"] = this.secretKey;\n      } else if (this.clientId) {\n        headers[\"x-client-id\"] = this.clientId;\n        const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token.\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_0db6302a_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.s)(headers);\n    }\n\n    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n    const response = await fetch(this.paymasterUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"pm_sponsorUserOperation\",\n        params: [await hexlifyUserOp(userOp), this.entryPoint]\n      })\n    });\n    const res = await response.json();\n    if (!response.ok) {\n      const error = res.error || response.statusText;\n      const code = res.code || \"UNKNOWN\";\n      throw new Error(`Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    if (DEBUG) {\n      console.debug(\"Paymaster result:\", res);\n    }\n    if (res.result) {\n      // some paymasters return a string, some return an object with more data\n      if (typeof res.result === \"string\") {\n        return {\n          paymasterAndData: res.result\n        };\n      } else {\n        return res.result;\n      }\n    } else {\n      const error = res.error?.message || res.error || response.statusText || \"unknown error\";\n      throw new Error(`Paymaster error from ${this.paymasterUrl}: ${error}`);\n    }\n  }\n}\nconst getVerifyingPaymaster = (paymasterUrl, entryPoint, clientId, secretKey) => new VerifyingPaymasterAPI(paymasterUrl, entryPoint, clientId, secretKey);\n\n/**\n * This class encapsulates Ethers.js listener function and necessary UserOperation details to\n * discover a TransactionReceipt for the operation.\n *\n * TODO refactor this to a simple event listener on the entry point\n */\nclass UserOperationEventListener {\n  constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.entryPoint = entryPoint;\n    this.sender = sender;\n    this.userOpHash = userOpHash;\n    this.nonce = nonce;\n    this.timeout = timeout;\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this, \"resolved\", false);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.boundLisener = this.listenerCallback.bind(this);\n  }\n  start() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);\n    // listener takes time... first query directly:\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      const res = await this.entryPoint.queryFilter(filter, -10); // look at last 10 blocks\n      if (res.length > 0) {\n        void this.listenerCallback(res[0]);\n      } else {\n        this.entryPoint.once(filter, this.boundLisener);\n      }\n    }, 100);\n  }\n  stop() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.entryPoint.off(\"UserOperationEvent\", this.boundLisener);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async listenerCallback() {\n    for (var _len = arguments.length, param = new Array(_len), _key = 0; _key < _len; _key++) {\n      param[_key] = arguments[_key];\n    }\n    // TODO clean this up..\n    // eslint-disable-next-line prefer-rest-params\n    const event = arguments[arguments.length - 1];\n    if (!event.args) {\n      console.error(\"got event without args\", event);\n      return;\n    }\n    // TODO: can this happen? we register to event by userOpHash..\n    if (event.args.userOpHash !== this.userOpHash) {\n      console.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt(this.nonce?.toString())}`);\n      return;\n    }\n    const transactionReceipt = await event.getTransactionReceipt();\n\n    // before returning the receipt, update the status from the event.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!event.args.success) {\n      await this.extractFailureReason(transactionReceipt);\n    }\n    this.stop();\n    this.resolve(transactionReceipt);\n    this.resolved = true;\n  }\n  async extractFailureReason(receipt) {\n    receipt.status = 0;\n    const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);\n    if (revertReasonEvents[0]) {\n      let message = revertReasonEvents[0].args.revertReason;\n      if (message.startsWith(\"0x08c379a0\")) {\n        // Error(string)\n        message = ethers__WEBPACK_IMPORTED_MODULE_3__.utils.defaultAbiCoder.decode([\"string\"], \"0x\" + message.substring(10)).toString();\n      }\n      this.reject(new Error(`UserOp failed with reason: ${message}`));\n    }\n  }\n}\n\nclass ERC4337EthersSigner extends ethers__WEBPACK_IMPORTED_MODULE_3__.Signer {\n  // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference\n  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {\n    super();\n    ethers__WEBPACK_IMPORTED_MODULE_3__.utils.defineReadOnly(this, \"provider\", erc4337provider);\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.erc4337provider = erc4337provider;\n    this.httpRpcClient = httpRpcClient;\n    this.smartAccountAPI = smartAccountAPI;\n    this.approving = false;\n  }\n  // This one is called by Contract. It signs the request and passes in to Provider to be sent.\n  async sendTransaction(transaction, options) {\n    if (!this.approving) {\n      this.approving = true;\n      const tx = await this.smartAccountAPI.createApproveTx();\n      if (tx) {\n        await (await this.sendTransaction(tx)).wait();\n      }\n      this.approving = false;\n    }\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = randomNonce();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);\n    try {\n      await this.httpRpcClient.sendUserOpToBundler(userOperation);\n    } catch (error) {\n      throw this.unwrapError(error);\n    }\n    // TODO: handle errors - transaction that is \"rejected\" by bundler is _not likely_ to ever resolve its \"wait()\"\n    return transactionResponse;\n  }\n  unwrapError(errorIn) {\n    try {\n      let errorMsg = \"Unknown Error\";\n      if (errorIn.error) {\n        errorMsg = `The bundler has failed to include UserOperation in a batch: ${errorIn.error}`;\n      } else if (errorIn.body && typeof errorIn.body === \"string\") {\n        const errorBody = JSON.parse(errorIn.body);\n        const errorStatus = errorIn.status || \"UNKNOWN\";\n        const errorCode = errorBody?.code || \"UNKNOWN\";\n        let failedOpMessage = errorBody?.error?.message || errorBody?.error?.data || errorBody?.error || errorIn.reason;\n        if (failedOpMessage?.includes(\"FailedOp\")) {\n          let paymasterInfo = \"\";\n          // TODO: better error extraction methods will be needed\n          const matched = failedOpMessage.match(/FailedOp\\((.*)\\)/);\n          if (matched) {\n            const split = matched[1].split(\",\");\n            paymasterInfo = `(paymaster address: ${split[1]})`;\n            failedOpMessage = split[2];\n          }\n          errorMsg = `The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo}`;\n        } else {\n          errorMsg = `RPC error: ${failedOpMessage}\nStatus: ${errorStatus}\nCode: ${errorCode}`;\n        }\n      }\n      const error = new Error(errorMsg);\n      error.stack = errorIn.stack;\n      return error;\n    } catch (error) {}\n    return errorIn;\n  }\n  async verifyAllNecessaryFields(transactionRequest) {\n    if (!transactionRequest.to) {\n      throw new Error(\"Missing call target\");\n    }\n    if (!transactionRequest.data && !transactionRequest.value) {\n      // TBD: banning no-op UserOps seems to make sense on provider level\n      throw new Error(\"Missing call data or value\");\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connect(provider) {\n    throw new Error(\"changing providers is not supported\");\n  }\n  async getAddress() {\n    if (!this.address) {\n      this.address = await this.erc4337provider.getSenderAccountAddress();\n    }\n    return this.address;\n  }\n\n  /**\n   * Sign a message and return the signature\n   */\n  async signMessage(message) {\n    // Deploy smart wallet if needed\n    const isNotDeployed = await this.smartAccountAPI.checkAccountPhantom();\n    if (isNotDeployed) {\n      console.log(\"Account contract not deployed yet. Deploying account before signing message\");\n      const tx = await this.sendTransaction({\n        to: await this.getAddress(),\n        data: \"0x\"\n      });\n      await tx.wait();\n    }\n    const [chainId, address] = await Promise.all([this.getChainId(), this.getAddress()]);\n    const originalMsgHash = ethers__WEBPACK_IMPORTED_MODULE_3__.utils.hashMessage(message);\n    let factorySupports712;\n    let signature;\n    const rpcUrl = (0,_wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.chainIdToThirdwebRpc)(chainId, this.config.clientId);\n    const headers = {};\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.i)(rpcUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (this.config.secretKey) {\n        headers[\"x-secret-key\"] = this.config.secretKey;\n      } else if (this.config.clientId) {\n        headers[\"x-client-id\"] = this.config.clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_0db6302a_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.s)(headers);\n    }\n    try {\n      const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.providers.StaticJsonRpcProvider({\n        url: rpcUrl,\n        headers\n      }, chainId);\n      const walletContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(address, [\"function getMessageHash(bytes32 _hash) public view returns (bytes32)\"], provider);\n      // if this fails it's a pre 712 factory\n      await walletContract.getMessageHash(originalMsgHash);\n      factorySupports712 = true;\n    } catch {\n      factorySupports712 = false;\n    }\n    if (factorySupports712) {\n      const result = await (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.signTypedDataInternal)(this, {\n        name: \"Account\",\n        version: \"1\",\n        chainId,\n        verifyingContract: address\n      }, {\n        AccountMessage: [{\n          name: \"message\",\n          type: \"bytes\"\n        }]\n      }, {\n        message: ethers__WEBPACK_IMPORTED_MODULE_3__.utils.defaultAbiCoder.encode([\"bytes32\"], [originalMsgHash])\n      });\n      signature = result.signature;\n    } else {\n      signature = await this.originalSigner.signMessage(message);\n    }\n    const isValid = await (0,_dist_constants_509940c0_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)(message, signature, address, chainId, this.config.clientId, this.config.secretKey);\n    if (isValid) {\n      return signature;\n    } else {\n      throw new Error(\"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\");\n    }\n  }\n  async signTransaction(transaction, options) {\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = randomNonce();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const userOpString = JSON.stringify(await hexlifyUserOp(userOperation));\n    return userOpString;\n  }\n}\n\nclass ERC4337EthersProvider extends ethers__WEBPACK_IMPORTED_MODULE_3__.providers.BaseProvider {\n  constructor(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {\n    super({\n      name: \"ERC-4337 Custom Network\",\n      chainId\n    });\n    this.chainId = chainId;\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.originalProvider = originalProvider;\n    this.httpRpcClient = httpRpcClient;\n    this.entryPoint = entryPoint;\n    this.smartAccountAPI = smartAccountAPI;\n    this.signer = new ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);\n  }\n  getSigner() {\n    return this.signer;\n  }\n  async perform(method, params) {\n    if (method === \"sendTransaction\" || method === \"getTransactionReceipt\") {\n      // TODO: do we need 'perform' method to be available at all?\n      // there is nobody out there to use it for ERC-4337 methods yet, we have nothing to override in fact.\n      throw new Error(\"Should not get here. Investigate.\");\n    }\n    if (method === \"estimateGas\") {\n      // gas estimation does nothing at this layer, sendTransaction will do the gas estimation for the userOp\n      return ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(500000);\n    }\n    return await this.originalProvider.perform(method, params);\n  }\n  async getTransaction(transactionHash) {\n    // TODO\n    return await super.getTransaction(transactionHash);\n  }\n  async getTransactionReceipt(transactionHash) {\n    const userOpHash = await transactionHash;\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      new UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();\n    });\n  }\n  async getSenderAccountAddress() {\n    return await this.smartAccountAPI.getAccountAddress();\n  }\n  async waitForTransaction(transactionHash, confirmations, timeout) {\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      const listener = new UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, undefined, timeout);\n      listener.start();\n    });\n  }\n\n  // fabricate a response in a format usable by ethers users...\n  async constructUserOpTransactionResponse(userOp1) {\n    const userOp = await ethers__WEBPACK_IMPORTED_MODULE_3__.utils.resolveProperties(userOp1);\n    const userOpHash = await this.smartAccountAPI.getUserOpHash(userOp);\n    return {\n      hash: userOpHash,\n      confirmations: 0,\n      from: userOp.sender,\n      nonce: 0,\n      // not the real nonce, but good enough for this purpose\n      gasLimit: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(userOp.callGasLimit),\n      // ??\n      value: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0),\n      data: ethers__WEBPACK_IMPORTED_MODULE_3__.utils.hexValue(userOp.callData),\n      // should extract the actual called method from this \"execFromEntryPoint()\" call\n      chainId: this.chainId,\n      wait: async confirmations => {\n        const transactionReceipt = await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient, userOpHash);\n        if (userOp.initCode.length !== 0) {\n          // checking if the wallet has been deployed by the transaction; it must be if we are here\n          await this.smartAccountAPI.checkAccountPhantom();\n        }\n        return transactionReceipt;\n      }\n    };\n  }\n  async detectNetwork() {\n    return this.originalProvider.detectNetwork();\n  }\n}\n\n/**\n * wrap an existing provider to tunnel requests through Account Abstraction.\n * @param originalProvider - The normal provider\n * @param config - see {@link ClientConfig} for more info\n * @param originalSigner - use this signer as the owner. of this wallet. By default, use the provider's signer\n */\nfunction create4337Provider(config, accountApi, originalProvider, chainId) {\n  const entryPoint = _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);\n  const httpRpcClient = new HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.clientId, config.secretKey);\n  return new ERC4337EthersProvider(chainId, config, config.localSigner, originalProvider, httpRpcClient, entryPoint, accountApi);\n}\n\nconst DUMMY_SIGNATURE = \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nclass BaseAccountAPI {\n  // entryPoint connected to \"zero\" address. allowed to make static calls (e.g. to getSenderAddress)\n\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params) {\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this, \"isPhantom\", true);\n    this.provider = params.provider;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.paymasterAPI = params.paymasterAPI;\n    this.gasless = params.gasless;\n    this.erc20PaymasterAddress = params.erc20PaymasterAddress;\n    this.erc20TokenAddress = params.erc20TokenAddress;\n\n    // factory \"connect\" define the contract address. the contract \"connect\" defines the \"from\" address.\n    this.entryPointView = _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__.EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.constants.AddressZero);\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the contract is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n\n  /**\n   * return current account's nonce.\n   */\n\n  /**\n   * encode the call from entryPoint through our account to the target contract.\n   * @param target - The target contract address\n   * @param value - The value to send to the target contract\n   * @param data - The calldata to send to the target contract\n   */\n\n  /**\n   * sign a userOp's hash (userOpHash).\n   * @param userOpHash - The hash to sign\n   */\n\n  /**\n   * calculate the account address even before it is deployed\n   */\n\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom() {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());\n    if (senderAddressCode.length > 2) {\n      this.isPhantom = false;\n    }\n    return this.isPhantom;\n  }\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode() {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return \"0x\";\n  }\n\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit() {\n    return 100000;\n  }\n\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp - userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp) {\n    const chainId = await this.provider.getNetwork().then(net => net.chainId);\n    return getUserOpHashV06(userOp, this.entryPointAddress, chainId);\n  }\n\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress() {\n    if (!this.senderAddress) {\n      if (this.accountAddress) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n  async estimateCreationGas(initCode) {\n    if (!initCode || initCode === \"0x\") {\n      return 0;\n    }\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = \"0x\" + initCode.substring(42);\n    return await this.provider.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData\n    });\n  }\n  async createUnsignedUserOp(httpRpcClient, info, options) {\n    let {\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = info;\n    // get fees from bundler if available\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.i)(httpRpcClient.bundlerUrl)) {\n      const bundlerFeeData = await httpRpcClient.getUserOperationGasPrice();\n      maxFeePerGas = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(bundlerFeeData.maxFeePerGas);\n      maxPriorityFeePerGas = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(bundlerFeeData.maxPriorityFeePerGas);\n    } else {\n      // if bundler is not available, try to get fees from the network if not passed explicitly\n      if (!maxFeePerGas || !maxPriorityFeePerGas) {\n        const feeData = await (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.getDynamicFeeData)(this.provider);\n        if (!maxPriorityFeePerGas) {\n          maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined;\n        }\n        if (!maxFeePerGas) {\n          maxFeePerGas = feeData.maxFeePerGas ?? undefined;\n          const network = await this.provider.getNetwork();\n          const chainId = network.chainId;\n          if (chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_9__.Celo.chainId || chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_9__.CeloAlfajoresTestnet.chainId || chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_9__.CeloBaklavaTestnet.chainId) {\n            maxPriorityFeePerGas = maxFeePerGas;\n          }\n        }\n      }\n    }\n    if (!maxFeePerGas || !maxPriorityFeePerGas) {\n      throw new Error(\"maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely\");\n    }\n    const [sender, nonce] = await Promise.all([this.getAccountAddress(), info.nonce ? Promise.resolve(info.nonce) : this.getNonce()]);\n    const initCode = await this.getInitCode();\n    const value = parseNumber(info.value) ?? ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0);\n    const callData = options?.batchData ? info.data : await this.prepareExecute(info.target, value, info.data).then(async tx => {\n      if (!info.gasLimit) {\n        // estimate gas on the inner transactions to simulate\n        // bundler would not revert otherwise\n        await this.provider.estimateGas({\n          from: sender,\n          to: info.target,\n          data: info.data,\n          value: value\n        });\n      }\n      return tx.encode();\n    });\n    const partialOp = {\n      sender,\n      nonce,\n      initCode,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      callGasLimit: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(1000000),\n      verificationGasLimit: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(1000000),\n      preVerificationGas: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(1000000),\n      paymasterAndData: \"0x\",\n      signature: DUMMY_SIGNATURE\n    };\n\n    // paymaster data + maybe used for estimation as well\n    const gasless = options?.gasless !== undefined ? options.gasless : this.gasless;\n    const useErc20Paymaster = this.erc20PaymasterAddress && this.erc20TokenAddress && (await this.isAccountApproved());\n    if (useErc20Paymaster) {\n      partialOp.paymasterAndData = this.erc20PaymasterAddress;\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    } else if (gasless) {\n      const paymasterResult = await this.paymasterAPI.getPaymasterAndData(partialOp);\n      const paymasterAndData = paymasterResult.paymasterAndData;\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        partialOp.paymasterAndData = paymasterAndData;\n      }\n      // paymaster can have the gas limits in the response\n      if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n        partialOp.callGasLimit = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(paymasterResult.callGasLimit);\n        partialOp.verificationGasLimit = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(paymasterResult.verificationGasLimit);\n        partialOp.preVerificationGas = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(paymasterResult.preVerificationGas);\n      } else {\n        // otherwise fallback to bundler for gas limits\n        let estimates;\n        try {\n          estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n        } catch (error) {\n          throw this.unwrapBundlerError(error);\n        }\n        partialOp.callGasLimit = estimates.callGasLimit;\n        partialOp.verificationGasLimit = estimates.verificationGasLimit;\n        partialOp.preVerificationGas = estimates.preVerificationGas;\n        // need paymaster to re-sign after estimates\n        if (paymasterAndData && paymasterAndData !== \"0x\") {\n          const paymasterResult2 = await this.paymasterAPI.getPaymasterAndData(partialOp);\n          if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== \"0x\") {\n            partialOp.paymasterAndData = paymasterResult2.paymasterAndData;\n          }\n        }\n      }\n    } else {\n      // query bundler for gas limits\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    }\n    return {\n      ...partialOp,\n      signature: \"\"\n    };\n  }\n\n  /**\n   * Sign the filled userOp.\n   * @param userOp - The UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp) {\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = await this.signUserOpHash(userOpHash);\n    return {\n      ...userOp,\n      signature\n    };\n  }\n\n  /**\n   * get the transaction that has this userOpHash mined, or throws if not found\n   * @param userOpHash - returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout - stop waiting after this timeout\n   * @param interval - time to wait between polls.\n   * @returns The transaction receipt, or an error if timed out.\n   */\n  async getUserOpReceipt(httpRpcClient, userOpHash) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120000;\n    let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const userOpReceipt = await httpRpcClient.getUserOperationReceipt(userOpHash);\n      if (userOpReceipt) {\n        // avoid desync with current provider state\n        return await this.provider.waitForTransaction(userOpReceipt.receipt.transactionHash);\n      }\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    throw new Error(\"Timeout waiting for userOp to be mined\");\n  }\n  unwrapBundlerError(error) {\n    const message = error?.error?.message || error.error || error.message || error;\n    return new Error(message);\n  }\n}\nfunction parseNumber(a) {\n  if (!a || a === \"\") {\n    return null;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(a.toString());\n}\n\nclass AccountAPI extends BaseAccountAPI {\n  constructor(params, originalProvider) {\n    super({\n      ...params,\n      provider: originalProvider\n    });\n    this.params = params;\n    // Technically dont need the signer here, but we need to encode/estimate gas with it so a signer is required\n    // We don't want to use the localSigner directly since it might be connected to another chain\n    // so we just use the public hardhat pkey instead\n    this.sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.ThirdwebSDK.fromPrivateKey(_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.LOCAL_NODE_PKEY, params.chain, {\n      clientId: params.clientId,\n      secretKey: params.secretKey,\n      // @ts-expect-error expected chain type error\n      supportedChains: typeof params.chain === \"object\" ? [params.chain] : undefined\n    });\n  }\n  async getChainId() {\n    return await this.provider.getNetwork().then(n => n.chainId);\n  }\n  async getAccountContract() {\n    if (!this.accountContract) {\n      if (this.params.accountInfo?.abi) {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), this.params.accountInfo.abi);\n      } else {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), _dist_constants_509940c0_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.A);\n      }\n    }\n    return this.accountContract;\n  }\n  async getAccountInitCode() {\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    const tx = await this.params.factoryInfo.createAccount(factory, localSigner);\n    return ethers__WEBPACK_IMPORTED_MODULE_3__.utils.hexConcat([factory.getAddress(), tx.encode()]);\n  }\n  async getFactoryContract() {\n    if (this.factoryContract) {\n      return this.factoryContract;\n    }\n    if (this.params.factoryInfo?.abi) {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress, this.params.factoryInfo.abi);\n    } else {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress);\n    }\n    return this.factoryContract;\n  }\n  async getCounterFactualAddress() {\n    if (this.params.accountAddress) {\n      return this.params.accountAddress;\n    }\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    return this.params.factoryInfo.getAccountAddress(factory, localSigner);\n  }\n  async getNonce() {\n    if (await this.checkAccountPhantom()) {\n      return ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0);\n    }\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.getNonce(accountContract);\n  }\n  async prepareExecute(target, value, data) {\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.execute(accountContract, target, value, data);\n  }\n  async prepareExecuteBatch(targets, values, datas) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.prepare(\"executeBatch\", [targets, values, datas]);\n  }\n  async signUserOpHash(userOpHash) {\n    return await this.params.localSigner.signMessage(ethers__WEBPACK_IMPORTED_MODULE_3__.utils.arrayify(userOpHash));\n  }\n  async isAcountDeployed() {\n    return !(await this.checkAccountPhantom());\n  }\n  async isAccountApproved() {\n    if (!this.params.erc20PaymasterAddress || !this.params.erc20TokenAddress) {\n      return true;\n    }\n    const swAddress = await this.getCounterFactualAddress();\n    const ERC20Abi = (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/IERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json\", 19))).default;\n    const erc20Token = await this.sdk.getContract(this.params.erc20TokenAddress, ERC20Abi);\n    const allowance = await erc20Token.call(\"allowance\", [swAddress, this.params.erc20PaymasterAddress]);\n    return allowance.gte(ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(2).pow(96).sub(1));\n  }\n  async createApproveTx() {\n    if (await this.isAccountApproved()) {\n      return undefined;\n    }\n    const amountToApprove = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(2).pow(96).sub(1);\n    const ethersSigner = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Wallet(_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.LOCAL_NODE_PKEY, this.provider);\n    const erc20Contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(this.params.erc20TokenAddress, [\"function approve(address spender, uint256 amount) public returns (bool)\"], ethersSigner);\n    const tx = {\n      to: this.params.erc20TokenAddress,\n      from: await this.getAccountAddress(),\n      value: 0,\n      data: erc20Contract.interface.encodeFunctionData(\"approve\", [this.params.erc20PaymasterAddress, amountToApprove])\n    };\n    return tx;\n  }\n}\n\nclass SmartWalletConnector extends _dist_connector_05689d68_browser_esm_js__WEBPACK_IMPORTED_MODULE_10__.C {\n  constructor(config) {\n    super();\n    this.config = config;\n  }\n  async initialize(params) {\n    const config = this.config;\n    const originalProvider = (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.getChainProvider)(config.chain, {\n      clientId: config.clientId,\n      secretKey: config.secretKey\n    });\n    this.chainId = (await originalProvider.getNetwork()).chainId;\n    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const paymasterUrl = this.config.paymasterUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const entryPointAddress = config.entryPointAddress || _dist_constants_509940c0_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.E;\n    const localSigner = await params.personalWallet.getSigner();\n    const providerConfig = {\n      chain: config.chain,\n      localSigner,\n      entryPointAddress,\n      bundlerUrl,\n      paymasterAPI: this.config.paymasterAPI ? this.config.paymasterAPI : getVerifyingPaymaster(paymasterUrl, entryPointAddress, this.config.clientId, this.config.secretKey),\n      gasless: config.gasless,\n      factoryAddress: config.factoryAddress,\n      accountAddress: params.accountAddress,\n      factoryInfo: {\n        createAccount: config.factoryInfo?.createAccount || this.defaultFactoryInfo().createAccount,\n        getAccountAddress: config.factoryInfo?.getAccountAddress || this.defaultFactoryInfo().getAccountAddress,\n        abi: config.factoryInfo?.abi\n      },\n      accountInfo: {\n        execute: config.accountInfo?.execute || this.defaultAccountInfo().execute,\n        getNonce: config.accountInfo?.getNonce || this.defaultAccountInfo().getNonce,\n        abi: config.accountInfo?.abi\n      },\n      clientId: config.clientId,\n      secretKey: config.secretKey,\n      erc20PaymasterAddress: config.erc20PaymasterAddress,\n      erc20TokenAddress: config.erc20TokenAddress\n    };\n    this.personalWallet = params.personalWallet;\n    const accountApi = new AccountAPI(providerConfig, originalProvider);\n    this.aaProvider = create4337Provider(providerConfig, accountApi, originalProvider, this.chainId);\n    this.accountApi = accountApi;\n  }\n  async connect(connectionArgs) {\n    await this.initialize(connectionArgs);\n    return await this.getAddress();\n  }\n  getProvider() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider);\n  }\n  async getSigner() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider.getSigner());\n  }\n  async getAddress() {\n    const signer = await this.getSigner();\n    return signer.getAddress();\n  }\n  async isConnected() {\n    try {\n      const address = await this.getAddress();\n      return !!address;\n    } catch (e) {\n      return false;\n    }\n  }\n  async disconnect() {\n    this.personalWallet = undefined;\n    this.aaProvider = undefined;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const currentChainId = (await provider.getNetwork()).chainId;\n    if (currentChainId !== chainId) {\n      // only throw if actually trying to switch chains\n      throw new Error(\"Not supported.\");\n    }\n  }\n  setupListeners() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateChains(chains) {}\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction - The transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const accountContract = await this.getAccountContract();\n    const signer = await this.getSigner();\n    const signerAddress = await signer.getAddress();\n    const restrictions = (await accountContract.account.getAllSigners()).filter(item => ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.getAddress(item.signer) === ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.getAddress(signerAddress))[0]?.permissions;\n    if (!restrictions) {\n      return false;\n    }\n    return restrictions.approvedCallTargets.includes(transaction.getTarget());\n  }\n\n  /// PREPARED TRANSACTIONS\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transaction - the transaction to send\n   * @param config - optional the transaction configuration\n   * @returns The awaitable transaction\n   */\n  async send(transaction, options) {\n    const signer = await this.getSigner();\n    return signer.sendTransaction({\n      to: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue()\n    }, options);\n  }\n\n  /**\n   * Execute a single transaction (waiting for confirmations)\n   * @param transaction - The transaction to execute\n   * @returns The transaction receipt\n   */\n  async execute(transaction, options) {\n    const tx = await this.send(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions - The transactions to execute\n   * @returns The transaction receipt\n   */\n  async executeBatch(transactions, options) {\n    const tx = await this.sendBatch(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// RAW TRANSACTIONS\n\n  async sendRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    return signer.sendTransaction(transaction, options);\n  }\n  async executeRaw(transaction, options) {\n    const tx = await this.sendRaw(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const batch = await this.prepareBatchRaw(transactions);\n    return signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: batch.tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData: batch.batchData // batched tx flag\n    });\n  }\n  async executeBatchRaw(transactions, options) {\n    const tx = await this.sendBatchRaw(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// ESTIMATION\n\n  async estimate(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return this.estimateTx({\n      target: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue(),\n      gasLimit: await transaction.getOverrides().gasLimit,\n      maxFeePerGas: await transaction.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await transaction.getOverrides().maxPriorityFeePerGas,\n      nonce: await transaction.getOverrides().nonce\n    }, options);\n  }\n  async estimateRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.resolveProperties(transaction);\n    return this.estimateTx({\n      target: tx.to || ethers__WEBPACK_IMPORTED_MODULE_3__.constants.AddressZero,\n      data: tx.data?.toString() || \"\",\n      value: tx.value || ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0),\n      gasLimit: tx.gasLimit,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n      nonce: tx.nonce\n    }, options);\n  }\n  async estimateBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n  async estimateBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchRaw(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  //// DEPLOYMENT\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns The transaction receipt\n   */\n  async deploy(options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const tx = await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: \"0x\"\n    }, {\n      ...options,\n      batchData: {\n        targets: [],\n        data: [],\n        values: []\n      } // batched tx flag to avoid hitting the Router fallback method\n    });\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return await this.accountApi.isAcountDeployed();\n  }\n  async deployIfNeeded(options) {\n    const isDeployed = await this.isDeployed();\n    if (!isDeployed) {\n      await this.deploy(options);\n    }\n  }\n\n  //// PERMISSIONS\n\n  async grantPermissions(target, permissions) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantPermissions(target, permissions);\n  }\n  async revokePermissions(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAccess(target);\n  }\n  async addAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantAdminPermissions(target);\n  }\n  async removeAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAdminPermissions(target);\n  }\n  async getAllActiveSigners() {\n    const isDeployed = await this.isDeployed();\n    if (isDeployed) {\n      const accountContract = await this.getAccountContract();\n      return accountContract.account.getAllAdminsAndSigners();\n    } else {\n      const personalWallet = await this.personalWallet?.getSigner();\n      if (!personalWallet) {\n        throw new Error(\"Personal wallet not connected\");\n      }\n      return [{\n        isAdmin: true,\n        signer: await personalWallet.getAddress(),\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      }];\n    }\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns The account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    // getting a new instance everytime\n    // to avoid caching issues pre/post deployment\n    const sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.accountInfo?.abi) {\n      return sdk.getContract(await this.getAddress(), this.config.accountInfo.abi);\n    } else {\n      return sdk.getContract(await this.getAddress(), _dist_constants_509940c0_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.A);\n    }\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns The account factory contract.\n   */\n  async getFactoryContract() {\n    const sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.factoryInfo?.abi) {\n      return sdk.getContract(this.config.factoryAddress, this.config.factoryInfo.abi);\n    }\n    return sdk.getContract(this.config.factoryAddress);\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async (factory, owner) => {\n        return factory.prepare(\"createAccount\", [owner, ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async (factory, owner) => {\n        return await factory.call(\"getAddress\", [owner, ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.toUtf8Bytes(\"\")]);\n      }\n    };\n  }\n  defaultAccountInfo() {\n    return {\n      execute: async (account, target, value, data) => {\n        return account.prepare(\"execute\", [target, value, data]);\n      },\n      getNonce: async account => {\n        return account.call(\"getNonce\", []);\n      }\n    };\n  }\n\n  /// PRIVATE METHODS\n\n  async estimateTx(tx, options) {\n    if (!this.accountApi || !this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    let deployGasLimit = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0);\n    const [provider, isDeployed] = await Promise.all([this.getProvider(), this.isDeployed()]);\n    if (!isDeployed) {\n      deployGasLimit = await this.estimateDeploymentGasLimit();\n    }\n    const [userOp, gasPrice] = await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient, tx, options), (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.getGasPrice)(provider)]);\n    const resolved = await ethers__WEBPACK_IMPORTED_MODULE_3__.utils.resolveProperties(userOp);\n    const transactionGasLimit = ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(resolved.callGasLimit);\n    const transactionCost = transactionGasLimit.mul(gasPrice);\n    const deployCost = deployGasLimit.mul(gasPrice);\n    const totalCost = deployCost.add(transactionCost);\n    return {\n      ether: ethers__WEBPACK_IMPORTED_MODULE_3__.utils.formatEther(totalCost),\n      wei: totalCost,\n      details: {\n        deployGasLimit,\n        transactionGasLimit,\n        gasPrice,\n        transactionCost,\n        deployCost,\n        totalCost\n      }\n    };\n  }\n  async estimateDeploymentGasLimit() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const initCode = await this.accountApi.getInitCode();\n    const [initGas, verificationGasLimit] = await Promise.all([this.accountApi.estimateCreationGas(initCode), this.accountApi.getVerificationGasLimit()]);\n    return ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(verificationGasLimit).add(initGas);\n  }\n  async prepareBatchRaw(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const resolvedTxs = await Promise.all(transactions.map(transaction => ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.utils.resolveProperties(transaction)));\n    const targets = resolvedTxs.map(tx => tx.to || ethers__WEBPACK_IMPORTED_MODULE_3__.constants.AddressZero);\n    const data = resolvedTxs.map(tx => tx.data || \"0x\");\n    const values = resolvedTxs.map(tx => tx.value || ethers__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(0));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n  async prepareBatchTx(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const targets = transactions.map(tx => tx.getTarget());\n    const data = transactions.map(tx => tx.encode());\n    const values = await Promise.all(transactions.map(tx => tx.getValue()));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL3NtYXJ0LXdhbGxldC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLXNtYXJ0LXdhbGxldC5icm93c2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9GO0FBQ007QUFDZDtBQUNnQjtBQUM0RjtBQUNuSDtBQUMwQjtBQUMyQztBQUNYO0FBQ3pDO0FBQy9EOztBQUV2QjtBQUNBLHVCQUF1Qix5Q0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUFLO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFLO0FBQ3ZCLGtCQUFrQix5Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFLO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIOztBQUVBLHFCQUFxQix5Q0FBSztBQUMxQixjQUFjLHlDQUFLO0FBQ25CLFNBQVMseUNBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsMENBQU0sbUNBQW1DLDBDQUFNO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBLHVCQUF1Qiw2Q0FBUztBQUNoQztBQUNBLHlCQUF5Qiw2Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2Q0FBUztBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVc7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCxzRUFBZ0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFXO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwwQ0FBTTtBQUM5RCxPQUFPO0FBQ1A7QUFDQSx3REFBd0QsMENBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSw4REFBVztBQUMvSSwyQkFBMkIseUNBQUs7QUFDaEMsZ0NBQWdDLDZDQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDBDQUFNO0FBQ2hGLG1EQUFtRCw2Q0FBUztBQUM1RDtBQUNBLHFEQUFxRCw2Q0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL3NtYXJ0LXdhbGxldC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLXNtYXJ0LXdhbGxldC5icm93c2VyLmVzbS5qcz8yMTY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEMgYXMgQ29ubmVjdG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9jb25uZWN0b3ItMDU2ODlkNjguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgdXRpbHMsIEJpZ051bWJlciwgcHJvdmlkZXJzLCBTaWduZXIsIGV0aGVycywgQ29udHJhY3QsIGNvbnN0YW50cyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBpIGFzIGlzVHdVcmwgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L3VybC1hNDUyMTliZC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBzIGFzIHNldEFuYWx5dGljc0hlYWRlcnMgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2hlYWRlcnMtMGRiNjMwMmEuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgTSBhcyBNQU5BR0VEX0FDQ09VTlRfR0FTX0JVRkZFUiwgYyBhcyBjaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLCBBIGFzIEFDQ09VTlRfQ09SRV9BQkksIEUgYXMgRU5UUllQT0lOVF9BRERSRVNTIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9jb25zdGFudHMtNTA5OTQwYzAuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgRW50cnlQb2ludF9fZmFjdG9yeSB9IGZyb20gJ0BhY2NvdW50LWFic3RyYWN0aW9uL2NvbnRyYWN0cyc7XG5pbXBvcnQgeyBfIGFzIF9kZWZpbmVQcm9wZXJ0eSB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvZGVmaW5lUHJvcGVydHktMzUwZmM1MDguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgc2lnblR5cGVkRGF0YUludGVybmFsLCBnZXREeW5hbWljRmVlRGF0YSwgVGhpcmR3ZWJTREssIExPQ0FMX05PREVfUEtFWSwgZ2V0Q2hhaW5Qcm92aWRlciwgZ2V0R2FzUHJpY2UgfSBmcm9tICdAdGhpcmR3ZWItZGV2L3Nkayc7XG5pbXBvcnQgeyBjaGFpbklkVG9UaGlyZHdlYlJwYyB9IGZyb20gJy4uLy4uLy4uL3dhbGxldHMvYWJzdHJhY3QvZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0td2FsbGV0cy1hYnN0cmFjdC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBDZWxvLCBDZWxvQWxmYWpvcmVzVGVzdG5ldCwgQ2Vsb0Jha2xhdmFUZXN0bmV0IH0gZnJvbSAnQHRoaXJkd2ViLWRldi9jaGFpbnMnO1xuaW1wb3J0ICdldmVudGVtaXR0ZXIzJztcblxuYXN5bmMgZnVuY3Rpb24gaGV4bGlmeVVzZXJPcChvcCkge1xuICBjb25zdCB1c2VyT3AgPSBhd2FpdCB1dGlscy5yZXNvbHZlUHJvcGVydGllcyhvcCk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh1c2VyT3ApLm1hcChrZXkgPT4ge1xuICAgIGxldCB2YWwgPSB1c2VyT3Bba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgdmFsID0gdXRpbHMuaGV4VmFsdWUodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIFtrZXksIHZhbF07XG4gIH0pLnJlZHVjZSgoc2V0LCBfcmVmKSA9PiB7XG4gICAgbGV0IFtrLCB2XSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNldCxcbiAgICAgIFtrXTogdlxuICAgIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gdjAuNiB1c2VyT3BIYXNoIGNhbGN1bGF0aW9uXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyT3BIYXNoVjA2KHVzZXJPcCwgZW50cnlQb2ludCwgY2hhaW5JZCkge1xuICBjb25zdCBvcCA9IGF3YWl0IHV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKHVzZXJPcCk7XG4gIGNvbnN0IGhhc2hlZFVzZXJPcCA9IHtcbiAgICBzZW5kZXI6IG9wLnNlbmRlcixcbiAgICBub25jZTogb3Aubm9uY2UsXG4gICAgaW5pdENvZGVIYXNoOiB1dGlscy5rZWNjYWsyNTYob3AuaW5pdENvZGUpLFxuICAgIGNhbGxEYXRhSGFzaDogdXRpbHMua2VjY2FrMjU2KG9wLmNhbGxEYXRhKSxcbiAgICBjYWxsR2FzTGltaXQ6IG9wLmNhbGxHYXNMaW1pdCxcbiAgICB2ZXJpZmljYXRpb25HYXNMaW1pdDogb3AudmVyaWZpY2F0aW9uR2FzTGltaXQsXG4gICAgcHJlVmVyaWZpY2F0aW9uR2FzOiBvcC5wcmVWZXJpZmljYXRpb25HYXMsXG4gICAgbWF4RmVlUGVyR2FzOiBvcC5tYXhGZWVQZXJHYXMsXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG9wLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgIHBheW1hc3RlckFuZERhdGFIYXNoOiB1dGlscy5rZWNjYWsyNTYob3AucGF5bWFzdGVyQW5kRGF0YSlcbiAgfTtcbiAgY29uc3QgdXNlck9wVHlwZSA9IHtcbiAgICBjb21wb25lbnRzOiBbe1xuICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICBuYW1lOiBcInNlbmRlclwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICBuYW1lOiBcIm5vbmNlXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIG5hbWU6IFwiaW5pdENvZGVIYXNoXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIG5hbWU6IFwiY2FsbERhdGFIYXNoXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIG5hbWU6IFwiY2FsbEdhc0xpbWl0XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIG5hbWU6IFwidmVyaWZpY2F0aW9uR2FzTGltaXRcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJwcmVWZXJpZmljYXRpb25HYXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJtYXhGZWVQZXJHYXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICBuYW1lOiBcInBheW1hc3RlckFuZERhdGFIYXNoXCJcbiAgICB9XSxcbiAgICBuYW1lOiBcImhhc2hlZFVzZXJPcFwiLFxuICAgIHR5cGU6IFwidHVwbGVcIlxuICB9O1xuICBjb25zdCBlbmNvZGVkID0gdXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShbdXNlck9wVHlwZV0sIFt7XG4gICAgLi4uaGFzaGVkVXNlck9wXG4gIH1dKTtcbiAgLy8gcmVtb3ZlIGxlYWRpbmcgd29yZCAodG90YWwgbGVuZ3RoKSBhbmQgdHJhaWxpbmcgd29yZCAoemVyby1sZW5ndGggc2lnbmF0dXJlKVxuXG4gIGNvbnN0IHVzZXJPcEhhc2ggPSB1dGlscy5rZWNjYWsyNTYoZW5jb2RlZCk7XG4gIGNvbnN0IGVuYyA9IHV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoW1wiYnl0ZXMzMlwiLCBcImFkZHJlc3NcIiwgXCJ1aW50MjU2XCJdLCBbdXNlck9wSGFzaCwgZW50cnlQb2ludCwgY2hhaW5JZF0pO1xuICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KGVuYyk7XG59XG5jb25zdCBnZW5lcmF0ZVJhbmRvbVVpbnQxOTIgPSAoKSA9PiB7XG4gIGNvbnN0IHJhbmQxID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQyID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQzID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQ0ID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQ1ID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQ2ID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIHJldHVybiByYW5kMSA8PCBCaWdJbnQoMTYwKSB8IHJhbmQyIDw8IEJpZ0ludCgxMjgpIHwgcmFuZDMgPDwgQmlnSW50KDk2KSB8IHJhbmQ0IDw8IEJpZ0ludCg2NCkgfCByYW5kNSA8PCBCaWdJbnQoMzIpIHwgcmFuZDY7XG59O1xuY29uc3QgcmFuZG9tTm9uY2UgPSAoKSA9PiB7XG4gIGxldCBoZXhTdHJpbmcgPSBnZW5lcmF0ZVJhbmRvbVVpbnQxOTIoKS50b1N0cmluZygxNik7XG4gIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIGhleFN0cmluZyA9IFwiMFwiICsgaGV4U3RyaW5nO1xuICB9XG4gIGhleFN0cmluZyA9IFwiMHhcIiArIGhleFN0cmluZztcbiAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHV0aWxzLmNvbmNhdChbaGV4U3RyaW5nLCBcIjB4MDAwMDAwMDAwMDAwMDAwMFwiXSkpO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogYW4gQVBJIHRvIGV4dGVybmFsIGEgVXNlck9wZXJhdGlvbiB3aXRoIHBheW1hc3RlciBpbmZvXG4gKi9cbmNsYXNzIFBheW1hc3RlckFQSSB7fVxuXG5jb25zdCBERUJVRyA9IGZhbHNlOyAvLyBUT0RPIHNldCBhcyBwdWJsaWMgZmxhZ1xuXG5jbGFzcyBIdHRwUnBjQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYnVuZGxlclVybCwgZW50cnlQb2ludEFkZHJlc3MsIGNoYWluSWQsIGNsaWVudElkLCBzZWNyZXRLZXkpIHtcbiAgICB0aGlzLmJ1bmRsZXJVcmwgPSBidW5kbGVyVXJsO1xuICAgIHRoaXMuZW50cnlQb2ludEFkZHJlc3MgPSBlbnRyeVBvaW50QWRkcmVzcztcbiAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAoaXNUd1VybCh0aGlzLmJ1bmRsZXJVcmwpKSB7XG4gICAgICBjb25zdCBidW5kbGVJZCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiQVBQX0JVTkRMRV9JRFwiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLkFQUF9CVU5ETEVfSUQgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2VjcmV0S2V5KSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LXNlY3JldC1rZXlcIl0gPSBzZWNyZXRLZXk7XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudElkKSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWNsaWVudC1pZFwiXSA9IGNsaWVudElkO1xuICAgICAgICBpZiAoYnVuZGxlSWQpIHtcbiAgICAgICAgICBoZWFkZXJzW1wieC1idW5kbGUtaWRcIl0gPSBidW5kbGVJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEYXNoYm9hcmQgdG9rZW5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIENMSSB0b2tlblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQ0xJX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQ0xJX0FVVEhfVE9LRU59YDtcbiAgICAgICAgaGVhZGVyc1tcIngtYXV0aG9yaXplLXdhbGxldFwiXSA9IFwidHJ1ZVwiO1xuICAgICAgfVxuICAgICAgc2V0QW5hbHl0aWNzSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlN0YXRpY0pzb25ScGNQcm92aWRlcih7XG4gICAgICB1cmw6IHRoaXMuYnVuZGxlclVybCxcbiAgICAgIGhlYWRlcnNcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcIkNvbm5lY3RlZCBidW5kbGVyIG5ldHdvcmtcIixcbiAgICAgIGNoYWluSWRcbiAgICB9KTtcbiAgICB0aGlzLmluaXRpYWxpemluZyA9IHRoaXMudmFsaWRhdGVDaGFpbklkKCk7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGVDaGFpbklkKCkge1xuICAgIC8vIHZhbGlkYXRlIGNoYWluSWQgaXMgaW4gc3luYyB3aXRoIGV4cGVjdGVkIGNoYWluaWRcbiAgICBjb25zdCBjaGFpbiA9IGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgY29uc3QgYnVuZGxlckNoYWluID0gcGFyc2VJbnQoY2hhaW4pO1xuICAgIGlmIChidW5kbGVyQ2hhaW4gIT09IHRoaXMuY2hhaW5JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBidW5kbGVyICR7dGhpcy5idW5kbGVyVXJsfSBpcyBvbiBjaGFpbklkICR7YnVuZGxlckNoYWlufSwgYnV0IHByb3ZpZGVyIGlzIG9uIGNoYWluSWQgJHt0aGlzLmNoYWluSWR9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNlbmQgYSBVc2VyT3BlcmF0aW9uIHRvIHRoZSBidW5kbGVyXG4gICAqIEBwYXJhbSB1c2VyT3AxIC0gVGhlIFVzZXJPcGVyYXRpb24gdG8gc2VuZFxuICAgKiBAcmV0dXJucyB1c2VyT3BIYXNoIHRoZSBpZCBvZiB0aGlzIG9wZXJhdGlvbiwgZm9yIGdldFVzZXJPcGVyYXRpb25UcmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgc2VuZFVzZXJPcFRvQnVuZGxlcih1c2VyT3AxKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgY29uc3QgaGV4aWZpZWRVc2VyT3AgPSBhd2FpdCBoZXhsaWZ5VXNlck9wKHVzZXJPcDEpO1xuICAgIGNvbnN0IGpzb25SZXF1ZXN0RGF0YSA9IFtoZXhpZmllZFVzZXJPcCwgdGhpcy5lbnRyeVBvaW50QWRkcmVzc107XG4gICAgYXdhaXQgdGhpcy5wcmludFVzZXJPcGVyYXRpb24oXCJldGhfc2VuZFVzZXJPcGVyYXRpb25cIiwganNvblJlcXVlc3REYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVXNlck9wZXJhdGlvblwiLCBbaGV4aWZpZWRVc2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3NdKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZVVzZXJPcEdhcyh1c2VyT3ApIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemluZztcbiAgICBjb25zdCBoZXhpZmllZFVzZXJPcCA9IGF3YWl0IGhleGxpZnlVc2VyT3AodXNlck9wKTtcbiAgICBjb25zdCBqc29uUmVxdWVzdERhdGEgPSBbaGV4aWZpZWRVc2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3NdO1xuICAgIGF3YWl0IHRoaXMucHJpbnRVc2VyT3BlcmF0aW9uKFwiZXRoX2VzdGltYXRlVXNlck9wZXJhdGlvbkdhc1wiLCBqc29uUmVxdWVzdERhdGEpO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwiZXRoX2VzdGltYXRlVXNlck9wZXJhdGlvbkdhc1wiLCBbaGV4aWZpZWRVc2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3NdKTtcbiAgICAvLyBhZGRzIGdhcyBidWZmZXIgdG8gY2FsbEdhc0xpbWl0IHRvIGFjY291bnQgZm9yIE1hbmFnZWRBY2NvdW50RmFjdG9yeSBkZWxlZ2F0ZSBjYWxsc1xuICAgIHJldHVybiB7XG4gICAgICBwcmVWZXJpZmljYXRpb25HYXM6IEJpZ051bWJlci5mcm9tKGRhdGEucHJlVmVyaWZpY2F0aW9uR2FzKSxcbiAgICAgIHZlcmlmaWNhdGlvbkdhczogQmlnTnVtYmVyLmZyb20oZGF0YS52ZXJpZmljYXRpb25HYXMpLFxuICAgICAgdmVyaWZpY2F0aW9uR2FzTGltaXQ6IEJpZ051bWJlci5mcm9tKGRhdGEudmVyaWZpY2F0aW9uR2FzTGltaXQpLFxuICAgICAgY2FsbEdhc0xpbWl0OiBCaWdOdW1iZXIuZnJvbShkYXRhLmNhbGxHYXNMaW1pdCkuYWRkKE1BTkFHRURfQUNDT1VOVF9HQVNfQlVGRkVSKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlKCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6aW5nO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwidGhpcmR3ZWJfZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlXCIsIFtdKTtcbiAgfVxuICBhc3luYyBnZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCh1c2VyT3BIYXNoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0VXNlck9wZXJhdGlvblJlY2VpcHRcIiwgW3VzZXJPcEhhc2hdKTtcbiAgfVxuICBhc3luYyBwcmludFVzZXJPcGVyYXRpb24obWV0aG9kLCBfcmVmKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBWZXJpZnlpbmdQYXltYXN0ZXJBUEkgZXh0ZW5kcyBQYXltYXN0ZXJBUEkge1xuICBjb25zdHJ1Y3RvcihwYXltYXN0ZXJVcmwsIGVudHJ5UG9pbnQsIGNsaWVudElkLCBzZWNyZXRLZXkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucGF5bWFzdGVyVXJsID0gcGF5bWFzdGVyVXJsO1xuICAgIHRoaXMuZW50cnlQb2ludCA9IGVudHJ5UG9pbnQ7XG4gICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIHRoaXMuc2VjcmV0S2V5ID0gc2VjcmV0S2V5O1xuICB9XG4gIGFzeW5jIGdldFBheW1hc3RlckFuZERhdGEodXNlck9wKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfTtcbiAgICBpZiAoaXNUd1VybCh0aGlzLnBheW1hc3RlclVybCkpIHtcbiAgICAgIGlmICh0aGlzLnNlY3JldEtleSAmJiB0aGlzLmNsaWVudElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYm90aCBzZWNyZXQga2V5IGFuZCBjbGllbnQgSUQuIFBsZWFzZSB1c2Ugc2VjcmV0S2V5IGZvciBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbnMgYW5kIGNsaWVudElkIGZvciBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbnMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VjcmV0S2V5KSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LXNlY3JldC1rZXlcIl0gPSB0aGlzLnNlY3JldEtleTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGllbnRJZCkge1xuICAgICAgICBoZWFkZXJzW1wieC1jbGllbnQtaWRcIl0gPSB0aGlzLmNsaWVudElkO1xuICAgICAgICBjb25zdCBidW5kbGVJZCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiQVBQX0JVTkRMRV9JRFwiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLkFQUF9CVU5ETEVfSUQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChidW5kbGVJZCkge1xuICAgICAgICAgIGhlYWRlcnNbXCJ4LWJ1bmRsZS1pZFwiXSA9IGJ1bmRsZUlkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERhc2hib2FyZCB0b2tlbi5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIENMSSB0b2tlbi5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0NMSV9BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOfWA7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWF1dGhvcml6ZS13YWxsZXRcIl0gPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICAgIHNldEFuYWx5dGljc0hlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuXG4gICAgLy8gQXNrIHRoZSBwYXltYXN0ZXIgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gYW5kIHJldHVybiBhIHZhbGlkIHBheW1hc3RlckFuZERhdGEgdmFsdWUuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnBheW1hc3RlclVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGlkOiAxLFxuICAgICAgICBtZXRob2Q6IFwicG1fc3BvbnNvclVzZXJPcGVyYXRpb25cIixcbiAgICAgICAgcGFyYW1zOiBbYXdhaXQgaGV4bGlmeVVzZXJPcCh1c2VyT3ApLCB0aGlzLmVudHJ5UG9pbnRdXG4gICAgICB9KVxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHJlcy5lcnJvciB8fCByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgY29uc3QgY29kZSA9IHJlcy5jb2RlIHx8IFwiVU5LTk9XTlwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXltYXN0ZXIgZXJyb3I6ICR7ZXJyb3J9XG5TdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfVxuQ29kZTogJHtjb2RlfWApO1xuICAgIH1cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJQYXltYXN0ZXIgcmVzdWx0OlwiLCByZXMpO1xuICAgIH1cbiAgICBpZiAocmVzLnJlc3VsdCkge1xuICAgICAgLy8gc29tZSBwYXltYXN0ZXJzIHJldHVybiBhIHN0cmluZywgc29tZSByZXR1cm4gYW4gb2JqZWN0IHdpdGggbW9yZSBkYXRhXG4gICAgICBpZiAodHlwZW9mIHJlcy5yZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXltYXN0ZXJBbmREYXRhOiByZXMucmVzdWx0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSByZXMuZXJyb3I/Lm1lc3NhZ2UgfHwgcmVzLmVycm9yIHx8IHJlc3BvbnNlLnN0YXR1c1RleHQgfHwgXCJ1bmtub3duIGVycm9yXCI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBheW1hc3RlciBlcnJvciBmcm9tICR7dGhpcy5wYXltYXN0ZXJVcmx9OiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxufVxuY29uc3QgZ2V0VmVyaWZ5aW5nUGF5bWFzdGVyID0gKHBheW1hc3RlclVybCwgZW50cnlQb2ludCwgY2xpZW50SWQsIHNlY3JldEtleSkgPT4gbmV3IFZlcmlmeWluZ1BheW1hc3RlckFQSShwYXltYXN0ZXJVcmwsIGVudHJ5UG9pbnQsIGNsaWVudElkLCBzZWNyZXRLZXkpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIEV0aGVycy5qcyBsaXN0ZW5lciBmdW5jdGlvbiBhbmQgbmVjZXNzYXJ5IFVzZXJPcGVyYXRpb24gZGV0YWlscyB0b1xuICogZGlzY292ZXIgYSBUcmFuc2FjdGlvblJlY2VpcHQgZm9yIHRoZSBvcGVyYXRpb24uXG4gKlxuICogVE9ETyByZWZhY3RvciB0aGlzIHRvIGEgc2ltcGxlIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBlbnRyeSBwb2ludFxuICovXG5jbGFzcyBVc2VyT3BlcmF0aW9uRXZlbnRMaXN0ZW5lciB7XG4gIGNvbnN0cnVjdG9yKHJlc29sdmUsIHJlamVjdCwgZW50cnlQb2ludCwgc2VuZGVyLCB1c2VyT3BIYXNoLCBub25jZSwgdGltZW91dCkge1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5lbnRyeVBvaW50ID0gZW50cnlQb2ludDtcbiAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgICB0aGlzLnVzZXJPcEhhc2ggPSB1c2VyT3BIYXNoO1xuICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc29sdmVkXCIsIGZhbHNlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICB0aGlzLmJvdW5kTGlzZW5lciA9IHRoaXMubGlzdGVuZXJDYWxsYmFjay5iaW5kKHRoaXMpO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZW50cnlQb2ludC5maWx0ZXJzLlVzZXJPcGVyYXRpb25FdmVudCh0aGlzLnVzZXJPcEhhc2gpO1xuICAgIC8vIGxpc3RlbmVyIHRha2VzIHRpbWUuLi4gZmlyc3QgcXVlcnkgZGlyZWN0bHk6XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmVudHJ5UG9pbnQucXVlcnlGaWx0ZXIoZmlsdGVyLCAtMTApOyAvLyBsb29rIGF0IGxhc3QgMTAgYmxvY2tzXG4gICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdm9pZCB0aGlzLmxpc3RlbmVyQ2FsbGJhY2socmVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW50cnlQb2ludC5vbmNlKGZpbHRlciwgdGhpcy5ib3VuZExpc2VuZXIpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICB0aGlzLmVudHJ5UG9pbnQub2ZmKFwiVXNlck9wZXJhdGlvbkV2ZW50XCIsIHRoaXMuYm91bmRMaXNlbmVyKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgYXN5bmMgbGlzdGVuZXJDYWxsYmFjaygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW0gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwYXJhbVtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgLy8gVE9ETyBjbGVhbiB0aGlzIHVwLi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgY29uc3QgZXZlbnQgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghZXZlbnQuYXJncykge1xuICAgICAgY29uc29sZS5lcnJvcihcImdvdCBldmVudCB3aXRob3V0IGFyZ3NcIiwgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjYW4gdGhpcyBoYXBwZW4/IHdlIHJlZ2lzdGVyIHRvIGV2ZW50IGJ5IHVzZXJPcEhhc2guLlxuICAgIGlmIChldmVudC5hcmdzLnVzZXJPcEhhc2ggIT09IHRoaXMudXNlck9wSGFzaCkge1xuICAgICAgY29uc29sZS5sb2coYD09IGV2ZW50IHdpdGggd3JvbmcgdXNlck9wSGFzaDogc2VuZGVyL25vbmNlOiBldmVudC4ke2V2ZW50LmFyZ3Muc2VuZGVyfUAke2V2ZW50LmFyZ3Mubm9uY2UudG9TdHJpbmcoKX0hPSB1c2VyT3AuJHt0aGlzLnNlbmRlcn1AJHtwYXJzZUludCh0aGlzLm5vbmNlPy50b1N0cmluZygpKX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZWNlaXB0ID0gYXdhaXQgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCk7XG5cbiAgICAvLyBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZWNlaXB0LCB1cGRhdGUgdGhlIHN0YXR1cyBmcm9tIHRoZSBldmVudC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgaWYgKCFldmVudC5hcmdzLnN1Y2Nlc3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEZhaWx1cmVSZWFzb24odHJhbnNhY3Rpb25SZWNlaXB0KTtcbiAgICB9XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5yZXNvbHZlKHRyYW5zYWN0aW9uUmVjZWlwdCk7XG4gICAgdGhpcy5yZXNvbHZlZCA9IHRydWU7XG4gIH1cbiAgYXN5bmMgZXh0cmFjdEZhaWx1cmVSZWFzb24ocmVjZWlwdCkge1xuICAgIHJlY2VpcHQuc3RhdHVzID0gMDtcbiAgICBjb25zdCByZXZlcnRSZWFzb25FdmVudHMgPSBhd2FpdCB0aGlzLmVudHJ5UG9pbnQucXVlcnlGaWx0ZXIodGhpcy5lbnRyeVBvaW50LmZpbHRlcnMuVXNlck9wZXJhdGlvblJldmVydFJlYXNvbih0aGlzLnVzZXJPcEhhc2gsIHRoaXMuc2VuZGVyKSwgcmVjZWlwdC5ibG9ja0hhc2gpO1xuICAgIGlmIChyZXZlcnRSZWFzb25FdmVudHNbMF0pIHtcbiAgICAgIGxldCBtZXNzYWdlID0gcmV2ZXJ0UmVhc29uRXZlbnRzWzBdLmFyZ3MucmV2ZXJ0UmVhc29uO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcIjB4MDhjMzc5YTBcIikpIHtcbiAgICAgICAgLy8gRXJyb3Ioc3RyaW5nKVxuICAgICAgICBtZXNzYWdlID0gdXRpbHMuZGVmYXVsdEFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIFwiMHhcIiArIG1lc3NhZ2Uuc3Vic3RyaW5nKDEwKSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVqZWN0KG5ldyBFcnJvcihgVXNlck9wIGZhaWxlZCB3aXRoIHJlYXNvbjogJHttZXNzYWdlfWApKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRVJDNDMzN0V0aGVyc1NpZ25lciBleHRlbmRzIFNpZ25lciB7XG4gIC8vIFRPRE86IHdlIGhhdmUgJ2VyYzQzMzdwcm92aWRlcicsIHJlbW92ZSBzaGFyZWQgZGVwZW5kZW5jaWVzIG9yIGF2b2lkIHR3by13YXkgcmVmZXJlbmNlXG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgb3JpZ2luYWxTaWduZXIsIGVyYzQzMzdwcm92aWRlciwgaHR0cFJwY0NsaWVudCwgc21hcnRBY2NvdW50QVBJKSB7XG4gICAgc3VwZXIoKTtcbiAgICB1dGlscy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIGVyYzQzMzdwcm92aWRlcik7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5vcmlnaW5hbFNpZ25lciA9IG9yaWdpbmFsU2lnbmVyO1xuICAgIHRoaXMuZXJjNDMzN3Byb3ZpZGVyID0gZXJjNDMzN3Byb3ZpZGVyO1xuICAgIHRoaXMuaHR0cFJwY0NsaWVudCA9IGh0dHBScGNDbGllbnQ7XG4gICAgdGhpcy5zbWFydEFjY291bnRBUEkgPSBzbWFydEFjY291bnRBUEk7XG4gICAgdGhpcy5hcHByb3ZpbmcgPSBmYWxzZTtcbiAgfVxuICAvLyBUaGlzIG9uZSBpcyBjYWxsZWQgYnkgQ29udHJhY3QuIEl0IHNpZ25zIHRoZSByZXF1ZXN0IGFuZCBwYXNzZXMgaW4gdG8gUHJvdmlkZXIgdG8gYmUgc2VudC5cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFwcHJvdmluZykge1xuICAgICAgdGhpcy5hcHByb3ZpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5jcmVhdGVBcHByb3ZlVHgoKTtcbiAgICAgIGlmICh0eCkge1xuICAgICAgICBhd2FpdCAoYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24odHgpKS53YWl0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcHJvdmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IGF3YWl0IGV0aGVycy51dGlscy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbik7XG4gICAgYXdhaXQgdGhpcy52ZXJpZnlBbGxOZWNlc3NhcnlGaWVsZHModHgpO1xuICAgIGNvbnN0IG11bHRpZGltZW5zaW9uYWxOb25jZSA9IHJhbmRvbU5vbmNlKCk7XG4gICAgY29uc3QgdW5zaWduZWQgPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5jcmVhdGVVbnNpZ25lZFVzZXJPcCh0aGlzLmh0dHBScGNDbGllbnQsIHtcbiAgICAgIHRhcmdldDogdHgudG8gfHwgXCJcIixcbiAgICAgIGRhdGE6IHR4LmRhdGE/LnRvU3RyaW5nKCkgfHwgXCIweFwiLFxuICAgICAgdmFsdWU6IHR4LnZhbHVlLFxuICAgICAgZ2FzTGltaXQ6IHR4Lmdhc0xpbWl0LFxuICAgICAgbm9uY2U6IG11bHRpZGltZW5zaW9uYWxOb25jZSxcbiAgICAgIG1heEZlZVBlckdhczogdHgubWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdXNlck9wZXJhdGlvbiA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLnNpZ25Vc2VyT3AodW5zaWduZWQpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmVyYzQzMzdwcm92aWRlci5jb25zdHJ1Y3RVc2VyT3BUcmFuc2FjdGlvblJlc3BvbnNlKHVzZXJPcGVyYXRpb24pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmh0dHBScGNDbGllbnQuc2VuZFVzZXJPcFRvQnVuZGxlcih1c2VyT3BlcmF0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy51bndyYXBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvcnMgLSB0cmFuc2FjdGlvbiB0aGF0IGlzIFwicmVqZWN0ZWRcIiBieSBidW5kbGVyIGlzIF9ub3QgbGlrZWx5XyB0byBldmVyIHJlc29sdmUgaXRzIFwid2FpdCgpXCJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZXNwb25zZTtcbiAgfVxuICB1bndyYXBFcnJvcihlcnJvckluKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBlcnJvck1zZyA9IFwiVW5rbm93biBFcnJvclwiO1xuICAgICAgaWYgKGVycm9ySW4uZXJyb3IpIHtcbiAgICAgICAgZXJyb3JNc2cgPSBgVGhlIGJ1bmRsZXIgaGFzIGZhaWxlZCB0byBpbmNsdWRlIFVzZXJPcGVyYXRpb24gaW4gYSBiYXRjaDogJHtlcnJvckluLmVycm9yfWA7XG4gICAgICB9IGVsc2UgaWYgKGVycm9ySW4uYm9keSAmJiB0eXBlb2YgZXJyb3JJbi5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQm9keSA9IEpTT04ucGFyc2UoZXJyb3JJbi5ib2R5KTtcbiAgICAgICAgY29uc3QgZXJyb3JTdGF0dXMgPSBlcnJvckluLnN0YXR1cyB8fCBcIlVOS05PV05cIjtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3JCb2R5Py5jb2RlIHx8IFwiVU5LTk9XTlwiO1xuICAgICAgICBsZXQgZmFpbGVkT3BNZXNzYWdlID0gZXJyb3JCb2R5Py5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvckJvZHk/LmVycm9yPy5kYXRhIHx8IGVycm9yQm9keT8uZXJyb3IgfHwgZXJyb3JJbi5yZWFzb247XG4gICAgICAgIGlmIChmYWlsZWRPcE1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkT3BcIikpIHtcbiAgICAgICAgICBsZXQgcGF5bWFzdGVySW5mbyA9IFwiXCI7XG4gICAgICAgICAgLy8gVE9ETzogYmV0dGVyIGVycm9yIGV4dHJhY3Rpb24gbWV0aG9kcyB3aWxsIGJlIG5lZWRlZFxuICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBmYWlsZWRPcE1lc3NhZ2UubWF0Y2goL0ZhaWxlZE9wXFwoKC4qKVxcKS8pO1xuICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpdCA9IG1hdGNoZWRbMV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgcGF5bWFzdGVySW5mbyA9IGAocGF5bWFzdGVyIGFkZHJlc3M6ICR7c3BsaXRbMV19KWA7XG4gICAgICAgICAgICBmYWlsZWRPcE1lc3NhZ2UgPSBzcGxpdFsyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3JNc2cgPSBgVGhlIGJ1bmRsZXIgaGFzIGZhaWxlZCB0byBpbmNsdWRlIFVzZXJPcGVyYXRpb24gaW4gYSBiYXRjaDogJHtmYWlsZWRPcE1lc3NhZ2V9ICR7cGF5bWFzdGVySW5mb31gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yTXNnID0gYFJQQyBlcnJvcjogJHtmYWlsZWRPcE1lc3NhZ2V9XG5TdGF0dXM6ICR7ZXJyb3JTdGF0dXN9XG5Db2RlOiAke2Vycm9yQ29kZX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICBlcnJvci5zdGFjayA9IGVycm9ySW4uc3RhY2s7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgcmV0dXJuIGVycm9ySW47XG4gIH1cbiAgYXN5bmMgdmVyaWZ5QWxsTmVjZXNzYXJ5RmllbGRzKHRyYW5zYWN0aW9uUmVxdWVzdCkge1xuICAgIGlmICghdHJhbnNhY3Rpb25SZXF1ZXN0LnRvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNhbGwgdGFyZ2V0XCIpO1xuICAgIH1cbiAgICBpZiAoIXRyYW5zYWN0aW9uUmVxdWVzdC5kYXRhICYmICF0cmFuc2FjdGlvblJlcXVlc3QudmFsdWUpIHtcbiAgICAgIC8vIFRCRDogYmFubmluZyBuby1vcCBVc2VyT3BzIHNlZW1zIHRvIG1ha2Ugc2Vuc2Ugb24gcHJvdmlkZXIgbGV2ZWxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY2FsbCBkYXRhIG9yIHZhbHVlXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29ubmVjdChwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5naW5nIHByb3ZpZGVycyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgaWYgKCF0aGlzLmFkZHJlc3MpIHtcbiAgICAgIHRoaXMuYWRkcmVzcyA9IGF3YWl0IHRoaXMuZXJjNDMzN3Byb3ZpZGVyLmdldFNlbmRlckFjY291bnRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhIG1lc3NhZ2UgYW5kIHJldHVybiB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgLy8gRGVwbG95IHNtYXJ0IHdhbGxldCBpZiBuZWVkZWRcbiAgICBjb25zdCBpc05vdERlcGxveWVkID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuY2hlY2tBY2NvdW50UGhhbnRvbSgpO1xuICAgIGlmIChpc05vdERlcGxveWVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkFjY291bnQgY29udHJhY3Qgbm90IGRlcGxveWVkIHlldC4gRGVwbG95aW5nIGFjY291bnQgYmVmb3JlIHNpZ25pbmcgbWVzc2FnZVwiKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICB0bzogYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksXG4gICAgICAgIGRhdGE6IFwiMHhcIlxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgfVxuICAgIGNvbnN0IFtjaGFpbklkLCBhZGRyZXNzXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmdldENoYWluSWQoKSwgdGhpcy5nZXRBZGRyZXNzKCldKTtcbiAgICBjb25zdCBvcmlnaW5hbE1zZ0hhc2ggPSB1dGlscy5oYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICBsZXQgZmFjdG9yeVN1cHBvcnRzNzEyO1xuICAgIGxldCBzaWduYXR1cmU7XG4gICAgY29uc3QgcnBjVXJsID0gY2hhaW5JZFRvVGhpcmR3ZWJScGMoY2hhaW5JZCwgdGhpcy5jb25maWcuY2xpZW50SWQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAoaXNUd1VybChycGNVcmwpKSB7XG4gICAgICBjb25zdCBidW5kbGVJZCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiQVBQX0JVTkRMRV9JRFwiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLkFQUF9CVU5ETEVfSUQgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5jb25maWcuc2VjcmV0S2V5KSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LXNlY3JldC1rZXlcIl0gPSB0aGlzLmNvbmZpZy5zZWNyZXRLZXk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLmNsaWVudElkKSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWNsaWVudC1pZFwiXSA9IHRoaXMuY29uZmlnLmNsaWVudElkO1xuICAgICAgICBpZiAoYnVuZGxlSWQpIHtcbiAgICAgICAgICBoZWFkZXJzW1wieC1idW5kbGUtaWRcIl0gPSBidW5kbGVJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEYXNoYm9hcmQgdG9rZW5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIENMSSB0b2tlblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQ0xJX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQ0xJX0FVVEhfVE9LRU59YDtcbiAgICAgICAgaGVhZGVyc1tcIngtYXV0aG9yaXplLXdhbGxldFwiXSA9IFwidHJ1ZVwiO1xuICAgICAgfVxuICAgICAgc2V0QW5hbHl0aWNzSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5TdGF0aWNKc29uUnBjUHJvdmlkZXIoe1xuICAgICAgICB1cmw6IHJwY1VybCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSwgY2hhaW5JZCk7XG4gICAgICBjb25zdCB3YWxsZXRDb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBbXCJmdW5jdGlvbiBnZXRNZXNzYWdlSGFzaChieXRlczMyIF9oYXNoKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczMyKVwiXSwgcHJvdmlkZXIpO1xuICAgICAgLy8gaWYgdGhpcyBmYWlscyBpdCdzIGEgcHJlIDcxMiBmYWN0b3J5XG4gICAgICBhd2FpdCB3YWxsZXRDb250cmFjdC5nZXRNZXNzYWdlSGFzaChvcmlnaW5hbE1zZ0hhc2gpO1xuICAgICAgZmFjdG9yeVN1cHBvcnRzNzEyID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZhY3RvcnlTdXBwb3J0czcxMiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmFjdG9yeVN1cHBvcnRzNzEyKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduVHlwZWREYXRhSW50ZXJuYWwodGhpcywge1xuICAgICAgICBuYW1lOiBcIkFjY291bnRcIixcbiAgICAgICAgdmVyc2lvbjogXCIxXCIsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBhZGRyZXNzXG4gICAgICB9LCB7XG4gICAgICAgIEFjY291bnRNZXNzYWdlOiBbe1xuICAgICAgICAgIG5hbWU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIlxuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBtZXNzYWdlOiB1dGlscy5kZWZhdWx0QWJpQ29kZXIuZW5jb2RlKFtcImJ5dGVzMzJcIl0sIFtvcmlnaW5hbE1zZ0hhc2hdKVxuICAgICAgfSk7XG4gICAgICBzaWduYXR1cmUgPSByZXN1bHQuc2lnbmF0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLm9yaWdpbmFsU2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZShtZXNzYWdlLCBzaWduYXR1cmUsIGFkZHJlc3MsIGNoYWluSWQsIHRoaXMuY29uZmlnLmNsaWVudElkLCB0aGlzLmNvbmZpZy5zZWNyZXRLZXkpO1xuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gdmVyaWZ5IHNpZ25hdHVyZSBvbiBzbWFydCBhY2NvdW50LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBzbWFydCBhY2NvdW50IGlzIGRlcGxveWVkIGFuZCB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLlwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHggPSBhd2FpdCBldGhlcnMudXRpbHMucmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pO1xuICAgIGF3YWl0IHRoaXMudmVyaWZ5QWxsTmVjZXNzYXJ5RmllbGRzKHR4KTtcbiAgICBjb25zdCBtdWx0aWRpbWVuc2lvbmFsTm9uY2UgPSByYW5kb21Ob25jZSgpO1xuICAgIGNvbnN0IHVuc2lnbmVkID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuY3JlYXRlVW5zaWduZWRVc2VyT3AodGhpcy5odHRwUnBjQ2xpZW50LCB7XG4gICAgICB0YXJnZXQ6IHR4LnRvIHx8IFwiXCIsXG4gICAgICBkYXRhOiB0eC5kYXRhPy50b1N0cmluZygpIHx8IFwiMHhcIixcbiAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgIGdhc0xpbWl0OiB0eC5nYXNMaW1pdCxcbiAgICAgIG5vbmNlOiBtdWx0aWRpbWVuc2lvbmFsTm9uY2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb25zdCB1c2VyT3BlcmF0aW9uID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuc2lnblVzZXJPcCh1bnNpZ25lZCk7XG4gICAgY29uc3QgdXNlck9wU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgaGV4bGlmeVVzZXJPcCh1c2VyT3BlcmF0aW9uKSk7XG4gICAgcmV0dXJuIHVzZXJPcFN0cmluZztcbiAgfVxufVxuXG5jbGFzcyBFUkM0MzM3RXRoZXJzUHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcnMuQmFzZVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IoY2hhaW5JZCwgY29uZmlnLCBvcmlnaW5hbFNpZ25lciwgb3JpZ2luYWxQcm92aWRlciwgaHR0cFJwY0NsaWVudCwgZW50cnlQb2ludCwgc21hcnRBY2NvdW50QVBJKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJFUkMtNDMzNyBDdXN0b20gTmV0d29ya1wiLFxuICAgICAgY2hhaW5JZFxuICAgIH0pO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5vcmlnaW5hbFNpZ25lciA9IG9yaWdpbmFsU2lnbmVyO1xuICAgIHRoaXMub3JpZ2luYWxQcm92aWRlciA9IG9yaWdpbmFsUHJvdmlkZXI7XG4gICAgdGhpcy5odHRwUnBjQ2xpZW50ID0gaHR0cFJwY0NsaWVudDtcbiAgICB0aGlzLmVudHJ5UG9pbnQgPSBlbnRyeVBvaW50O1xuICAgIHRoaXMuc21hcnRBY2NvdW50QVBJID0gc21hcnRBY2NvdW50QVBJO1xuICAgIHRoaXMuc2lnbmVyID0gbmV3IEVSQzQzMzdFdGhlcnNTaWduZXIoY29uZmlnLCBvcmlnaW5hbFNpZ25lciwgdGhpcywgaHR0cFJwY0NsaWVudCwgc21hcnRBY2NvdW50QVBJKTtcbiAgfVxuICBnZXRTaWduZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmVyO1xuICB9XG4gIGFzeW5jIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICBpZiAobWV0aG9kID09PSBcInNlbmRUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIikge1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCAncGVyZm9ybScgbWV0aG9kIHRvIGJlIGF2YWlsYWJsZSBhdCBhbGw/XG4gICAgICAvLyB0aGVyZSBpcyBub2JvZHkgb3V0IHRoZXJlIHRvIHVzZSBpdCBmb3IgRVJDLTQzMzcgbWV0aG9kcyB5ZXQsIHdlIGhhdmUgbm90aGluZyB0byBvdmVycmlkZSBpbiBmYWN0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5vdCBnZXQgaGVyZS4gSW52ZXN0aWdhdGUuXCIpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgIC8vIGdhcyBlc3RpbWF0aW9uIGRvZXMgbm90aGluZyBhdCB0aGlzIGxheWVyLCBzZW5kVHJhbnNhY3Rpb24gd2lsbCBkbyB0aGUgZ2FzIGVzdGltYXRpb24gZm9yIHRoZSB1c2VyT3BcbiAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSg1MDAwMDApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5vcmlnaW5hbFByb3ZpZGVyLnBlcmZvcm0obWV0aG9kLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gYXdhaXQgc3VwZXIuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IHRyYW5zYWN0aW9uSGFzaDtcbiAgICBjb25zdCBzZW5kZXIgPSBhd2FpdCB0aGlzLmdldFNlbmRlckFjY291bnRBZGRyZXNzKCk7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG5ldyBVc2VyT3BlcmF0aW9uRXZlbnRMaXN0ZW5lcihyZXNvbHZlLCByZWplY3QsIHRoaXMuZW50cnlQb2ludCwgc2VuZGVyLCB1c2VyT3BIYXNoKS5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFNlbmRlckFjY291bnRBZGRyZXNzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5nZXRBY2NvdW50QWRkcmVzcygpO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcbiAgICBjb25zdCBzZW5kZXIgPSBhd2FpdCB0aGlzLmdldFNlbmRlckFjY291bnRBZGRyZXNzKCk7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFVzZXJPcGVyYXRpb25FdmVudExpc3RlbmVyKHJlc29sdmUsIHJlamVjdCwgdGhpcy5lbnRyeVBvaW50LCBzZW5kZXIsIHRyYW5zYWN0aW9uSGFzaCwgdW5kZWZpbmVkLCB0aW1lb3V0KTtcbiAgICAgIGxpc3RlbmVyLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmYWJyaWNhdGUgYSByZXNwb25zZSBpbiBhIGZvcm1hdCB1c2FibGUgYnkgZXRoZXJzIHVzZXJzLi4uXG4gIGFzeW5jIGNvbnN0cnVjdFVzZXJPcFRyYW5zYWN0aW9uUmVzcG9uc2UodXNlck9wMSkge1xuICAgIGNvbnN0IHVzZXJPcCA9IGF3YWl0IHV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKHVzZXJPcDEpO1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5nZXRVc2VyT3BIYXNoKHVzZXJPcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc2g6IHVzZXJPcEhhc2gsXG4gICAgICBjb25maXJtYXRpb25zOiAwLFxuICAgICAgZnJvbTogdXNlck9wLnNlbmRlcixcbiAgICAgIG5vbmNlOiAwLFxuICAgICAgLy8gbm90IHRoZSByZWFsIG5vbmNlLCBidXQgZ29vZCBlbm91Z2ggZm9yIHRoaXMgcHVycG9zZVxuICAgICAgZ2FzTGltaXQ6IEJpZ051bWJlci5mcm9tKHVzZXJPcC5jYWxsR2FzTGltaXQpLFxuICAgICAgLy8gPz9cbiAgICAgIHZhbHVlOiBCaWdOdW1iZXIuZnJvbSgwKSxcbiAgICAgIGRhdGE6IHV0aWxzLmhleFZhbHVlKHVzZXJPcC5jYWxsRGF0YSksXG4gICAgICAvLyBzaG91bGQgZXh0cmFjdCB0aGUgYWN0dWFsIGNhbGxlZCBtZXRob2QgZnJvbSB0aGlzIFwiZXhlY0Zyb21FbnRyeVBvaW50KClcIiBjYWxsXG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluSWQsXG4gICAgICB3YWl0OiBhc3luYyBjb25maXJtYXRpb25zID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25SZWNlaXB0ID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuZ2V0VXNlck9wUmVjZWlwdCh0aGlzLmh0dHBScGNDbGllbnQsIHVzZXJPcEhhc2gpO1xuICAgICAgICBpZiAodXNlck9wLmluaXRDb2RlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIC8vIGNoZWNraW5nIGlmIHRoZSB3YWxsZXQgaGFzIGJlZW4gZGVwbG95ZWQgYnkgdGhlIHRyYW5zYWN0aW9uOyBpdCBtdXN0IGJlIGlmIHdlIGFyZSBoZXJlXG4gICAgICAgICAgYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuY2hlY2tBY2NvdW50UGhhbnRvbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvblJlY2VpcHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBkZXRlY3ROZXR3b3JrKCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbmFsUHJvdmlkZXIuZGV0ZWN0TmV0d29yaygpO1xuICB9XG59XG5cbi8qKlxuICogd3JhcCBhbiBleGlzdGluZyBwcm92aWRlciB0byB0dW5uZWwgcmVxdWVzdHMgdGhyb3VnaCBBY2NvdW50IEFic3RyYWN0aW9uLlxuICogQHBhcmFtIG9yaWdpbmFsUHJvdmlkZXIgLSBUaGUgbm9ybWFsIHByb3ZpZGVyXG4gKiBAcGFyYW0gY29uZmlnIC0gc2VlIHtAbGluayBDbGllbnRDb25maWd9IGZvciBtb3JlIGluZm9cbiAqIEBwYXJhbSBvcmlnaW5hbFNpZ25lciAtIHVzZSB0aGlzIHNpZ25lciBhcyB0aGUgb3duZXIuIG9mIHRoaXMgd2FsbGV0LiBCeSBkZWZhdWx0LCB1c2UgdGhlIHByb3ZpZGVyJ3Mgc2lnbmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZTQzMzdQcm92aWRlcihjb25maWcsIGFjY291bnRBcGksIG9yaWdpbmFsUHJvdmlkZXIsIGNoYWluSWQpIHtcbiAgY29uc3QgZW50cnlQb2ludCA9IEVudHJ5UG9pbnRfX2ZhY3RvcnkuY29ubmVjdChjb25maWcuZW50cnlQb2ludEFkZHJlc3MsIG9yaWdpbmFsUHJvdmlkZXIpO1xuICBjb25zdCBodHRwUnBjQ2xpZW50ID0gbmV3IEh0dHBScGNDbGllbnQoY29uZmlnLmJ1bmRsZXJVcmwsIGNvbmZpZy5lbnRyeVBvaW50QWRkcmVzcywgY2hhaW5JZCwgY29uZmlnLmNsaWVudElkLCBjb25maWcuc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5ldyBFUkM0MzM3RXRoZXJzUHJvdmlkZXIoY2hhaW5JZCwgY29uZmlnLCBjb25maWcubG9jYWxTaWduZXIsIG9yaWdpbmFsUHJvdmlkZXIsIGh0dHBScGNDbGllbnQsIGVudHJ5UG9pbnQsIGFjY291bnRBcGkpO1xufVxuXG5jb25zdCBEVU1NWV9TSUdOQVRVUkUgPSBcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDdhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWExY1wiO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBTbWFydCBXYWxsZXQgRVJDLTQzMzcgQ2xpZW50cyB0byBpbXBsZW1lbnQuXG4gKiBTdWJjbGFzcyBzaG91bGQgaW5oZXJpdCA1IG1ldGhvZHMgdG8gc3VwcG9ydCBhIHNwZWNpZmljIHdhbGxldCBjb250cmFjdDpcbiAqXG4gKiAtIGdldEFjY291bnRJbml0Q29kZSAtIHJldHVybiB0aGUgdmFsdWUgdG8gcHV0IGludG8gdGhlIFwiaW5pdENvZGVcIiBmaWVsZCwgaWYgdGhlIGFjY291bnQgaXMgbm90IHlldCBkZXBsb3llZC4gc2hvdWxkIGNyZWF0ZSB0aGUgYWNjb3VudCBpbnN0YW5jZSB1c2luZyBhIGZhY3RvcnkgY29udHJhY3QuXG4gKiAtIGdldE5vbmNlIC0gcmV0dXJuIGN1cnJlbnQgYWNjb3VudCdzIG5vbmNlIHZhbHVlXG4gKiAtIGVuY29kZUV4ZWN1dGUgLSBlbmNvZGUgdGhlIGNhbGwgZnJvbSBlbnRyeVBvaW50IHRocm91Z2ggb3VyIGFjY291bnQgdG8gdGhlIHRhcmdldCBjb250cmFjdC5cbiAqIC0gc2lnblVzZXJPcEhhc2ggLSBzaWduIHRoZSBoYXNoIG9mIGEgVXNlck9wLlxuICpcbiAqIFRoZSB1c2VyIGNhbiB1c2UgdGhlIGZvbGxvd2luZyBBUElzOlxuICogLSBjcmVhdGVVbnNpZ25lZFVzZXJPcCAtIGdpdmVuIFwidGFyZ2V0XCIgYW5kIFwiY2FsbGRhdGFcIiwgZmlsbCB1c2VyT3AgdG8gcGVyZm9ybSB0aGF0IG9wZXJhdGlvbiBmcm9tIHRoZSBhY2NvdW50LlxuICogLSBjcmVhdGVTaWduZWRVc2VyT3AgLSBoZWxwZXIgdG8gY2FsbCB0aGUgYWJvdmUgY3JlYXRlVW5zaWduZWRVc2VyT3AsIGFuZCB0aGVuIGV4dHJhY3QgdGhlIHVzZXJPcEhhc2ggYW5kIHNpZ24gaXRcbiAqL1xuY2xhc3MgQmFzZUFjY291bnRBUEkge1xuICAvLyBlbnRyeVBvaW50IGNvbm5lY3RlZCB0byBcInplcm9cIiBhZGRyZXNzLiBhbGxvd2VkIHRvIG1ha2Ugc3RhdGljIGNhbGxzIChlLmcuIHRvIGdldFNlbmRlckFkZHJlc3MpXG5cbiAgLyoqXG4gICAqIGJhc2UgY29uc3RydWN0b3IuXG4gICAqIHN1YmNsYXNzIFNIT1VMRCBhZGQgcGFyYW1ldGVycyB0aGF0IGRlZmluZSB0aGUgb3duZXIgKHNpZ25lcikgb2YgdGhpcyB3YWxsZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzUGhhbnRvbVwiLCB0cnVlKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gcGFyYW1zLnByb3ZpZGVyO1xuICAgIHRoaXMuZW50cnlQb2ludEFkZHJlc3MgPSBwYXJhbXMuZW50cnlQb2ludEFkZHJlc3M7XG4gICAgdGhpcy5hY2NvdW50QWRkcmVzcyA9IHBhcmFtcy5hY2NvdW50QWRkcmVzcztcbiAgICB0aGlzLnBheW1hc3RlckFQSSA9IHBhcmFtcy5wYXltYXN0ZXJBUEk7XG4gICAgdGhpcy5nYXNsZXNzID0gcGFyYW1zLmdhc2xlc3M7XG4gICAgdGhpcy5lcmMyMFBheW1hc3RlckFkZHJlc3MgPSBwYXJhbXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzO1xuICAgIHRoaXMuZXJjMjBUb2tlbkFkZHJlc3MgPSBwYXJhbXMuZXJjMjBUb2tlbkFkZHJlc3M7XG5cbiAgICAvLyBmYWN0b3J5IFwiY29ubmVjdFwiIGRlZmluZSB0aGUgY29udHJhY3QgYWRkcmVzcy4gdGhlIGNvbnRyYWN0IFwiY29ubmVjdFwiIGRlZmluZXMgdGhlIFwiZnJvbVwiIGFkZHJlc3MuXG4gICAgdGhpcy5lbnRyeVBvaW50VmlldyA9IEVudHJ5UG9pbnRfX2ZhY3RvcnkuY29ubmVjdChwYXJhbXMuZW50cnlQb2ludEFkZHJlc3MsIHBhcmFtcy5wcm92aWRlcikuY29ubmVjdChldGhlcnMuY29uc3RhbnRzLkFkZHJlc3NaZXJvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIHZhbHVlIHRvIHB1dCBpbnRvIHRoZSBcImluaXRDb2RlXCIgZmllbGQsIGlmIHRoZSBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkLlxuICAgKiB0aGlzIHZhbHVlIGhvbGRzIHRoZSBcImZhY3RvcnlcIiBhZGRyZXNzLCBmb2xsb3dlZCBieSB0aGlzIGFjY291bnQncyBpbmZvcm1hdGlvblxuICAgKi9cblxuICAvKipcbiAgICogcmV0dXJuIGN1cnJlbnQgYWNjb3VudCdzIG5vbmNlLlxuICAgKi9cblxuICAvKipcbiAgICogZW5jb2RlIHRoZSBjYWxsIGZyb20gZW50cnlQb2ludCB0aHJvdWdoIG91ciBhY2NvdW50IHRvIHRoZSB0YXJnZXQgY29udHJhY3QuXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNlbmQgdG8gdGhlIHRhcmdldCBjb250cmFjdFxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBjYWxsZGF0YSB0byBzZW5kIHRvIHRoZSB0YXJnZXQgY29udHJhY3RcbiAgICovXG5cbiAgLyoqXG4gICAqIHNpZ24gYSB1c2VyT3AncyBoYXNoICh1c2VyT3BIYXNoKS5cbiAgICogQHBhcmFtIHVzZXJPcEhhc2ggLSBUaGUgaGFzaCB0byBzaWduXG4gICAqL1xuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFjY291bnQgYWRkcmVzcyBldmVuIGJlZm9yZSBpdCBpcyBkZXBsb3llZFxuICAgKi9cblxuICAvKipcbiAgICogY2hlY2sgaWYgdGhlIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVwbG95ZWQuXG4gICAqL1xuICBhc3luYyBjaGVja0FjY291bnRQaGFudG9tKCkge1xuICAgIGlmICghdGhpcy5pc1BoYW50b20pIHtcbiAgICAgIC8vIGFscmVhZHkgZGVwbG95ZWQuIG5vIG5lZWQgdG8gY2hlY2sgYW55bW9yZS5cbiAgICAgIHJldHVybiB0aGlzLmlzUGhhbnRvbTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyQWRkcmVzc0NvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldENvZGUodGhpcy5nZXRBY2NvdW50QWRkcmVzcygpKTtcbiAgICBpZiAoc2VuZGVyQWRkcmVzc0NvZGUubGVuZ3RoID4gMikge1xuICAgICAgdGhpcy5pc1BoYW50b20gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNQaGFudG9tO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm4gaW5pdENvZGUgdmFsdWUgdG8gaW50byB0aGUgVXNlck9wLlxuICAgKiAoZWl0aGVyIGRlcGxveW1lbnQgY29kZSwgb3IgZW1wdHkgaGV4IGlmIGNvbnRyYWN0IGFscmVhZHkgZGVwbG95ZWQpXG4gICAqL1xuICBhc3luYyBnZXRJbml0Q29kZSgpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5jaGVja0FjY291bnRQaGFudG9tKCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEFjY291bnRJbml0Q29kZSgpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiBtYXhpbXVtIGdhcyB1c2VkIGZvciB2ZXJpZmljYXRpb24uXG4gICAqIE5PVEU6IGNyZWF0ZVVuc2lnbmVkVXNlck9wIHdpbGwgYWRkIHRvIHRoaXMgdmFsdWUgdGhlIGNvc3Qgb2YgY3JlYXRpb24sIGlmIHRoZSBjb250cmFjdCBpcyBub3QgeWV0IGNyZWF0ZWQuXG4gICAqL1xuICBhc3luYyBnZXRWZXJpZmljYXRpb25HYXNMaW1pdCgpIHtcbiAgICByZXR1cm4gMTAwMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB1c2VyT3BIYXNoIGZvciBzaWduaW5nLlxuICAgKiBUaGlzIHZhbHVlIG1hdGNoZXMgZW50cnlQb2ludC5nZXRVc2VyT3BIYXNoIChjYWxjdWxhdGVkIG9mZi1jaGFpbiwgdG8gYXZvaWQgYSB2aWV3IGNhbGwpXG4gICAqIEBwYXJhbSB1c2VyT3AgLSB1c2VyT3BlcmF0aW9uLCAoc2lnbmF0dXJlIGZpZWxkIGlnbm9yZWQpXG4gICAqL1xuICBhc3luYyBnZXRVc2VyT3BIYXNoKHVzZXJPcCkge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKS50aGVuKG5ldCA9PiBuZXQuY2hhaW5JZCk7XG4gICAgcmV0dXJuIGdldFVzZXJPcEhhc2hWMDYodXNlck9wLCB0aGlzLmVudHJ5UG9pbnRBZGRyZXNzLCBjaGFpbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGFjY291bnQncyBhZGRyZXNzLlxuICAgKiB0aGlzIHZhbHVlIGlzIHZhbGlkIGV2ZW4gYmVmb3JlIGRlcGxveWluZyB0aGUgY29udHJhY3QuXG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50QWRkcmVzcygpIHtcbiAgICBpZiAoIXRoaXMuc2VuZGVyQWRkcmVzcykge1xuICAgICAgaWYgKHRoaXMuYWNjb3VudEFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5zZW5kZXJBZGRyZXNzID0gdGhpcy5hY2NvdW50QWRkcmVzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VuZGVyQWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0Q291bnRlckZhY3R1YWxBZGRyZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlbmRlckFkZHJlc3M7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVDcmVhdGlvbkdhcyhpbml0Q29kZSkge1xuICAgIGlmICghaW5pdENvZGUgfHwgaW5pdENvZGUgPT09IFwiMHhcIikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGRlcGxveWVyQWRkcmVzcyA9IGluaXRDb2RlLnN1YnN0cmluZygwLCA0Mik7XG4gICAgY29uc3QgZGVwbG95ZXJDYWxsRGF0YSA9IFwiMHhcIiArIGluaXRDb2RlLnN1YnN0cmluZyg0Mik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoe1xuICAgICAgdG86IGRlcGxveWVyQWRkcmVzcyxcbiAgICAgIGRhdGE6IGRlcGxveWVyQ2FsbERhdGFcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjcmVhdGVVbnNpZ25lZFVzZXJPcChodHRwUnBjQ2xpZW50LCBpbmZvLCBvcHRpb25zKSB7XG4gICAgbGV0IHtcbiAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgfSA9IGluZm87XG4gICAgLy8gZ2V0IGZlZXMgZnJvbSBidW5kbGVyIGlmIGF2YWlsYWJsZVxuICAgIGlmIChpc1R3VXJsKGh0dHBScGNDbGllbnQuYnVuZGxlclVybCkpIHtcbiAgICAgIGNvbnN0IGJ1bmRsZXJGZWVEYXRhID0gYXdhaXQgaHR0cFJwY0NsaWVudC5nZXRVc2VyT3BlcmF0aW9uR2FzUHJpY2UoKTtcbiAgICAgIG1heEZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKGJ1bmRsZXJGZWVEYXRhLm1heEZlZVBlckdhcyk7XG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKGJ1bmRsZXJGZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYnVuZGxlciBpcyBub3QgYXZhaWxhYmxlLCB0cnkgdG8gZ2V0IGZlZXMgZnJvbSB0aGUgbmV0d29yayBpZiBub3QgcGFzc2VkIGV4cGxpY2l0bHlcbiAgICAgIGlmICghbWF4RmVlUGVyR2FzIHx8ICFtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgZ2V0RHluYW1pY0ZlZURhdGEodGhpcy5wcm92aWRlcik7XG4gICAgICAgIGlmICghbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPz8gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF4RmVlUGVyR2FzKSB7XG4gICAgICAgICAgbWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXMgPz8gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICBjb25zdCBjaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICAgIGlmIChjaGFpbklkID09PSBDZWxvLmNoYWluSWQgfHwgY2hhaW5JZCA9PT0gQ2Vsb0FsZmFqb3Jlc1Rlc3RuZXQuY2hhaW5JZCB8fCBjaGFpbklkID09PSBDZWxvQmFrbGF2YVRlc3RuZXQuY2hhaW5JZCkge1xuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBtYXhGZWVQZXJHYXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWF4RmVlUGVyR2FzIHx8ICFtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzIGNvdWxkIG5vdCBiZSBjYWxjdWxhdGVkLCBwbGVhc2UgcGFzcyB0aGVtIGV4cGxpY2l0ZWx5XCIpO1xuICAgIH1cbiAgICBjb25zdCBbc2VuZGVyLCBub25jZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5nZXRBY2NvdW50QWRkcmVzcygpLCBpbmZvLm5vbmNlID8gUHJvbWlzZS5yZXNvbHZlKGluZm8ubm9uY2UpIDogdGhpcy5nZXROb25jZSgpXSk7XG4gICAgY29uc3QgaW5pdENvZGUgPSBhd2FpdCB0aGlzLmdldEluaXRDb2RlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZU51bWJlcihpbmZvLnZhbHVlKSA/PyBCaWdOdW1iZXIuZnJvbSgwKTtcbiAgICBjb25zdCBjYWxsRGF0YSA9IG9wdGlvbnM/LmJhdGNoRGF0YSA/IGluZm8uZGF0YSA6IGF3YWl0IHRoaXMucHJlcGFyZUV4ZWN1dGUoaW5mby50YXJnZXQsIHZhbHVlLCBpbmZvLmRhdGEpLnRoZW4oYXN5bmMgdHggPT4ge1xuICAgICAgaWYgKCFpbmZvLmdhc0xpbWl0KSB7XG4gICAgICAgIC8vIGVzdGltYXRlIGdhcyBvbiB0aGUgaW5uZXIgdHJhbnNhY3Rpb25zIHRvIHNpbXVsYXRlXG4gICAgICAgIC8vIGJ1bmRsZXIgd291bGQgbm90IHJldmVydCBvdGhlcndpc2VcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgZnJvbTogc2VuZGVyLFxuICAgICAgICAgIHRvOiBpbmZvLnRhcmdldCxcbiAgICAgICAgICBkYXRhOiBpbmZvLmRhdGEsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR4LmVuY29kZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRpYWxPcCA9IHtcbiAgICAgIHNlbmRlcixcbiAgICAgIG5vbmNlLFxuICAgICAgaW5pdENvZGUsXG4gICAgICBjYWxsRGF0YSxcbiAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgY2FsbEdhc0xpbWl0OiBCaWdOdW1iZXIuZnJvbSgxMDAwMDAwKSxcbiAgICAgIHZlcmlmaWNhdGlvbkdhc0xpbWl0OiBCaWdOdW1iZXIuZnJvbSgxMDAwMDAwKSxcbiAgICAgIHByZVZlcmlmaWNhdGlvbkdhczogQmlnTnVtYmVyLmZyb20oMTAwMDAwMCksXG4gICAgICBwYXltYXN0ZXJBbmREYXRhOiBcIjB4XCIsXG4gICAgICBzaWduYXR1cmU6IERVTU1ZX1NJR05BVFVSRVxuICAgIH07XG5cbiAgICAvLyBwYXltYXN0ZXIgZGF0YSArIG1heWJlIHVzZWQgZm9yIGVzdGltYXRpb24gYXMgd2VsbFxuICAgIGNvbnN0IGdhc2xlc3MgPSBvcHRpb25zPy5nYXNsZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdhc2xlc3MgOiB0aGlzLmdhc2xlc3M7XG4gICAgY29uc3QgdXNlRXJjMjBQYXltYXN0ZXIgPSB0aGlzLmVyYzIwUGF5bWFzdGVyQWRkcmVzcyAmJiB0aGlzLmVyYzIwVG9rZW5BZGRyZXNzICYmIChhd2FpdCB0aGlzLmlzQWNjb3VudEFwcHJvdmVkKCkpO1xuICAgIGlmICh1c2VFcmMyMFBheW1hc3Rlcikge1xuICAgICAgcGFydGlhbE9wLnBheW1hc3RlckFuZERhdGEgPSB0aGlzLmVyYzIwUGF5bWFzdGVyQWRkcmVzcztcbiAgICAgIGxldCBlc3RpbWF0ZXM7XG4gICAgICB0cnkge1xuICAgICAgICBlc3RpbWF0ZXMgPSBhd2FpdCBodHRwUnBjQ2xpZW50LmVzdGltYXRlVXNlck9wR2FzKHBhcnRpYWxPcCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLnVud3JhcEJ1bmRsZXJFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICBwYXJ0aWFsT3AuY2FsbEdhc0xpbWl0ID0gZXN0aW1hdGVzLmNhbGxHYXNMaW1pdDtcbiAgICAgIHBhcnRpYWxPcC52ZXJpZmljYXRpb25HYXNMaW1pdCA9IGVzdGltYXRlcy52ZXJpZmljYXRpb25HYXNMaW1pdDtcbiAgICAgIHBhcnRpYWxPcC5wcmVWZXJpZmljYXRpb25HYXMgPSBlc3RpbWF0ZXMucHJlVmVyaWZpY2F0aW9uR2FzO1xuICAgIH0gZWxzZSBpZiAoZ2FzbGVzcykge1xuICAgICAgY29uc3QgcGF5bWFzdGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXltYXN0ZXJBUEkuZ2V0UGF5bWFzdGVyQW5kRGF0YShwYXJ0aWFsT3ApO1xuICAgICAgY29uc3QgcGF5bWFzdGVyQW5kRGF0YSA9IHBheW1hc3RlclJlc3VsdC5wYXltYXN0ZXJBbmREYXRhO1xuICAgICAgaWYgKHBheW1hc3RlckFuZERhdGEgJiYgcGF5bWFzdGVyQW5kRGF0YSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHBhcnRpYWxPcC5wYXltYXN0ZXJBbmREYXRhID0gcGF5bWFzdGVyQW5kRGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIHBheW1hc3RlciBjYW4gaGF2ZSB0aGUgZ2FzIGxpbWl0cyBpbiB0aGUgcmVzcG9uc2VcbiAgICAgIGlmIChwYXltYXN0ZXJSZXN1bHQuY2FsbEdhc0xpbWl0ICYmIHBheW1hc3RlclJlc3VsdC52ZXJpZmljYXRpb25HYXNMaW1pdCAmJiBwYXltYXN0ZXJSZXN1bHQucHJlVmVyaWZpY2F0aW9uR2FzKSB7XG4gICAgICAgIHBhcnRpYWxPcC5jYWxsR2FzTGltaXQgPSBCaWdOdW1iZXIuZnJvbShwYXltYXN0ZXJSZXN1bHQuY2FsbEdhc0xpbWl0KTtcbiAgICAgICAgcGFydGlhbE9wLnZlcmlmaWNhdGlvbkdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20ocGF5bWFzdGVyUmVzdWx0LnZlcmlmaWNhdGlvbkdhc0xpbWl0KTtcbiAgICAgICAgcGFydGlhbE9wLnByZVZlcmlmaWNhdGlvbkdhcyA9IEJpZ051bWJlci5mcm9tKHBheW1hc3RlclJlc3VsdC5wcmVWZXJpZmljYXRpb25HYXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJ1bmRsZXIgZm9yIGdhcyBsaW1pdHNcbiAgICAgICAgbGV0IGVzdGltYXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlc3RpbWF0ZXMgPSBhd2FpdCBodHRwUnBjQ2xpZW50LmVzdGltYXRlVXNlck9wR2FzKHBhcnRpYWxPcCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy51bndyYXBCdW5kbGVyRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRpYWxPcC5jYWxsR2FzTGltaXQgPSBlc3RpbWF0ZXMuY2FsbEdhc0xpbWl0O1xuICAgICAgICBwYXJ0aWFsT3AudmVyaWZpY2F0aW9uR2FzTGltaXQgPSBlc3RpbWF0ZXMudmVyaWZpY2F0aW9uR2FzTGltaXQ7XG4gICAgICAgIHBhcnRpYWxPcC5wcmVWZXJpZmljYXRpb25HYXMgPSBlc3RpbWF0ZXMucHJlVmVyaWZpY2F0aW9uR2FzO1xuICAgICAgICAvLyBuZWVkIHBheW1hc3RlciB0byByZS1zaWduIGFmdGVyIGVzdGltYXRlc1xuICAgICAgICBpZiAocGF5bWFzdGVyQW5kRGF0YSAmJiBwYXltYXN0ZXJBbmREYXRhICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICBjb25zdCBwYXltYXN0ZXJSZXN1bHQyID0gYXdhaXQgdGhpcy5wYXltYXN0ZXJBUEkuZ2V0UGF5bWFzdGVyQW5kRGF0YShwYXJ0aWFsT3ApO1xuICAgICAgICAgIGlmIChwYXltYXN0ZXJSZXN1bHQyLnBheW1hc3RlckFuZERhdGEgJiYgcGF5bWFzdGVyUmVzdWx0Mi5wYXltYXN0ZXJBbmREYXRhICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHBhcnRpYWxPcC5wYXltYXN0ZXJBbmREYXRhID0gcGF5bWFzdGVyUmVzdWx0Mi5wYXltYXN0ZXJBbmREYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBxdWVyeSBidW5kbGVyIGZvciBnYXMgbGltaXRzXG4gICAgICBsZXQgZXN0aW1hdGVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXN0aW1hdGVzID0gYXdhaXQgaHR0cFJwY0NsaWVudC5lc3RpbWF0ZVVzZXJPcEdhcyhwYXJ0aWFsT3ApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy51bndyYXBCdW5kbGVyRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcGFydGlhbE9wLmNhbGxHYXNMaW1pdCA9IGVzdGltYXRlcy5jYWxsR2FzTGltaXQ7XG4gICAgICBwYXJ0aWFsT3AudmVyaWZpY2F0aW9uR2FzTGltaXQgPSBlc3RpbWF0ZXMudmVyaWZpY2F0aW9uR2FzTGltaXQ7XG4gICAgICBwYXJ0aWFsT3AucHJlVmVyaWZpY2F0aW9uR2FzID0gZXN0aW1hdGVzLnByZVZlcmlmaWNhdGlvbkdhcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnRpYWxPcCxcbiAgICAgIHNpZ25hdHVyZTogXCJcIlxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgZmlsbGVkIHVzZXJPcC5cbiAgICogQHBhcmFtIHVzZXJPcCAtIFRoZSBVc2VyT3BlcmF0aW9uIHRvIHNpZ24gKHdpdGggc2lnbmF0dXJlIGZpZWxkIGlnbm9yZWQpXG4gICAqL1xuICBhc3luYyBzaWduVXNlck9wKHVzZXJPcCkge1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCB0aGlzLmdldFVzZXJPcEhhc2godXNlck9wKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25Vc2VyT3BIYXNoKHVzZXJPcEhhc2gpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi51c2VyT3AsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdHJhbnNhY3Rpb24gdGhhdCBoYXMgdGhpcyB1c2VyT3BIYXNoIG1pbmVkLCBvciB0aHJvd3MgaWYgbm90IGZvdW5kXG4gICAqIEBwYXJhbSB1c2VyT3BIYXNoIC0gcmV0dXJuZWQgYnkgc2VuZFVzZXJPcFRvQnVuZGxlciAob3IgYnkgZ2V0VXNlck9wSGFzaC4uKVxuICAgKiBAcGFyYW0gdGltZW91dCAtIHN0b3Agd2FpdGluZyBhZnRlciB0aGlzIHRpbWVvdXRcbiAgICogQHBhcmFtIGludGVydmFsIC0gdGltZSB0byB3YWl0IGJldHdlZW4gcG9sbHMuXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiByZWNlaXB0LCBvciBhbiBlcnJvciBpZiB0aW1lZCBvdXQuXG4gICAqL1xuICBhc3luYyBnZXRVc2VyT3BSZWNlaXB0KGh0dHBScGNDbGllbnQsIHVzZXJPcEhhc2gpIHtcbiAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTIwMDAwO1xuICAgIGxldCBpbnRlcnZhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTAwMDtcbiAgICBjb25zdCBlbmR0aW1lID0gRGF0ZS5ub3coKSArIHRpbWVvdXQ7XG4gICAgd2hpbGUgKERhdGUubm93KCkgPCBlbmR0aW1lKSB7XG4gICAgICBjb25zdCB1c2VyT3BSZWNlaXB0ID0gYXdhaXQgaHR0cFJwY0NsaWVudC5nZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCh1c2VyT3BIYXNoKTtcbiAgICAgIGlmICh1c2VyT3BSZWNlaXB0KSB7XG4gICAgICAgIC8vIGF2b2lkIGRlc3luYyB3aXRoIGN1cnJlbnQgcHJvdmlkZXIgc3RhdGVcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKHVzZXJPcFJlY2VpcHQucmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVvdXQgd2FpdGluZyBmb3IgdXNlck9wIHRvIGJlIG1pbmVkXCIpO1xuICB9XG4gIHVud3JhcEJ1bmRsZXJFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvcj8uZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3IuZXJyb3IgfHwgZXJyb3IubWVzc2FnZSB8fCBlcnJvcjtcbiAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZU51bWJlcihhKSB7XG4gIGlmICghYSB8fCBhID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGEudG9TdHJpbmcoKSk7XG59XG5cbmNsYXNzIEFjY291bnRBUEkgZXh0ZW5kcyBCYXNlQWNjb3VudEFQSSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgb3JpZ2luYWxQcm92aWRlcikge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIHByb3ZpZGVyOiBvcmlnaW5hbFByb3ZpZGVyXG4gICAgfSk7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgLy8gVGVjaG5pY2FsbHkgZG9udCBuZWVkIHRoZSBzaWduZXIgaGVyZSwgYnV0IHdlIG5lZWQgdG8gZW5jb2RlL2VzdGltYXRlIGdhcyB3aXRoIGl0IHNvIGEgc2lnbmVyIGlzIHJlcXVpcmVkXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGxvY2FsU2lnbmVyIGRpcmVjdGx5IHNpbmNlIGl0IG1pZ2h0IGJlIGNvbm5lY3RlZCB0byBhbm90aGVyIGNoYWluXG4gICAgLy8gc28gd2UganVzdCB1c2UgdGhlIHB1YmxpYyBoYXJkaGF0IHBrZXkgaW5zdGVhZFxuICAgIHRoaXMuc2RrID0gVGhpcmR3ZWJTREsuZnJvbVByaXZhdGVLZXkoTE9DQUxfTk9ERV9QS0VZLCBwYXJhbXMuY2hhaW4sIHtcbiAgICAgIGNsaWVudElkOiBwYXJhbXMuY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IHBhcmFtcy5zZWNyZXRLZXksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGV4cGVjdGVkIGNoYWluIHR5cGUgZXJyb3JcbiAgICAgIHN1cHBvcnRlZENoYWluczogdHlwZW9mIHBhcmFtcy5jaGFpbiA9PT0gXCJvYmplY3RcIiA/IFtwYXJhbXMuY2hhaW5dIDogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCkudGhlbihuID0+IG4uY2hhaW5JZCk7XG4gIH1cbiAgYXN5bmMgZ2V0QWNjb3VudENvbnRyYWN0KCkge1xuICAgIGlmICghdGhpcy5hY2NvdW50Q29udHJhY3QpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5hY2NvdW50SW5mbz8uYWJpKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5zZGsuZ2V0Q29udHJhY3QoYXdhaXQgdGhpcy5nZXRBY2NvdW50QWRkcmVzcygpLCB0aGlzLnBhcmFtcy5hY2NvdW50SW5mby5hYmkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLnNkay5nZXRDb250cmFjdChhd2FpdCB0aGlzLmdldEFjY291bnRBZGRyZXNzKCksIEFDQ09VTlRfQ09SRV9BQkkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hY2NvdW50Q29udHJhY3Q7XG4gIH1cbiAgYXN5bmMgZ2V0QWNjb3VudEluaXRDb2RlKCkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCB0aGlzLmdldEZhY3RvcnlDb250cmFjdCgpO1xuICAgIGNvbnN0IGxvY2FsU2lnbmVyID0gYXdhaXQgdGhpcy5wYXJhbXMubG9jYWxTaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wYXJhbXMuZmFjdG9yeUluZm8uY3JlYXRlQWNjb3VudChmYWN0b3J5LCBsb2NhbFNpZ25lcik7XG4gICAgcmV0dXJuIHV0aWxzLmhleENvbmNhdChbZmFjdG9yeS5nZXRBZGRyZXNzKCksIHR4LmVuY29kZSgpXSk7XG4gIH1cbiAgYXN5bmMgZ2V0RmFjdG9yeUNvbnRyYWN0KCkge1xuICAgIGlmICh0aGlzLmZhY3RvcnlDb250cmFjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yeUNvbnRyYWN0O1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJhbXMuZmFjdG9yeUluZm8/LmFiaSkge1xuICAgICAgdGhpcy5mYWN0b3J5Q29udHJhY3QgPSBhd2FpdCB0aGlzLnNkay5nZXRDb250cmFjdCh0aGlzLnBhcmFtcy5mYWN0b3J5QWRkcmVzcywgdGhpcy5wYXJhbXMuZmFjdG9yeUluZm8uYWJpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWN0b3J5Q29udHJhY3QgPSBhd2FpdCB0aGlzLnNkay5nZXRDb250cmFjdCh0aGlzLnBhcmFtcy5mYWN0b3J5QWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZhY3RvcnlDb250cmFjdDtcbiAgfVxuICBhc3luYyBnZXRDb3VudGVyRmFjdHVhbEFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMucGFyYW1zLmFjY291bnRBZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYWNjb3VudEFkZHJlc3M7XG4gICAgfVxuICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCB0aGlzLmdldEZhY3RvcnlDb250cmFjdCgpO1xuICAgIGNvbnN0IGxvY2FsU2lnbmVyID0gYXdhaXQgdGhpcy5wYXJhbXMubG9jYWxTaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5mYWN0b3J5SW5mby5nZXRBY2NvdW50QWRkcmVzcyhmYWN0b3J5LCBsb2NhbFNpZ25lcik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2UoKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuY2hlY2tBY2NvdW50UGhhbnRvbSgpKSB7XG4gICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oMCk7XG4gICAgfVxuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLmFjY291bnRJbmZvLmdldE5vbmNlKGFjY291bnRDb250cmFjdCk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUV4ZWN1dGUodGFyZ2V0LCB2YWx1ZSwgZGF0YSkge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLmFjY291bnRJbmZvLmV4ZWN1dGUoYWNjb3VudENvbnRyYWN0LCB0YXJnZXQsIHZhbHVlLCBkYXRhKTtcbiAgfVxuICBhc3luYyBwcmVwYXJlRXhlY3V0ZUJhdGNoKHRhcmdldHMsIHZhbHVlcywgZGF0YXMpIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiBhY2NvdW50Q29udHJhY3QucHJlcGFyZShcImV4ZWN1dGVCYXRjaFwiLCBbdGFyZ2V0cywgdmFsdWVzLCBkYXRhc10pO1xuICB9XG4gIGFzeW5jIHNpZ25Vc2VyT3BIYXNoKHVzZXJPcEhhc2gpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wYXJhbXMubG9jYWxTaWduZXIuc2lnbk1lc3NhZ2UodXRpbHMuYXJyYXlpZnkodXNlck9wSGFzaCkpO1xuICB9XG4gIGFzeW5jIGlzQWNvdW50RGVwbG95ZWQoKSB7XG4gICAgcmV0dXJuICEoYXdhaXQgdGhpcy5jaGVja0FjY291bnRQaGFudG9tKCkpO1xuICB9XG4gIGFzeW5jIGlzQWNjb3VudEFwcHJvdmVkKCkge1xuICAgIGlmICghdGhpcy5wYXJhbXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzIHx8ICF0aGlzLnBhcmFtcy5lcmMyMFRva2VuQWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHN3QWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0Q291bnRlckZhY3R1YWxBZGRyZXNzKCk7XG4gICAgY29uc3QgRVJDMjBBYmkgPSAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUVSQzIwLmpzb24nKSkuZGVmYXVsdDtcbiAgICBjb25zdCBlcmMyMFRva2VuID0gYXdhaXQgdGhpcy5zZGsuZ2V0Q29udHJhY3QodGhpcy5wYXJhbXMuZXJjMjBUb2tlbkFkZHJlc3MsIEVSQzIwQWJpKTtcbiAgICBjb25zdCBhbGxvd2FuY2UgPSBhd2FpdCBlcmMyMFRva2VuLmNhbGwoXCJhbGxvd2FuY2VcIiwgW3N3QWRkcmVzcywgdGhpcy5wYXJhbXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzXSk7XG4gICAgcmV0dXJuIGFsbG93YW5jZS5ndGUoQmlnTnVtYmVyLmZyb20oMikucG93KDk2KS5zdWIoMSkpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZUFwcHJvdmVUeCgpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0FjY291bnRBcHByb3ZlZCgpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBhbW91bnRUb0FwcHJvdmUgPSBCaWdOdW1iZXIuZnJvbSgyKS5wb3coOTYpLnN1YigxKTtcbiAgICBjb25zdCBldGhlcnNTaWduZXIgPSBuZXcgZXRoZXJzLldhbGxldChMT0NBTF9OT0RFX1BLRVksIHRoaXMucHJvdmlkZXIpO1xuICAgIGNvbnN0IGVyYzIwQ29udHJhY3QgPSBuZXcgQ29udHJhY3QodGhpcy5wYXJhbXMuZXJjMjBUb2tlbkFkZHJlc3MsIFtcImZ1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcHVibGljIHJldHVybnMgKGJvb2wpXCJdLCBldGhlcnNTaWduZXIpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgdG86IHRoaXMucGFyYW1zLmVyYzIwVG9rZW5BZGRyZXNzLFxuICAgICAgZnJvbTogYXdhaXQgdGhpcy5nZXRBY2NvdW50QWRkcmVzcygpLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBkYXRhOiBlcmMyMENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJhcHByb3ZlXCIsIFt0aGlzLnBhcmFtcy5lcmMyMFBheW1hc3RlckFkZHJlc3MsIGFtb3VudFRvQXBwcm92ZV0pXG4gICAgfTtcbiAgICByZXR1cm4gdHg7XG4gIH1cbn1cblxuY2xhc3MgU21hcnRXYWxsZXRDb25uZWN0b3IgZXh0ZW5kcyBDb25uZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qgb3JpZ2luYWxQcm92aWRlciA9IGdldENoYWluUHJvdmlkZXIoY29uZmlnLmNoYWluLCB7XG4gICAgICBjbGllbnRJZDogY29uZmlnLmNsaWVudElkLFxuICAgICAgc2VjcmV0S2V5OiBjb25maWcuc2VjcmV0S2V5XG4gICAgfSk7XG4gICAgdGhpcy5jaGFpbklkID0gKGF3YWl0IG9yaWdpbmFsUHJvdmlkZXIuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSB0aGlzLmNvbmZpZy5idW5kbGVyVXJsIHx8IGBodHRwczovLyR7dGhpcy5jaGFpbklkfS5idW5kbGVyLnRoaXJkd2ViLmNvbWA7XG4gICAgY29uc3QgcGF5bWFzdGVyVXJsID0gdGhpcy5jb25maWcucGF5bWFzdGVyVXJsIHx8IGBodHRwczovLyR7dGhpcy5jaGFpbklkfS5idW5kbGVyLnRoaXJkd2ViLmNvbWA7XG4gICAgY29uc3QgZW50cnlQb2ludEFkZHJlc3MgPSBjb25maWcuZW50cnlQb2ludEFkZHJlc3MgfHwgRU5UUllQT0lOVF9BRERSRVNTO1xuICAgIGNvbnN0IGxvY2FsU2lnbmVyID0gYXdhaXQgcGFyYW1zLnBlcnNvbmFsV2FsbGV0LmdldFNpZ25lcigpO1xuICAgIGNvbnN0IHByb3ZpZGVyQ29uZmlnID0ge1xuICAgICAgY2hhaW46IGNvbmZpZy5jaGFpbixcbiAgICAgIGxvY2FsU2lnbmVyLFxuICAgICAgZW50cnlQb2ludEFkZHJlc3MsXG4gICAgICBidW5kbGVyVXJsLFxuICAgICAgcGF5bWFzdGVyQVBJOiB0aGlzLmNvbmZpZy5wYXltYXN0ZXJBUEkgPyB0aGlzLmNvbmZpZy5wYXltYXN0ZXJBUEkgOiBnZXRWZXJpZnlpbmdQYXltYXN0ZXIocGF5bWFzdGVyVXJsLCBlbnRyeVBvaW50QWRkcmVzcywgdGhpcy5jb25maWcuY2xpZW50SWQsIHRoaXMuY29uZmlnLnNlY3JldEtleSksXG4gICAgICBnYXNsZXNzOiBjb25maWcuZ2FzbGVzcyxcbiAgICAgIGZhY3RvcnlBZGRyZXNzOiBjb25maWcuZmFjdG9yeUFkZHJlc3MsXG4gICAgICBhY2NvdW50QWRkcmVzczogcGFyYW1zLmFjY291bnRBZGRyZXNzLFxuICAgICAgZmFjdG9yeUluZm86IHtcbiAgICAgICAgY3JlYXRlQWNjb3VudDogY29uZmlnLmZhY3RvcnlJbmZvPy5jcmVhdGVBY2NvdW50IHx8IHRoaXMuZGVmYXVsdEZhY3RvcnlJbmZvKCkuY3JlYXRlQWNjb3VudCxcbiAgICAgICAgZ2V0QWNjb3VudEFkZHJlc3M6IGNvbmZpZy5mYWN0b3J5SW5mbz8uZ2V0QWNjb3VudEFkZHJlc3MgfHwgdGhpcy5kZWZhdWx0RmFjdG9yeUluZm8oKS5nZXRBY2NvdW50QWRkcmVzcyxcbiAgICAgICAgYWJpOiBjb25maWcuZmFjdG9yeUluZm8/LmFiaVxuICAgICAgfSxcbiAgICAgIGFjY291bnRJbmZvOiB7XG4gICAgICAgIGV4ZWN1dGU6IGNvbmZpZy5hY2NvdW50SW5mbz8uZXhlY3V0ZSB8fCB0aGlzLmRlZmF1bHRBY2NvdW50SW5mbygpLmV4ZWN1dGUsXG4gICAgICAgIGdldE5vbmNlOiBjb25maWcuYWNjb3VudEluZm8/LmdldE5vbmNlIHx8IHRoaXMuZGVmYXVsdEFjY291bnRJbmZvKCkuZ2V0Tm9uY2UsXG4gICAgICAgIGFiaTogY29uZmlnLmFjY291bnRJbmZvPy5hYmlcbiAgICAgIH0sXG4gICAgICBjbGllbnRJZDogY29uZmlnLmNsaWVudElkLFxuICAgICAgc2VjcmV0S2V5OiBjb25maWcuc2VjcmV0S2V5LFxuICAgICAgZXJjMjBQYXltYXN0ZXJBZGRyZXNzOiBjb25maWcuZXJjMjBQYXltYXN0ZXJBZGRyZXNzLFxuICAgICAgZXJjMjBUb2tlbkFkZHJlc3M6IGNvbmZpZy5lcmMyMFRva2VuQWRkcmVzc1xuICAgIH07XG4gICAgdGhpcy5wZXJzb25hbFdhbGxldCA9IHBhcmFtcy5wZXJzb25hbFdhbGxldDtcbiAgICBjb25zdCBhY2NvdW50QXBpID0gbmV3IEFjY291bnRBUEkocHJvdmlkZXJDb25maWcsIG9yaWdpbmFsUHJvdmlkZXIpO1xuICAgIHRoaXMuYWFQcm92aWRlciA9IGNyZWF0ZTQzMzdQcm92aWRlcihwcm92aWRlckNvbmZpZywgYWNjb3VudEFwaSwgb3JpZ2luYWxQcm92aWRlciwgdGhpcy5jaGFpbklkKTtcbiAgICB0aGlzLmFjY291bnRBcGkgPSBhY2NvdW50QXBpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29ubmVjdGlvbkFyZ3MpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoY29ubmVjdGlvbkFyZ3MpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgfVxuICBnZXRQcm92aWRlcigpIHtcbiAgICBpZiAoIXRoaXMuYWFQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hYVByb3ZpZGVyKTtcbiAgfVxuICBhc3luYyBnZXRTaWduZXIoKSB7XG4gICAgaWYgKCF0aGlzLmFhUHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWFQcm92aWRlci5nZXRTaWduZXIoKSk7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICB9XG4gIGFzeW5jIGlzQ29ubmVjdGVkKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICByZXR1cm4gISFhZGRyZXNzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnBlcnNvbmFsV2FsbGV0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWFQcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5cbiAgYXN5bmMgc3dpdGNoQ2hhaW4oY2hhaW5JZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gKGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICBpZiAoY3VycmVudENoYWluSWQgIT09IGNoYWluSWQpIHtcbiAgICAgIC8vIG9ubHkgdGhyb3cgaWYgYWN0dWFsbHkgdHJ5aW5nIHRvIHN3aXRjaCBjaGFpbnNcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgfVxuICBzZXR1cExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHVwZGF0ZUNoYWlucyhjaGFpbnMpIHt9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGNvbm5lY3RlZCBzaWduZXIgY2FuIGV4ZWN1dGUgYSBnaXZlbiB0cmFuc2FjdGlvbiB1c2luZyB0aGUgc21hcnQgd2FsbGV0LlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gZXhlY3V0ZSB1c2luZyB0aGUgc21hcnQgd2FsbGV0LlxuICAgKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBjb25uZWN0ZWQgc2lnbmVyIGNhbiBleGVjdXRlIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgc21hcnQgd2FsbGV0LlxuICAgKi9cbiAgYXN5bmMgaGFzUGVybWlzc2lvblRvRXhlY3V0ZSh0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBjb25zdCByZXN0cmljdGlvbnMgPSAoYXdhaXQgYWNjb3VudENvbnRyYWN0LmFjY291bnQuZ2V0QWxsU2lnbmVycygpKS5maWx0ZXIoaXRlbSA9PiBldGhlcnMudXRpbHMuZ2V0QWRkcmVzcyhpdGVtLnNpZ25lcikgPT09IGV0aGVycy51dGlscy5nZXRBZGRyZXNzKHNpZ25lckFkZHJlc3MpKVswXT8ucGVybWlzc2lvbnM7XG4gICAgaWYgKCFyZXN0cmljdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3RyaWN0aW9ucy5hcHByb3ZlZENhbGxUYXJnZXRzLmluY2x1ZGVzKHRyYW5zYWN0aW9uLmdldFRhcmdldCgpKTtcbiAgfVxuXG4gIC8vLyBQUkVQQVJFRCBUUkFOU0FDVElPTlNcblxuICAvKipcbiAgICogU2VuZCBhIHNpbmdsZSB0cmFuc2FjdGlvbiB3aXRob3V0IHdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gdGhlIHRyYW5zYWN0aW9uIHRvIHNlbmRcbiAgICogQHBhcmFtIGNvbmZpZyAtIG9wdGlvbmFsIHRoZSB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm5zIFRoZSBhd2FpdGFibGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIHNlbmQodHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHRvOiB0cmFuc2FjdGlvbi5nZXRUYXJnZXQoKSxcbiAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmVuY29kZSgpLFxuICAgICAgdmFsdWU6IGF3YWl0IHRyYW5zYWN0aW9uLmdldFZhbHVlKClcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgc2luZ2xlIHRyYW5zYWN0aW9uICh3YWl0aW5nIGZvciBjb25maXJtYXRpb25zKVxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gZXhlY3V0ZVxuICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZSh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kKHRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuICBhc3luYyBzZW5kQmF0Y2godHJhbnNhY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHR4LFxuICAgICAgYmF0Y2hEYXRhXG4gICAgfSA9IGF3YWl0IHRoaXMucHJlcGFyZUJhdGNoVHgodHJhbnNhY3Rpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICB0bzogYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKSxcbiAgICAgIGRhdGE6IHR4LmVuY29kZSgpLFxuICAgICAgdmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYmF0Y2hEYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBtdWx0aXBsZSB0cmFuc2FjdGlvbnMgaW4gYSBzaW5nbGUgYmF0Y2hcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyAtIFRoZSB0cmFuc2FjdGlvbnMgdG8gZXhlY3V0ZVxuICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZUJhdGNoKHRyYW5zYWN0aW9ucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kQmF0Y2godHJhbnNhY3Rpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuXG4gIC8vLyBSQVcgVFJBTlNBQ1RJT05TXG5cbiAgYXN5bmMgc2VuZFJhdyh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICByZXR1cm4gc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZVJhdyh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kUmF3KHRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuICBhc3luYyBzZW5kQmF0Y2hSYXcodHJhbnNhY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdGhpcy5wcmVwYXJlQmF0Y2hSYXcodHJhbnNhY3Rpb25zKTtcbiAgICByZXR1cm4gc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICB0bzogYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKSxcbiAgICAgIGRhdGE6IGJhdGNoLnR4LmVuY29kZSgpLFxuICAgICAgdmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYmF0Y2hEYXRhOiBiYXRjaC5iYXRjaERhdGEgLy8gYmF0Y2hlZCB0eCBmbGFnXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZUJhdGNoUmF3KHRyYW5zYWN0aW9ucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kQmF0Y2hSYXcodHJhbnNhY3Rpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuXG4gIC8vLyBFU1RJTUFUSU9OXG5cbiAgYXN5bmMgZXN0aW1hdGUodHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlVHgoe1xuICAgICAgdGFyZ2V0OiB0cmFuc2FjdGlvbi5nZXRUYXJnZXQoKSxcbiAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmVuY29kZSgpLFxuICAgICAgdmFsdWU6IGF3YWl0IHRyYW5zYWN0aW9uLmdldFZhbHVlKCksXG4gICAgICBnYXNMaW1pdDogYXdhaXQgdHJhbnNhY3Rpb24uZ2V0T3ZlcnJpZGVzKCkuZ2FzTGltaXQsXG4gICAgICBtYXhGZWVQZXJHYXM6IGF3YWl0IHRyYW5zYWN0aW9uLmdldE92ZXJyaWRlcygpLm1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBhd2FpdCB0cmFuc2FjdGlvbi5nZXRPdmVycmlkZXMoKS5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgIG5vbmNlOiBhd2FpdCB0cmFuc2FjdGlvbi5nZXRPdmVycmlkZXMoKS5ub25jZVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlUmF3KHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IGF3YWl0IGV0aGVycy51dGlscy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVUeCh7XG4gICAgICB0YXJnZXQ6IHR4LnRvIHx8IGNvbnN0YW50cy5BZGRyZXNzWmVybyxcbiAgICAgIGRhdGE6IHR4LmRhdGE/LnRvU3RyaW5nKCkgfHwgXCJcIixcbiAgICAgIHZhbHVlOiB0eC52YWx1ZSB8fCBCaWdOdW1iZXIuZnJvbSgwKSxcbiAgICAgIGdhc0xpbWl0OiB0eC5nYXNMaW1pdCxcbiAgICAgIG1heEZlZVBlckdhczogdHgubWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgbm9uY2U6IHR4Lm5vbmNlXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVCYXRjaCh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHR4LFxuICAgICAgYmF0Y2hEYXRhXG4gICAgfSA9IGF3YWl0IHRoaXMucHJlcGFyZUJhdGNoVHgodHJhbnNhY3Rpb25zKTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZVR4KHtcbiAgICAgIHRhcmdldDogdHguZ2V0VGFyZ2V0KCksXG4gICAgICBkYXRhOiB0eC5lbmNvZGUoKSxcbiAgICAgIHZhbHVlOiBhd2FpdCB0eC5nZXRWYWx1ZSgpLFxuICAgICAgZ2FzTGltaXQ6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLmdhc0xpbWl0LFxuICAgICAgbWF4RmVlUGVyR2FzOiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5tYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICBub25jZTogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkubm9uY2VcbiAgICB9LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYmF0Y2hEYXRhXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVCYXRjaFJhdyh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHR4LFxuICAgICAgYmF0Y2hEYXRhXG4gICAgfSA9IGF3YWl0IHRoaXMucHJlcGFyZUJhdGNoUmF3KHRyYW5zYWN0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVUeCh7XG4gICAgICB0YXJnZXQ6IHR4LmdldFRhcmdldCgpLFxuICAgICAgZGF0YTogdHguZW5jb2RlKCksXG4gICAgICB2YWx1ZTogYXdhaXQgdHguZ2V0VmFsdWUoKSxcbiAgICAgIGdhc0xpbWl0OiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5nYXNMaW1pdCxcbiAgICAgIG1heEZlZVBlckdhczogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkubWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgbm9uY2U6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLm5vbmNlXG4gICAgfSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGJhdGNoRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLy8vLyBERVBMT1lNRU5UXG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGRlcGxveSB0aGUgc21hcnQgd2FsbGV0IGNvbnRyYWN0LiBJZiBhbHJlYWR5IGRlcGxveWVkIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgbm90IG5lY2Vzc2FyeSBhcyB0aGUgc21hcnQgd2FsbGV0IHdpbGwgYmUgZGVwbG95ZWQgYXV0b21hdGljYWxseSBvbiB0aGUgZmlyc3QgdHJhbnNhY3Rpb24gdGhlIHVzZXIgbWFrZXMuXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqL1xuICBhc3luYyBkZXBsb3kob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgdG86IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICBkYXRhOiBcIjB4XCJcbiAgICB9LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYmF0Y2hEYXRhOiB7XG4gICAgICAgIHRhcmdldHM6IFtdLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgdmFsdWVzOiBbXVxuICAgICAgfSAvLyBiYXRjaGVkIHR4IGZsYWcgdG8gYXZvaWQgaGl0dGluZyB0aGUgUm91dGVyIGZhbGxiYWNrIG1ldGhvZFxuICAgIH0pO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzbWFydCB3YWxsZXQgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc21hcnQgd2FsbGV0IGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAqL1xuICBhc3luYyBpc0RlcGxveWVkKCkge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWNjb3VudEFwaS5pc0Fjb3VudERlcGxveWVkKCk7XG4gIH1cbiAgYXN5bmMgZGVwbG95SWZOZWVkZWQob3B0aW9ucykge1xuICAgIGNvbnN0IGlzRGVwbG95ZWQgPSBhd2FpdCB0aGlzLmlzRGVwbG95ZWQoKTtcbiAgICBpZiAoIWlzRGVwbG95ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vLy8gUEVSTUlTU0lPTlNcblxuICBhc3luYyBncmFudFBlcm1pc3Npb25zKHRhcmdldCwgcGVybWlzc2lvbnMpIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiBhY2NvdW50Q29udHJhY3QuYWNjb3VudC5ncmFudFBlcm1pc3Npb25zKHRhcmdldCwgcGVybWlzc2lvbnMpO1xuICB9XG4gIGFzeW5jIHJldm9rZVBlcm1pc3Npb25zKHRhcmdldCkge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIGFjY291bnRDb250cmFjdC5hY2NvdW50LnJldm9rZUFjY2Vzcyh0YXJnZXQpO1xuICB9XG4gIGFzeW5jIGFkZEFkbWluKHRhcmdldCkge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIGFjY291bnRDb250cmFjdC5hY2NvdW50LmdyYW50QWRtaW5QZXJtaXNzaW9ucyh0YXJnZXQpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUFkbWluKHRhcmdldCkge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIGFjY291bnRDb250cmFjdC5hY2NvdW50LnJldm9rZUFkbWluUGVybWlzc2lvbnModGFyZ2V0KTtcbiAgfVxuICBhc3luYyBnZXRBbGxBY3RpdmVTaWduZXJzKCkge1xuICAgIGNvbnN0IGlzRGVwbG95ZWQgPSBhd2FpdCB0aGlzLmlzRGVwbG95ZWQoKTtcbiAgICBpZiAoaXNEZXBsb3llZCkge1xuICAgICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICAgIHJldHVybiBhY2NvdW50Q29udHJhY3QuYWNjb3VudC5nZXRBbGxBZG1pbnNBbmRTaWduZXJzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBlcnNvbmFsV2FsbGV0ID0gYXdhaXQgdGhpcy5wZXJzb25hbFdhbGxldD8uZ2V0U2lnbmVyKCk7XG4gICAgICBpZiAoIXBlcnNvbmFsV2FsbGV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGlzQWRtaW46IHRydWUsXG4gICAgICAgIHNpZ25lcjogYXdhaXQgcGVyc29uYWxXYWxsZXQuZ2V0QWRkcmVzcygpLFxuICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUoMCksXG4gICAgICAgICAgZXhwaXJhdGlvbkRhdGU6IG5ldyBEYXRlKDApLFxuICAgICAgICAgIG5hdGl2ZVRva2VuTGltaXRQZXJUcmFuc2FjdGlvbjogQmlnTnVtYmVyLmZyb20oMCksXG4gICAgICAgICAgYXBwcm92ZWRDYWxsVGFyZ2V0czogW11cbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5kZXJseWluZyBhY2NvdW50IGNvbnRyYWN0IG9mIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqIEByZXR1cm5zIFRoZSBhY2NvdW50IGNvbnRyYWN0IG9mIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50Q29udHJhY3QoKSB7XG4gICAgLy8gZ2V0dGluZyBhIG5ldyBpbnN0YW5jZSBldmVyeXRpbWVcbiAgICAvLyB0byBhdm9pZCBjYWNoaW5nIGlzc3VlcyBwcmUvcG9zdCBkZXBsb3ltZW50XG4gICAgY29uc3Qgc2RrID0gVGhpcmR3ZWJTREsuZnJvbVNpZ25lcihhd2FpdCB0aGlzLmdldFNpZ25lcigpLCB0aGlzLmNvbmZpZy5jaGFpbiwge1xuICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmNsaWVudElkLFxuICAgICAgc2VjcmV0S2V5OiB0aGlzLmNvbmZpZy5zZWNyZXRLZXlcbiAgICB9KTtcbiAgICBpZiAodGhpcy5jb25maWcuYWNjb3VudEluZm8/LmFiaSkge1xuICAgICAgcmV0dXJuIHNkay5nZXRDb250cmFjdChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgdGhpcy5jb25maWcuYWNjb3VudEluZm8uYWJpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNkay5nZXRDb250cmFjdChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgQUNDT1VOVF9DT1JFX0FCSSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5kZXJseWluZyBhY2NvdW50IGZhY3RvcnkgY29udHJhY3Qgb2YgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICogQHJldHVybnMgVGhlIGFjY291bnQgZmFjdG9yeSBjb250cmFjdC5cbiAgICovXG4gIGFzeW5jIGdldEZhY3RvcnlDb250cmFjdCgpIHtcbiAgICBjb25zdCBzZGsgPSBUaGlyZHdlYlNESy5mcm9tU2lnbmVyKGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCksIHRoaXMuY29uZmlnLmNoYWluLCB7XG4gICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IHRoaXMuY29uZmlnLnNlY3JldEtleVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmNvbmZpZy5mYWN0b3J5SW5mbz8uYWJpKSB7XG4gICAgICByZXR1cm4gc2RrLmdldENvbnRyYWN0KHRoaXMuY29uZmlnLmZhY3RvcnlBZGRyZXNzLCB0aGlzLmNvbmZpZy5mYWN0b3J5SW5mby5hYmkpO1xuICAgIH1cbiAgICByZXR1cm4gc2RrLmdldENvbnRyYWN0KHRoaXMuY29uZmlnLmZhY3RvcnlBZGRyZXNzKTtcbiAgfVxuICBkZWZhdWx0RmFjdG9yeUluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUFjY291bnQ6IGFzeW5jIChmYWN0b3J5LCBvd25lcikgPT4ge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5wcmVwYXJlKFwiY3JlYXRlQWNjb3VudFwiLCBbb3duZXIsIGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhcIlwiKV0pO1xuICAgICAgfSxcbiAgICAgIGdldEFjY291bnRBZGRyZXNzOiBhc3luYyAoZmFjdG9yeSwgb3duZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZhY3RvcnkuY2FsbChcImdldEFkZHJlc3NcIiwgW293bmVyLCBldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoXCJcIildKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRlZmF1bHRBY2NvdW50SW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhlY3V0ZTogYXN5bmMgKGFjY291bnQsIHRhcmdldCwgdmFsdWUsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjY291bnQucHJlcGFyZShcImV4ZWN1dGVcIiwgW3RhcmdldCwgdmFsdWUsIGRhdGFdKTtcbiAgICAgIH0sXG4gICAgICBnZXROb25jZTogYXN5bmMgYWNjb3VudCA9PiB7XG4gICAgICAgIHJldHVybiBhY2NvdW50LmNhbGwoXCJnZXROb25jZVwiLCBbXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vLyBQUklWQVRFIE1FVEhPRFNcblxuICBhc3luYyBlc3RpbWF0ZVR4KHR4LCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkgfHwgIXRoaXMuYWFQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGxldCBkZXBsb3lHYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKDApO1xuICAgIGNvbnN0IFtwcm92aWRlciwgaXNEZXBsb3llZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5nZXRQcm92aWRlcigpLCB0aGlzLmlzRGVwbG95ZWQoKV0pO1xuICAgIGlmICghaXNEZXBsb3llZCkge1xuICAgICAgZGVwbG95R2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVwbG95bWVudEdhc0xpbWl0KCk7XG4gICAgfVxuICAgIGNvbnN0IFt1c2VyT3AsIGdhc1ByaWNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmFjY291bnRBcGkuY3JlYXRlVW5zaWduZWRVc2VyT3AodGhpcy5hYVByb3ZpZGVyLmh0dHBScGNDbGllbnQsIHR4LCBvcHRpb25zKSwgZ2V0R2FzUHJpY2UocHJvdmlkZXIpXSk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCB1dGlscy5yZXNvbHZlUHJvcGVydGllcyh1c2VyT3ApO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzTGltaXQgPSBCaWdOdW1iZXIuZnJvbShyZXNvbHZlZC5jYWxsR2FzTGltaXQpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQ29zdCA9IHRyYW5zYWN0aW9uR2FzTGltaXQubXVsKGdhc1ByaWNlKTtcbiAgICBjb25zdCBkZXBsb3lDb3N0ID0gZGVwbG95R2FzTGltaXQubXVsKGdhc1ByaWNlKTtcbiAgICBjb25zdCB0b3RhbENvc3QgPSBkZXBsb3lDb3N0LmFkZCh0cmFuc2FjdGlvbkNvc3QpO1xuICAgIHJldHVybiB7XG4gICAgICBldGhlcjogdXRpbHMuZm9ybWF0RXRoZXIodG90YWxDb3N0KSxcbiAgICAgIHdlaTogdG90YWxDb3N0LFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICBkZXBsb3lHYXNMaW1pdCxcbiAgICAgICAgdHJhbnNhY3Rpb25HYXNMaW1pdCxcbiAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgIHRyYW5zYWN0aW9uQ29zdCxcbiAgICAgICAgZGVwbG95Q29zdCxcbiAgICAgICAgdG90YWxDb3N0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveW1lbnRHYXNMaW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGluaXRDb2RlID0gYXdhaXQgdGhpcy5hY2NvdW50QXBpLmdldEluaXRDb2RlKCk7XG4gICAgY29uc3QgW2luaXRHYXMsIHZlcmlmaWNhdGlvbkdhc0xpbWl0XSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmFjY291bnRBcGkuZXN0aW1hdGVDcmVhdGlvbkdhcyhpbml0Q29kZSksIHRoaXMuYWNjb3VudEFwaS5nZXRWZXJpZmljYXRpb25HYXNMaW1pdCgpXSk7XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZlcmlmaWNhdGlvbkdhc0xpbWl0KS5hZGQoaW5pdEdhcyk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUJhdGNoUmF3KHRyYW5zYWN0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRUeHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMubWFwKHRyYW5zYWN0aW9uID0+IGV0aGVycy51dGlscy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbikpKTtcbiAgICBjb25zdCB0YXJnZXRzID0gcmVzb2x2ZWRUeHMubWFwKHR4ID0+IHR4LnRvIHx8IGNvbnN0YW50cy5BZGRyZXNzWmVybyk7XG4gICAgY29uc3QgZGF0YSA9IHJlc29sdmVkVHhzLm1hcCh0eCA9PiB0eC5kYXRhIHx8IFwiMHhcIik7XG4gICAgY29uc3QgdmFsdWVzID0gcmVzb2x2ZWRUeHMubWFwKHR4ID0+IHR4LnZhbHVlIHx8IEJpZ051bWJlci5mcm9tKDApKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHg6IGF3YWl0IHRoaXMuYWNjb3VudEFwaS5wcmVwYXJlRXhlY3V0ZUJhdGNoKHRhcmdldHMsIHZhbHVlcywgZGF0YSksXG4gICAgICBiYXRjaERhdGE6IHtcbiAgICAgICAgdGFyZ2V0cyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdmFsdWVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBwcmVwYXJlQmF0Y2hUeCh0cmFuc2FjdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldHMgPSB0cmFuc2FjdGlvbnMubWFwKHR4ID0+IHR4LmdldFRhcmdldCgpKTtcbiAgICBjb25zdCBkYXRhID0gdHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5lbmNvZGUoKSk7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5nZXRWYWx1ZSgpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4OiBhd2FpdCB0aGlzLmFjY291bnRBcGkucHJlcGFyZUV4ZWN1dGVCYXRjaCh0YXJnZXRzLCB2YWx1ZXMsIGRhdGEpLFxuICAgICAgYmF0Y2hEYXRhOiB7XG4gICAgICAgIHRhcmdldHMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHZhbHVlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgU21hcnRXYWxsZXRDb25uZWN0b3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js\n"));

/***/ })

}]);