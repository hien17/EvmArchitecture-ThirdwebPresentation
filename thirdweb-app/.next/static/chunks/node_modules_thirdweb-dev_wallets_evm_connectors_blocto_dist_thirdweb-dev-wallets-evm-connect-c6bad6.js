"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_thirdweb-dev_wallets_evm_connectors_blocto_dist_thirdweb-dev-wallets-evm-connect-c6bad6"],{

/***/ "./node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js ***!
  \*********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BloctoConnector: function() { return /* binding */ BloctoConnector; }\n/* harmony export */ });\n/* harmony import */ var _dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../dist/defineProperty-350fc508.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/defineProperty-350fc508.browser.esm.js\");\n/* harmony import */ var _dist_WagmiConnector_2f14002d_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../dist/WagmiConnector-2f14002d.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-2f14002d.browser.esm.js\");\n/* harmony import */ var _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../dist/errors-9edc08c8.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/errors-9edc08c8.browser.esm.js\");\n/* harmony import */ var _blocto_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @blocto/sdk */ \"./node_modules/@blocto/sdk/dist/blocto-sdk.module.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _dist_walletIds_dff6dced_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/walletIds-dff6dced.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/walletIds-dff6dced.browser.esm.js\");\n/* harmony import */ var _dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../dist/url-a45219bd.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _dist_normalizeChainId_1fb9aedf_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../dist/normalizeChainId-1fb9aedf.browser.esm.js */ \"./node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-1fb9aedf.browser.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@thirdweb-dev/wallets/node_modules/eventemitter3/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\nclass BloctoConnector extends _dist_WagmiConnector_2f14002d_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.W {\n  constructor(_ref) {\n    let {\n      chains,\n      options = {}\n    } = _ref;\n    super({\n      chains,\n      options\n    });\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, \"id\", _dist_walletIds_dff6dced_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.w.blocto);\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, \"name\", \"Blocto\");\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, \"ready\", true);\n    this._onAccountsChangedBind = this.onAccountsChanged.bind(this);\n    this._onChainChangedBind = this.onChainChanged.bind(this);\n    this._onDisconnectBind = this.onDisconnect.bind(this);\n  }\n  async connect(config) {\n    try {\n      const provider = await this.getProvider(config);\n      this.setupListeners();\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n      const accounts = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n      const account = ethers__WEBPACK_IMPORTED_MODULE_5__.utils.getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      this._handleConnectReset();\n      if (this._isUserRejectedRequestError(error)) {\n        throw new _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.U(error);\n      }\n      throw error;\n    }\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    await provider.request({\n      method: \"wallet_disconnect\"\n    });\n    this.removeListeners();\n    this._handleConnectReset();\n  }\n  async getAccount() {\n    const provider = await this.getProvider();\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n    const [address] = accounts || [];\n    if (!address) {\n      throw new Error(\"No accounts found\");\n    }\n    return address;\n  }\n  async getChainId() {\n    const provider = await this.getProvider();\n    const chainId = await provider.request({\n      method: \"eth_chainId\"\n    });\n    return (0,_dist_normalizeChainId_1fb9aedf_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.n)(chainId);\n  }\n  getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this._provider) {\n      const _chainId = chainId ?? this.chains[0]?.chainId ?? 1;\n      const _rpc = this.chains.find(x => x.chainId === _chainId)?.rpc[0];\n      this._provider = new _blocto_sdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        ethereum: {\n          chainId: _chainId,\n          rpc: _rpc\n        },\n        appId: this.options.appId\n      })?.ethereum;\n    }\n    if (!this._provider) {\n      throw new _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.a();\n    }\n    return Promise.resolve(this._provider);\n  }\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n    return new ethers__WEBPACK_IMPORTED_MODULE_5__.providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n  async isAuthorized() {\n    return !!this._provider?._blocto?.sessionKeyEnv ?? false;\n  }\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const id = ethers__WEBPACK_IMPORTED_MODULE_5__.utils.hexValue(chainId);\n    const chain = this.chains.find(x => x.chainId === chainId);\n    if (!chain) {\n      throw new _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.S(new Error(\"chain not found on connector.\"));\n    }\n    const blocktoSupportedChainList = await provider.supportChainList();\n    const isBloctoSupportChain = blocktoSupportedChainList[`${chainId}`];\n    if (!isBloctoSupportChain) {\n      throw new _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.S(new Error(`Blocto unsupported chain: ${id}`));\n    }\n    try {\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: id,\n          rpcUrls: (0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_8__.g)(chain) // no client id on purpose here\n        }]\n      });\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: id\n        }]\n      });\n      return chain;\n    } catch (error) {\n      if (this._isUserRejectedRequestError(error)) {\n        throw new _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.U(error);\n      }\n      throw new _dist_errors_9edc08c8_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.S(error);\n    }\n  }\n  onAccountsChanged() {\n    // not supported yet\n  }\n  async onChainChanged(chain) {\n    const id = (0,_dist_normalizeChainId_1fb9aedf_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.n)(chain);\n    const unsupported = this.isChainUnsupported(id);\n    const account = await this.getAccount();\n    this.emit(\"change\", {\n      chain: {\n        id,\n        unsupported\n      },\n      account\n    });\n  }\n  onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    provider.on(\"accountsChanged\", this._onAccountsChangedBind);\n    provider.on(\"chainChanged\", this._onChainChangedBind);\n    provider.on(\"disconnect\", this._onDisconnectBind);\n  }\n  async removeListeners() {\n    const provider = await this.getProvider();\n    provider.off(\"accountsChanged\", this._onAccountsChangedBind);\n    provider.off(\"chainChanged\", this._onChainChangedBind);\n    provider.off(\"disconnect\", this._onDisconnectBind);\n  }\n  _isUserRejectedRequestError(error) {\n    return /(user rejected)/i.test(error.message);\n  }\n  _handleConnectReset() {\n    this._provider = undefined;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL2Jsb2N0by9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLWJsb2N0by5icm93c2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ0Q7QUFDc0Q7QUFDaEg7QUFDTTtBQUMwQztBQUNLO0FBQ1M7QUFDcEU7QUFDUDs7QUFFdkIsOEJBQThCLDJFQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLCtFQUFlLGFBQWEsc0VBQVM7QUFDekMsSUFBSSwrRUFBZTtBQUNuQixJQUFJLCtFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHlDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtCQUFrQixtRUFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLGlGQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsNkNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBSztBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFnQjtBQUNoQztBQUNBO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQSxnQkFBZ0IsbUVBQWdCLHdDQUF3QyxHQUFHO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRUFBb0I7QUFDdkMsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsbUVBQXdCO0FBQzFDO0FBQ0EsZ0JBQWdCLG1FQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlGQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvd2FsbGV0cy9ldm0vY29ubmVjdG9ycy9ibG9jdG8vZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0tY29ubmVjdG9ycy1ibG9jdG8uYnJvd3Nlci5lc20uanM/ZmQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9kZWZpbmVQcm9wZXJ0eSB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvZGVmaW5lUHJvcGVydHktMzUwZmM1MDguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgVyBhcyBXYWdtaUNvbm5lY3RvciB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvV2FnbWlDb25uZWN0b3ItMmYxNDAwMmQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgVSBhcyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsIGEgYXMgQ29ubmVjdG9yTm90Rm91bmRFcnJvciwgUyBhcyBTd2l0Y2hDaGFpbkVycm9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9lcnJvcnMtOWVkYzA4YzguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IEJsb2N0b1NESyBmcm9tICdAYmxvY3RvL3Nkayc7XG5pbXBvcnQgeyB1dGlscywgcHJvdmlkZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IHcgYXMgd2FsbGV0SWRzIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC93YWxsZXRJZHMtZGZmNmRjZWQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRWYWxpZFB1YmxpY1JQQ1VybCB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvdXJsLWE0NTIxOWJkLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IG4gYXMgbm9ybWFsaXplQ2hhaW5JZCB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3Qvbm9ybWFsaXplQ2hhaW5JZC0xZmI5YWVkZi5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY2hhaW5zJztcbmltcG9ydCAnZXZlbnRlbWl0dGVyMyc7XG5cbmNsYXNzIEJsb2N0b0Nvbm5lY3RvciBleHRlbmRzIFdhZ21pQ29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjaGFpbnMsXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBjaGFpbnMsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgd2FsbGV0SWRzLmJsb2N0byk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIkJsb2N0b1wiKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFkeVwiLCB0cnVlKTtcbiAgICB0aGlzLl9vbkFjY291bnRzQ2hhbmdlZEJpbmQgPSB0aGlzLm9uQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DaGFpbkNoYW5nZWRCaW5kID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRGlzY29ubmVjdEJpbmQgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcihjb25maWcpO1xuICAgICAgdGhpcy5zZXR1cExpc3RlbmVycygpO1xuICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCB7XG4gICAgICAgIHR5cGU6IFwiY29ubmVjdGluZ1wiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWNjb3VudCA9IHV0aWxzLmdldEFkZHJlc3MoYWNjb3VudHNbMF0pO1xuICAgICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgIGNvbnN0IHVuc3VwcG9ydGVkID0gdGhpcy5pc0NoYWluVW5zdXBwb3J0ZWQoaWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB1bnN1cHBvcnRlZFxuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlclxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdFJlc2V0KCk7XG4gICAgICBpZiAodGhpcy5faXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwid2FsbGV0X2Rpc2Nvbm5lY3RcIlxuICAgIH0pO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5faGFuZGxlQ29ubmVjdFJlc2V0KCk7XG4gIH1cbiAgYXN5bmMgZ2V0QWNjb3VudCgpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiXG4gICAgfSk7XG4gICAgY29uc3QgW2FkZHJlc3NdID0gYWNjb3VudHMgfHwgW107XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY2NvdW50cyBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIlxuICAgIH0pO1xuICAgIHJldHVybiBub3JtYWxpemVDaGFpbklkKGNoYWluSWQpO1xuICB9XG4gIGdldFByb3ZpZGVyKCkge1xuICAgIGxldCB7XG4gICAgICBjaGFpbklkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCF0aGlzLl9wcm92aWRlcikge1xuICAgICAgY29uc3QgX2NoYWluSWQgPSBjaGFpbklkID8/IHRoaXMuY2hhaW5zWzBdPy5jaGFpbklkID8/IDE7XG4gICAgICBjb25zdCBfcnBjID0gdGhpcy5jaGFpbnMuZmluZCh4ID0+IHguY2hhaW5JZCA9PT0gX2NoYWluSWQpPy5ycGNbMF07XG4gICAgICB0aGlzLl9wcm92aWRlciA9IG5ldyBCbG9jdG9TREsoe1xuICAgICAgICBldGhlcmV1bToge1xuICAgICAgICAgIGNoYWluSWQ6IF9jaGFpbklkLFxuICAgICAgICAgIHJwYzogX3JwY1xuICAgICAgICB9LFxuICAgICAgICBhcHBJZDogdGhpcy5vcHRpb25zLmFwcElkXG4gICAgICB9KT8uZXRoZXJldW07XG4gICAgfVxuICAgIGlmICghdGhpcy5fcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RGb3VuZEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcHJvdmlkZXIpO1xuICB9XG4gIGFzeW5jIGdldFNpZ25lcigpIHtcbiAgICBsZXQge1xuICAgICAgY2hhaW5JZFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IFtwcm92aWRlciwgYWNjb3VudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5nZXRQcm92aWRlcigpLCB0aGlzLmdldEFjY291bnQoKV0pO1xuICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLldlYjNQcm92aWRlcihwcm92aWRlciwgY2hhaW5JZCkuZ2V0U2lnbmVyKGFjY291bnQpO1xuICB9XG4gIGFzeW5jIGlzQXV0aG9yaXplZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wcm92aWRlcj8uX2Jsb2N0bz8uc2Vzc2lvbktleUVudiA/PyBmYWxzZTtcbiAgfVxuICBhc3luYyBzd2l0Y2hDaGFpbihjaGFpbklkKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgY29uc3QgaWQgPSB1dGlscy5oZXhWYWx1ZShjaGFpbklkKTtcbiAgICBjb25zdCBjaGFpbiA9IHRoaXMuY2hhaW5zLmZpbmQoeCA9PiB4LmNoYWluSWQgPT09IGNoYWluSWQpO1xuICAgIGlmICghY2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBFcnJvcihcImNoYWluIG5vdCBmb3VuZCBvbiBjb25uZWN0b3IuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2t0b1N1cHBvcnRlZENoYWluTGlzdCA9IGF3YWl0IHByb3ZpZGVyLnN1cHBvcnRDaGFpbkxpc3QoKTtcbiAgICBjb25zdCBpc0Jsb2N0b1N1cHBvcnRDaGFpbiA9IGJsb2NrdG9TdXBwb3J0ZWRDaGFpbkxpc3RbYCR7Y2hhaW5JZH1gXTtcbiAgICBpZiAoIWlzQmxvY3RvU3VwcG9ydENoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgU3dpdGNoQ2hhaW5FcnJvcihuZXcgRXJyb3IoYEJsb2N0byB1bnN1cHBvcnRlZCBjaGFpbjogJHtpZH1gKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIndhbGxldF9hZGRFdGhlcmV1bUNoYWluXCIsXG4gICAgICAgIHBhcmFtczogW3tcbiAgICAgICAgICBjaGFpbklkOiBpZCxcbiAgICAgICAgICBycGNVcmxzOiBnZXRWYWxpZFB1YmxpY1JQQ1VybChjaGFpbikgLy8gbm8gY2xpZW50IGlkIG9uIHB1cnBvc2UgaGVyZVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCIsXG4gICAgICAgIHBhcmFtczogW3tcbiAgICAgICAgICBjaGFpbklkOiBpZFxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhaW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLl9pc1VzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU3dpdGNoQ2hhaW5FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIG9uQWNjb3VudHNDaGFuZ2VkKCkge1xuICAgIC8vIG5vdCBzdXBwb3J0ZWQgeWV0XG4gIH1cbiAgYXN5bmMgb25DaGFpbkNoYW5nZWQoY2hhaW4pIHtcbiAgICBjb25zdCBpZCA9IG5vcm1hbGl6ZUNoYWluSWQoY2hhaW4pO1xuICAgIGNvbnN0IHVuc3VwcG9ydGVkID0gdGhpcy5pc0NoYWluVW5zdXBwb3J0ZWQoaWQpO1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmdldEFjY291bnQoKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwge1xuICAgICAgY2hhaW46IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHVuc3VwcG9ydGVkXG4gICAgICB9LFxuICAgICAgYWNjb3VudFxuICAgIH0pO1xuICB9XG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIHNldHVwTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIHByb3ZpZGVyLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIHRoaXMuX29uQWNjb3VudHNDaGFuZ2VkQmluZCk7XG4gICAgcHJvdmlkZXIub24oXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5fb25DaGFpbkNoYW5nZWRCaW5kKTtcbiAgICBwcm92aWRlci5vbihcImRpc2Nvbm5lY3RcIiwgdGhpcy5fb25EaXNjb25uZWN0QmluZCk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIHByb3ZpZGVyLm9mZihcImFjY291bnRzQ2hhbmdlZFwiLCB0aGlzLl9vbkFjY291bnRzQ2hhbmdlZEJpbmQpO1xuICAgIHByb3ZpZGVyLm9mZihcImNoYWluQ2hhbmdlZFwiLCB0aGlzLl9vbkNoYWluQ2hhbmdlZEJpbmQpO1xuICAgIHByb3ZpZGVyLm9mZihcImRpc2Nvbm5lY3RcIiwgdGhpcy5fb25EaXNjb25uZWN0QmluZCk7XG4gIH1cbiAgX2lzVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIC8odXNlciByZWplY3RlZCkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIF9oYW5kbGVDb25uZWN0UmVzZXQoKSB7XG4gICAgdGhpcy5fcHJvdmlkZXIgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmxvY3RvQ29ubmVjdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js\n"));

/***/ }),

/***/ "./node_modules/@blocto/sdk/dist/blocto-sdk.module.js":
/*!************************************************************!*\
  !*** ./node_modules/@blocto/sdk/dist/blocto-sdk.module.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ BloctoSDK; }\n/* harmony export */ });\n/* Version: 0.10.2 - May 3, 2024 04:32:29 */\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n// instead invariant from package, since all error will throw on production\nfunction invariant(condition, format) {\n    if (!condition) {\n        throw new Error(format);\n    }\n}\n\nvar KEY_SESSION;\n(function (KEY_SESSION) {\n    KEY_SESSION[\"prod\"] = \"BLOCTO_SDK\";\n    KEY_SESSION[\"dev\"] = \"BLOCTO_SDK_DEV\";\n    KEY_SESSION[\"staging\"] = \"BLOCTO_SDK_STAGING\";\n})(KEY_SESSION || (KEY_SESSION = {}));\nvar CHAIN;\n(function (CHAIN) {\n    CHAIN[\"ETHEREUM\"] = \"ethereum\";\n    CHAIN[\"APTOS\"] = \"aptos\";\n})(CHAIN || (CHAIN = {}));\n/* eth series constants begin */\nconst ETH_RPC_LIST = {\n    // This is the list of public RPC endpoints that we known to be working\n    // Used to help developers did not set up their own RPC endpoints\n    // BSC mainnet\n    56: 'https://bsc-dataseed1.binance.org',\n    // BSC testnet\n    97: 'https://data-seed-prebsc-1-s1.binance.org:8545',\n    // Polygon Mainnet\n    137: 'https://rpc-mainnet.maticvigil.com/',\n    // Polygon Amoy Testnet\n    80002: 'https://rpc-amoy.polygon.technology/',\n    // Avalanche Mainnet\n    43114: 'https://api.avax.network/ext/bc/C/rpc',\n    // Avalanche Fuji Testnet\n    43113: 'https://api.avax-test.network/ext/bc/C/rpc',\n    // Arbitrum Mainnet\n    42161: 'https://arb1.arbitrum.io/rpc',\n    // Arbitrum Sepolia Testnet\n    421614: 'https://arbitrum-sepolia.blockpi.network/v1/rpc/public',\n    // Optimism Mainnet\n    10: 'https://mainnet.optimism.io',\n    // Optimism Sepolia Testnet\n    11155420: 'https://sepolia.optimism.io',\n    // Base Mainnet\n    8453: 'https://mainnet.base.org',\n    // Base Sepolia Testnet\n    84532: 'https://sepolia.base.org',\n    // Zora\n    7777777: 'https://rpc.zora.energy',\n    // Zora Sepolia Testnet\n    999999999: 'https://sepolia.rpc.zora.energy',\n    // Scroll\n    534352: 'https://rpc.scroll.io',\n    // Scroll Sepolia Testnet\n    534351: 'https://sepolia-rpc.scroll.io',\n    // Linea\n    59144: 'https://rpc.linea.build',\n    // zKatana Sepolia Testnet\n    1261120: 'https://rpc.startale.com/zkatana',\n    // Blast\n    81457: 'https://rpc.blast.io',\n    // Blast Sepolia Testnet\n    168587773: 'https://sepolia.blast.io'\n};\nconst ETH_ENV_WALLET_SERVER_MAPPING = {\n    prod: 'https://wallet-v2.blocto.app',\n    staging: 'https://wallet-v2-staging.blocto.app',\n    dev: 'https://wallet-v2-dev.blocto.app',\n};\nconst ETH_SESSION_KEY_MAPPING = {\n    prod: KEY_SESSION.prod,\n    staging: KEY_SESSION.staging,\n    dev: KEY_SESSION.dev,\n};\n/* eth series constants end */\n/* aptos constants begin */\nconst APT_SESSION_KEY_MAPPING = {\n    1: KEY_SESSION.prod,\n    2: KEY_SESSION.dev,\n    3: KEY_SESSION.dev,\n    4: KEY_SESSION.dev,\n    5: KEY_SESSION.staging,\n};\nconst APT_CHAIN_ID_SERVER_MAPPING = {\n    // MAINNET\n    1: 'https://wallet-v2.blocto.app',\n    // TESTNET\n    2: 'https://wallet-v2-dev.blocto.app',\n    // DEVNET\n    3: 'https://wallet-v2-dev.blocto.app',\n    // TESTING\n    4: 'https://wallet-v2-dev.blocto.app',\n    // PREMAINNET\n    5: 'https://wallet-v2-staging.blocto.app',\n};\nvar WalletAdapterNetwork;\n(function (WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n    WalletAdapterNetwork[\"Testing\"] = \"testing\";\n    WalletAdapterNetwork[\"Premainnet\"] = \"premainnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\nconst APT_CHAIN_ID_NAME_MAPPING = {\n    1: WalletAdapterNetwork.Mainnet,\n    2: WalletAdapterNetwork.Testnet,\n    3: WalletAdapterNetwork.Devnet,\n    4: WalletAdapterNetwork.Testing,\n    5: WalletAdapterNetwork.Premainnet,\n};\nconst APT_CHAIN_ID_RPC_MAPPING = {\n    1: 'https://fullnode.mainnet.aptoslabs.com/v1',\n    2: 'https://fullnode.testnet.aptoslabs.com/v1',\n    3: 'https://fullnode.devnet.aptoslabs.com/v1',\n    4: '',\n    5: 'https://premainnet.aptosdev.com/v1',\n};\n/* aptos constants end */\nconst EIP1193_EVENTS = [\n    'connect',\n    'disconnect',\n    'message',\n    'chainChanged',\n    'accountsChanged',\n];\n// Preserve login for 1 day\nconst LOGIN_PERSISTING_TIME = 86400 * 1000;\nconst DEFAULT_APP_ID = '00000000-0000-0000-0000-000000000000';\n// Will inject the version of the SDK by rollup versionInjector during build time\nconst SDK_VERSION = '0.10.2';\n\n// The root class for all providers\nclass BloctoProvider {\n    constructor() {\n        this.isBlocto = true;\n        this.isConnecting = false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.eventListeners = {};\n        // alias removeListener\n        this.off = this.removeListener;\n        // init event listeners\n        EIP1193_EVENTS.forEach((event) => {\n            this.eventListeners[event] = [];\n        });\n        this.appId = DEFAULT_APP_ID;\n    }\n    // implement by children\n    // eslint-disable-next-line\n    request(payload) {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    on(event, listener) {\n        if (!EIP1193_EVENTS.includes(event))\n            return;\n        this.eventListeners[event].push(listener);\n    }\n    // @todo: implement it\n    // eslint-disable-next-line\n    once() { }\n    removeListener(event, listener) {\n        const listeners = this.eventListeners[event];\n        const index = listeners.findIndex((item) => item === listener);\n        if (index !== -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n}\n\nconst IFRAME_STYLE = 'width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;';\nfunction createFrame(url) {\n    const frame = document.createElement('iframe');\n    frame.setAttribute('src', url);\n    frame.setAttribute('style', IFRAME_STYLE);\n    return frame;\n}\nfunction attachFrame(frame) {\n    document.body.appendChild(frame);\n}\nfunction detatchFrame(frame) {\n    const parentNode = frame && frame.parentNode;\n    if (parentNode && parentNode.removeChild instanceof Function) {\n        parentNode.removeChild(frame);\n    }\n}\n\nvar addSelfRemovableHandler = (eventType, handler, target = window) => {\n    function listener(e) {\n        const removeEventListener = () => target.removeEventListener(eventType, listener);\n        handler(e, removeEventListener);\n    }\n    target.addEventListener(eventType, listener);\n};\n\nconst isStorageSupported = () => {\n    if (typeof window === 'undefined') {\n        return false;\n    }\n    try {\n        window.sessionStorage.setItem('local_storage_supported', '1');\n        const result = window.sessionStorage.getItem('local_storage_supported');\n        window.sessionStorage.removeItem('local_storage_supported');\n        return result === '1';\n    }\n    catch (error) {\n        return false;\n    }\n};\nclass MemoryStorage {\n    constructor() {\n        this.storage = {};\n    }\n    getItem(key) {\n        return this[key] || null;\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n}\nconst memoryStorage = typeof window !== 'undefined' ? window.memoryStorage : new MemoryStorage();\n\nconst storage = isStorageSupported() ? window.sessionStorage : memoryStorage;\nconst getItem = (key, defaultValue = null) => {\n    const value = storage.getItem(key);\n    try {\n        return (value && JSON.parse(value)) || defaultValue;\n    }\n    catch (SyntaxError) {\n        return value || defaultValue;\n    }\n};\nconst setItem = (key, value) => storage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));\nconst removeItem = (key) => {\n    setItem(key, ''); // Due to some versions of browser bug can't removeItem correctly.\n    storage.removeItem(key);\n};\n/**\n * @param {KEY_SESSION} key - key to retrieve the data\n * @returns {ProviderSession | null} ProviderSession | null\n * @description\n * Get ProviderSession from storage.\n * If the data is expired, will remove the data and return null\n */\nconst getAccountStorage = (key) => {\n    const rawAccountStorage = getItem(key, null);\n    if (!rawAccountStorage)\n        return null;\n    // compare the expiry time of the item with the current time\n    if (new Date().getTime() > rawAccountStorage.expiry ||\n        rawAccountStorage.v !== SDK_VERSION) {\n        removeItem(key);\n        return null;\n    }\n    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;\n};\n/**\n  @param {KEY_SESSION} key - key to store the data\n  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated\n  @param {number} expiry - expiry time of the data\n*/\nconst setAccountStorage = (key, data, expiry) => {\n    var _a, _b, _c;\n    const rawAccountStorage = getItem(key);\n    const newAccountStorage = {\n        data: {\n            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),\n            accounts: Object.assign(Object.assign({}, (_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.accounts), data === null || data === void 0 ? void 0 : data.accounts),\n            evm: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.evm), data === null || data === void 0 ? void 0 : data.evm),\n        },\n        expiry: expiry ||\n            (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) ||\n            new Date().getTime() + LOGIN_PERSISTING_TIME,\n        v: SDK_VERSION,\n    };\n    setItem(key, newAccountStorage);\n    return;\n};\nconst getChainAddress = (key, chain) => {\n    var _a, _b, _c;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_c = (_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c[chain]) || null;\n};\nconst setChainAddress = (key, chain, account) => {\n    setAccountStorage(key, { accounts: { [chain]: account } });\n    return;\n};\nconst removeChainAddress = (key, chain) => {\n    setAccountStorage(key, { accounts: { [chain]: undefined } });\n    return;\n};\nconst getEvmAddress = (key, chain) => {\n    var _a, _b, _c;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_c = (_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.evm) === null || _c === void 0 ? void 0 : _c[chain]) || null;\n};\nconst setEvmAddress = (key, chain, accounts) => {\n    setAccountStorage(key, { evm: { [chain]: accounts } });\n    return;\n};\nconst removeAllEvmAddress = (key) => {\n    const newAccountStorage = getItem(key);\n    if (!newAccountStorage)\n        return;\n    newAccountStorage.data.evm = {};\n    setItem(key, newAccountStorage);\n    return;\n};\n\nfunction responseSessionGuard(response, key, disconnectHandler) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (response.status === 403 || response.status === 401) {\n            if (disconnectHandler) {\n                disconnectHandler();\n            }\n            removeItem(key);\n        }\n        if (!response.ok) {\n            const data = yield response.json();\n            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || 'unknown error');\n            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;\n            throw e;\n        }\n        return response.json();\n    });\n}\n\nconst isEmail = (value) => /\\S+@\\S+\\.\\S+/.test(value);\n\nvar ERROR_MESSAGE;\n(function (ERROR_MESSAGE) {\n    ERROR_MESSAGE[\"INVALID_TRANSACTION\"] = \"Invalid transaction\";\n    ERROR_MESSAGE[\"INVALID_TRANSACTIONS\"] = \"Invalid transactions\";\n    ERROR_MESSAGE[\"INVALID_TRANSACTION_VALUE\"] = \"Transaction params \\\"value\\\" should be hex-encoded string\";\n})(ERROR_MESSAGE || (ERROR_MESSAGE = {}));\n\nvar global$1 = (typeof global !== \"undefined\" ? global :\n  typeof self !== \"undefined\" ? self :\n  typeof window !== \"undefined\" ? window : {});\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n  ? global$1.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nkMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) ;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nconst isHexString = (hex) => typeof hex === 'string' && /^0x[0-9A-Fa-f]*$/.test(hex);\nconst utf8ToHex = (str) => {\n    return Buffer.from(str, 'utf8').toString('hex');\n};\n\nconst isValidTransaction = (transaction) => {\n    if (!transaction ||\n        typeof transaction !== 'object' ||\n        !('from' in transaction)) {\n        return { isValid: false, invalidMsg: ERROR_MESSAGE.INVALID_TRANSACTION };\n    }\n    if (transaction.value && !isHexString(transaction.value)) {\n        return {\n            isValid: false,\n            invalidMsg: ERROR_MESSAGE.INVALID_TRANSACTION_VALUE,\n        };\n    }\n    return { isValid: true };\n};\nconst isValidTransactions = (transactions) => {\n    if (!Array.isArray(transactions)) {\n        return { isValid: false, invalidMsg: ERROR_MESSAGE.INVALID_TRANSACTIONS };\n    }\n    for (let i = 0; i < transactions.length; i++) {\n        const { isValid, invalidMsg } = isValidTransaction(transactions[i]);\n        if (!isValid) {\n            return { isValid, invalidMsg };\n        }\n    }\n    return { isValid: true };\n};\n\nfunction getEvmSupport() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { networks } = yield fetch('https://api.blocto.app/networks/evm').then((response) => response.json());\n        const evmSupportMap = networks.reduce((a, v) => (Object.assign(Object.assign({}, a), { [v.chain_id]: v })), {});\n        return evmSupportMap;\n    });\n}\n\nvar dist = {};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct$1()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\n\nvar classes = {};\n\nvar fastSafeStringify = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = '[...]';\nvar CIRCULAR_REPLACE_NODE = '[Circular]';\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  };\n}\n\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n  decirc(obj, '', 0, [], undefined, 0, options);\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, {\n        value: replace\n      });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer = typeof replacer !== 'undefined' ? replacer : function (k, v) {\n    return v;\n  };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(classes, \"__esModule\", {\n  value: true\n});\nclasses.EthereumProviderError = classes.EthereumRpcError = void 0;\nvar fast_safe_stringify_1 = fastSafeStringify;\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n * Permits any integer error code.\n */\nvar EthereumRpcError = /*#__PURE__*/function (_Error) {\n  _inherits(EthereumRpcError, _Error);\n  var _super = _createSuper(EthereumRpcError);\n  function EthereumRpcError(code, message, data) {\n    var _this;\n    _classCallCheck(this, EthereumRpcError);\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a nonempty string.');\n    }\n    _this = _super.call(this, message);\n    _this.code = code;\n    if (data !== undefined) {\n      _this.data = data;\n    }\n    return _this;\n  }\n  /**\n   * Returns a plain object with all public class properties.\n   */\n  _createClass(EthereumRpcError, [{\n    key: \"serialize\",\n    value: function serialize() {\n      var serialized = {\n        code: this.code,\n        message: this.message\n      };\n      if (this.data !== undefined) {\n        serialized.data = this.data;\n      }\n      if (this.stack) {\n        serialized.stack = this.stack;\n      }\n      return serialized;\n    }\n    /**\n     * Return a string representation of the serialized error, omitting\n     * any circular references.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return fast_safe_stringify_1[\"default\"](this.serialize(), stringifyReplacer, 2);\n    }\n  }]);\n  return EthereumRpcError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nclasses.EthereumRpcError = EthereumRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nvar EthereumProviderError = /*#__PURE__*/function (_EthereumRpcError) {\n  _inherits(EthereumProviderError, _EthereumRpcError);\n  var _super2 = _createSuper(EthereumProviderError);\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */\n  function EthereumProviderError(code, message, data) {\n    _classCallCheck(this, EthereumProviderError);\n    if (!isValidEthProviderCode(code)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    return _super2.call(this, code, message, data);\n  }\n  return _createClass(EthereumProviderError);\n}(EthereumRpcError);\nclasses.EthereumProviderError = EthereumProviderError;\n// Internal\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n  if (value === '[Circular]') {\n    return undefined;\n  }\n  return value;\n}\n\nvar utils = {};\n\nvar errorConstants = {};\n\nObject.defineProperty(errorConstants, \"__esModule\", {\n  value: true\n});\nerrorConstants.errorValues = errorConstants.errorCodes = void 0;\nerrorConstants.errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nerrorConstants.errorValues = {\n  '-32700': {\n    standard: 'JSON RPC 2.0',\n    message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'\n  },\n  '-32600': {\n    standard: 'JSON RPC 2.0',\n    message: 'The JSON sent is not a valid Request object.'\n  },\n  '-32601': {\n    standard: 'JSON RPC 2.0',\n    message: 'The method does not exist / is not available.'\n  },\n  '-32602': {\n    standard: 'JSON RPC 2.0',\n    message: 'Invalid method parameter(s).'\n  },\n  '-32603': {\n    standard: 'JSON RPC 2.0',\n    message: 'Internal JSON-RPC error.'\n  },\n  '-32000': {\n    standard: 'EIP-1474',\n    message: 'Invalid input.'\n  },\n  '-32001': {\n    standard: 'EIP-1474',\n    message: 'Resource not found.'\n  },\n  '-32002': {\n    standard: 'EIP-1474',\n    message: 'Resource unavailable.'\n  },\n  '-32003': {\n    standard: 'EIP-1474',\n    message: 'Transaction rejected.'\n  },\n  '-32004': {\n    standard: 'EIP-1474',\n    message: 'Method not supported.'\n  },\n  '-32005': {\n    standard: 'EIP-1474',\n    message: 'Request limit exceeded.'\n  },\n  '4001': {\n    standard: 'EIP-1193',\n    message: 'User rejected the request.'\n  },\n  '4100': {\n    standard: 'EIP-1193',\n    message: 'The requested account and/or method has not been authorized by the user.'\n  },\n  '4200': {\n    standard: 'EIP-1193',\n    message: 'The requested method is not supported by this Ethereum provider.'\n  },\n  '4900': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from all chains.'\n  },\n  '4901': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from the specified chain.'\n  }\n};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n  var error_constants_1 = errorConstants;\n  var classes_1 = classes;\n  var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\n  var FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';\n  var FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE)\n  };\n  exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\n  /**\n   * Gets the message for a given code, or a fallback message if the code has\n   * no corresponding message.\n   */\n  function getMessageFromCode(code) {\n    var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n    if (Number.isInteger(code)) {\n      var codeString = code.toString();\n      if (hasKey(error_constants_1.errorValues, codeString)) {\n        return error_constants_1.errorValues[codeString].message;\n      }\n      if (isJsonRpcServerError(code)) {\n        return exports.JSON_RPC_SERVER_ERROR_MESSAGE;\n      }\n    }\n    return fallbackMessage;\n  }\n  exports.getMessageFromCode = getMessageFromCode;\n  /**\n   * Returns whether the given code is valid.\n   * A code is only valid if it has a message.\n   */\n  function isValidCode(code) {\n    if (!Number.isInteger(code)) {\n      return false;\n    }\n    var codeString = code.toString();\n    if (error_constants_1.errorValues[codeString]) {\n      return true;\n    }\n    if (isJsonRpcServerError(code)) {\n      return true;\n    }\n    return false;\n  }\n  exports.isValidCode = isValidCode;\n  /**\n   * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n   * Merely copies the given error's values if it is already compatible.\n   * If the given error is not fully compatible, it will be preserved on the\n   * returned object's data.originalError property.\n   */\n  function serializeError(error) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$fallbackError = _ref.fallbackError,\n      fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError,\n      _ref$shouldIncludeSta = _ref.shouldIncludeStack,\n      shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;\n    var _a, _b;\n    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== 'string') {\n      throw new Error('Must provide fallback error with integer number code and string message.');\n    }\n    if (error instanceof classes_1.EthereumRpcError) {\n      return error.serialize();\n    }\n    var serialized = {};\n    if (error && _typeof(error) === 'object' && !Array.isArray(error) && hasKey(error, 'code') && isValidCode(error.code)) {\n      var _error = error;\n      serialized.code = _error.code;\n      if (_error.message && typeof _error.message === 'string') {\n        serialized.message = _error.message;\n        if (hasKey(_error, 'data')) {\n          serialized.data = _error.data;\n        }\n      } else {\n        serialized.message = getMessageFromCode(serialized.code);\n        serialized.data = {\n          originalError: assignOriginalError(error)\n        };\n      }\n    } else {\n      serialized.code = fallbackError.code;\n      var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\n      serialized.message = message && typeof message === 'string' ? message : fallbackError.message;\n      serialized.data = {\n        originalError: assignOriginalError(error)\n      };\n    }\n    var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\n    if (shouldIncludeStack && error && stack && typeof stack === 'string') {\n      serialized.stack = stack;\n    }\n    return serialized;\n  }\n  exports.serializeError = serializeError;\n  // Internal\n  function isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n  }\n  function assignOriginalError(error) {\n    if (error && _typeof(error) === 'object' && !Array.isArray(error)) {\n      return Object.assign({}, error);\n    }\n    return error;\n  }\n  function hasKey(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  }\n})(utils);\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar errors = {};\n\nObject.defineProperty(errors, \"__esModule\", {\n  value: true\n});\nerrors.ethErrors = void 0;\nvar classes_1 = classes;\nvar utils_1 = utils;\nvar error_constants_1 = errorConstants;\nerrors.ethErrors = {\n  rpc: {\n    /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     */\n    parse: function parse(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     */\n    invalidRequest: function invalidRequest(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     */\n    invalidParams: function invalidParams(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     */\n    methodNotFound: function methodNotFound(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     */\n    internal: function internal(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     */\n    server: function server(opts) {\n      if (!opts || _typeof(opts) !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum RPC Server errors must provide single object argument.');\n      }\n      var code = opts.code;\n      if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n        throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n      }\n      return getEthJsonRpcError(code, opts);\n    },\n    /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     */\n    invalidInput: function invalidInput(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     */\n    resourceNotFound: function resourceNotFound(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     */\n    resourceUnavailable: function resourceUnavailable(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     */\n    transactionRejected: function transactionRejected(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     */\n    methodNotSupported: function methodNotSupported(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     */\n    limitExceeded: function limitExceeded(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);\n    }\n  },\n  provider: {\n    /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     */\n    userRejectedRequest: function userRejectedRequest(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     */\n    unauthorized: function unauthorized(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     */\n    unsupportedMethod: function unsupportedMethod(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     */\n    disconnected: function disconnected(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n    },\n    /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     */\n    chainDisconnected: function chainDisconnected(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n     * Get a custom Ethereum Provider error.\n     */\n    custom: function custom(opts) {\n      if (!opts || _typeof(opts) !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum Provider custom errors must provide single object argument.');\n      }\n      var code = opts.code,\n        message = opts.message,\n        data = opts.data;\n      if (!message || typeof message !== 'string') {\n        throw new Error('\"message\" must be a nonempty string');\n      }\n      return new classes_1.EthereumProviderError(code, message, data);\n    }\n  }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n  var _parseOpts = parseOpts(arg),\n    _parseOpts2 = _slicedToArray(_parseOpts, 2),\n    message = _parseOpts2[0],\n    data = _parseOpts2[1];\n  return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  var _parseOpts3 = parseOpts(arg),\n    _parseOpts4 = _slicedToArray(_parseOpts3, 2),\n    message = _parseOpts4[0],\n    data = _parseOpts4[1];\n  return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === 'string') {\n      return [arg];\n    } else if (_typeof(arg) === 'object' && !Array.isArray(arg)) {\n      var message = arg.message,\n        data = arg.data;\n      if (message && typeof message !== 'string') {\n        throw new Error('Must specify string message.');\n      }\n      return [message || undefined, data];\n    }\n  }\n  return [];\n}\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;\n  var classes_1 = classes;\n  Object.defineProperty(exports, \"EthereumRpcError\", {\n    enumerable: true,\n    get: function get() {\n      return classes_1.EthereumRpcError;\n    }\n  });\n  Object.defineProperty(exports, \"EthereumProviderError\", {\n    enumerable: true,\n    get: function get() {\n      return classes_1.EthereumProviderError;\n    }\n  });\n  var utils_1 = utils;\n  Object.defineProperty(exports, \"serializeError\", {\n    enumerable: true,\n    get: function get() {\n      return utils_1.serializeError;\n    }\n  });\n  Object.defineProperty(exports, \"getMessageFromCode\", {\n    enumerable: true,\n    get: function get() {\n      return utils_1.getMessageFromCode;\n    }\n  });\n  var errors_1 = errors;\n  Object.defineProperty(exports, \"ethErrors\", {\n    enumerable: true,\n    get: function get() {\n      return errors_1.ethErrors;\n    }\n  });\n  var error_constants_1 = errorConstants;\n  Object.defineProperty(exports, \"errorCodes\", {\n    enumerable: true,\n    get: function get() {\n      return error_constants_1.errorCodes;\n    }\n  });\n})(dist);\n\nvar _EthereumProvider_instances, _EthereumProvider_getBloctoProperties, _EthereumProvider_addToSwitchable, _EthereumProvider_checkNetworkMatched, _EthereumProvider_createAuthzFrame;\nfunction parseChainId(chainId) {\n    if (!chainId) {\n        return 1;\n    }\n    if (typeof chainId === 'number') {\n        return chainId;\n    }\n    else if (chainId.startsWith('0x')) {\n        return parseInt(chainId, 16);\n    }\n    return parseInt(chainId, 10);\n}\nclass EthereumProvider extends BloctoProvider {\n    get existedSDK() {\n        if (typeof window === 'undefined')\n            return undefined;\n        return window.ethereum;\n    }\n    constructor(config) {\n        var _a;\n        super();\n        _EthereumProvider_instances.add(this);\n        this.networkVersion = '1'; // same as chainId but in decimal\n        this.off = this.removeListener;\n        this.injectedWalletServer = config.walletServer;\n        this._blocto = {\n            sessionKeyEnv: KEY_SESSION.prod,\n            walletServer: this.injectedWalletServer || '',\n            blockchainName: '',\n            networkType: '',\n            switchableNetwork: {},\n        };\n        this.appId = config.appId || DEFAULT_APP_ID;\n        if ('chainId' in config) {\n            const { chainId, rpc } = config;\n            invariant(chainId, \"'chainId' is required\");\n            this.networkVersion = `${parseChainId(chainId)}`;\n            this.chainId = `0x${parseChainId(chainId).toString(16)}`;\n            // setup rpc\n            this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];\n            invariant(this.rpc, \"'rpc' is required\");\n        }\n        else {\n            const { defaultChainId, switchableChains } = config;\n            invariant(defaultChainId, \"'defaultChainId' is required\");\n            this.networkVersion = `${parseChainId(defaultChainId)}`;\n            this.chainId = `0x${parseChainId(defaultChainId).toString(16)}`;\n            // get config from switchableChains array\n            const chainConfig = switchableChains.find((chain) => parseChainId(chain.chainId) === parseChainId(defaultChainId));\n            if (!chainConfig) {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Chain ${defaultChainId} is not in switchableChains list`,\n                });\n            }\n            this.rpc = ((_a = chainConfig.rpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || ETH_RPC_LIST[this.networkVersion];\n            invariant(this.rpc, \"'rpc' is required\");\n            this._blocto.unloadedNetwork = switchableChains;\n        }\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated\n    send(methodOrPayload, paramsOrCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (true) {\n                // signature type 1: arg1 - JSON-RPC payload, arg2 - callback;\n                // ethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n                // This signature is exactly like ethereum.sendAsync()\n                case paramsOrCallback instanceof Function:\n                    return this.sendAsync(methodOrPayload, paramsOrCallback);\n                // signature type 2: arg1 - JSON-RPC method name, arg2 - params array;\n                // ethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n                // This signature is like an async ethereum.sendAsync() with method and params as arguments,\n                // instead of a JSON-RPC payload and callback\n                case typeof methodOrPayload === 'string' &&\n                    Array.isArray(paramsOrCallback):\n                    return this.sendAsync({\n                        jsonrpc: '2.0',\n                        method: methodOrPayload,\n                        params: paramsOrCallback,\n                    });\n                // signature type 3: arg1 - JSON-RPC payload(should be synchronous methods)\n                // ethereum.send(payload: JsonRpcRequest): unknown;\n                // This signature enables you to call some type of RPC methods synchronously\n                default:\n                    return this.sendAsync(methodOrPayload);\n            }\n        });\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation\n    // web3 v1.x BatchRequest still depends on it so we need to implement anyway ¯\\_(ツ)_/¯\n    sendAsync(payload, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const separateRequests = (payload) => {\n                return payload.reduce((acc, request) => {\n                    var _a;\n                    if (request.method === 'eth_sendTransaction') {\n                        acc.sendRequests.push((_a = request.params) === null || _a === void 0 ? void 0 : _a[0]);\n                    }\n                    else {\n                        acc.otherRequests.push(this.request(request));\n                    }\n                    return acc;\n                }, { sendRequests: [], otherRequests: [] });\n            };\n            function createBaseResponse(item) {\n                return {\n                    id: String(item.id),\n                    jsonrpc: '2.0',\n                    method: item.method,\n                };\n            }\n            function processResponses(payload, responses) {\n                const processedResponses = [];\n                let responseIndex = 1;\n                payload.forEach((item) => {\n                    const baseResponse = createBaseResponse(item);\n                    if (item.method === 'eth_sendTransaction') {\n                        baseResponse.result = responses[0].value;\n                        baseResponse.error =\n                            responses[0].status !== 'fulfilled'\n                                ? responses[0].reason\n                                : undefined;\n                    }\n                    else {\n                        if (responseIndex < responses.length) {\n                            baseResponse.result = responses[responseIndex].value;\n                            baseResponse.error =\n                                responses[responseIndex].status !== 'fulfilled'\n                                    ? responses[responseIndex].reason\n                                    : undefined;\n                            responseIndex++;\n                        }\n                    }\n                    processedResponses.push(baseResponse);\n                });\n                return processedResponses;\n            }\n            const handleRequest = new Promise((resolve) => {\n                // web3 v1.x concat batched JSON-RPC requests to an array, handle it here\n                if (Array.isArray(payload)) {\n                    const { sendRequests, otherRequests } = separateRequests(payload);\n                    // collect transactions and send batch with custom method\n                    const batchReqPayload = {\n                        method: 'wallet_sendMultiCallTransaction',\n                        params: [sendRequests, false],\n                    };\n                    const isSendRequestsEmpty = sendRequests.length === 0;\n                    const idBase = Math.floor(Math.random() * 10000);\n                    const allPromise = isSendRequestsEmpty\n                        ? [...otherRequests]\n                        : [this.request(batchReqPayload), ...otherRequests];\n                    // resolve response when all request are executed\n                    Promise.allSettled(allPromise)\n                        .then((responses) => {\n                        if (isSendRequestsEmpty) {\n                            return resolve(responses.map((response, index) => {\n                                var _a;\n                                return {\n                                    id: String(((_a = payload[index]) === null || _a === void 0 ? void 0 : _a.id) || idBase + index + 1),\n                                    jsonrpc: '2.0',\n                                    method: payload[index].method,\n                                    result: response.status === 'fulfilled'\n                                        ? response.value\n                                        : undefined,\n                                    error: response.status !== 'fulfilled'\n                                        ? response.reason\n                                        : undefined,\n                                };\n                            }));\n                        }\n                        const originalLengthResponse = processResponses(payload, responses);\n                        return resolve(originalLengthResponse);\n                    })\n                        .catch((error) => {\n                        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n                    });\n                }\n                else {\n                    this.request(Object.assign(Object.assign({}, payload), { id: Number(payload.id) })).then(resolve);\n                }\n            });\n            // execute callback or return promise, depdends on callback arg given or not\n            if (typeof callback === 'function') {\n                handleRequest\n                    .then((data) => {\n                    return callback(null, data);\n                })\n                    .catch((error) => callback(error));\n            }\n            else {\n                return handleRequest;\n            }\n        });\n    }\n    /**\n     * Sending userOperation using Blocto SDK.\n     * @param {IUserOperation} userOp - userOperation object\n     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.\n     * These parameters will be ignored.\n     * @returns {Promise<string>} - userOperation hash\n     */\n    sendUserOperation(userOp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request({\n                method: 'eth_sendUserOperation',\n                params: [userOp],\n            });\n        });\n    }\n    request(payload) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            // web3.js v4 batch entry point\n            if (Array.isArray(payload)) {\n                return this.sendAsync(payload);\n            }\n            if (!(payload === null || payload === void 0 ? void 0 : payload.method))\n                throw dist.ethErrors.rpc.invalidRequest();\n            const { blockchainName, switchableNetwork, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) {\n                if (payload.method === 'wallet_switchEthereumChain') {\n                    if (!((_c = (_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams();\n                    }\n                    return this.existedSDK.request(payload).then(() => {\n                        var _a, _b, _c;\n                        this.networkVersion = `${parseChainId((_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0].chainId)}`;\n                        this.chainId = `0x${parseChainId((_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0].chainId).toString(16)}`;\n                        this.rpc = (_c = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c === void 0 ? void 0 : _c.rpc_url;\n                        return null;\n                    });\n                }\n                return this.existedSDK.request(payload);\n            }\n            // method that doesn't require user to be connected\n            switch (payload.method) {\n                case 'eth_chainId': {\n                    return this.chainId;\n                }\n                case 'net_version': {\n                    return this.networkVersion;\n                }\n                case 'wallet_addEthereumChain': {\n                    return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);\n                }\n                case 'eth_blockNumber':\n                case 'web3_clientVersion':\n                case 'eth_call': {\n                    const response = yield this.handleReadRequests(payload);\n                    if (!response || (response && !response.result && response.error)) {\n                        const errorMessage = ((_d = response === null || response === void 0 ? void 0 : response.error) === null || _d === void 0 ? void 0 : _d.message)\n                            ? response.error.message\n                            : 'Request failed';\n                        throw dist.ethErrors.rpc.internal(errorMessage);\n                    }\n                    if (typeof (payload === null || payload === void 0 ? void 0 : payload.callback) === 'function') {\n                        payload.callback(null, response.result);\n                    }\n                    return response.result;\n                }\n                case 'wallet_switchEthereumChain': {\n                    return this.handleSwitchChain((_f = (_e = payload === null || payload === void 0 ? void 0 : payload.params) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.chainId);\n                }\n                case 'wallet_disconnect': {\n                    return this.handleDisconnect();\n                }\n                case 'eth_accounts': {\n                    return getEvmAddress(sessionKeyEnv, blockchainName) || [];\n                }\n            }\n            // Method that requires user to be connected\n            if (!getEvmAddress(sessionKeyEnv, blockchainName)) {\n                const email = (_g = payload === null || payload === void 0 ? void 0 : payload.params) === null || _g === void 0 ? void 0 : _g[0];\n                if (payload.method === 'eth_requestAccounts' && isEmail(email)) {\n                    yield this.enable(email);\n                }\n                else {\n                    yield this.enable();\n                }\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch (payload.method) {\n                    case 'eth_requestAccounts': {\n                        result = yield this.fetchAccounts();\n                        break;\n                    }\n                    // eslint-disable-next-line\n                    case 'eth_coinbase': {\n                        result = (_h = getEvmAddress(sessionKeyEnv, blockchainName)) === null || _h === void 0 ? void 0 : _h[0];\n                        break;\n                    }\n                    case 'eth_signTypedData_v3':\n                    case 'eth_signTypedData':\n                    case 'eth_signTypedData_v4':\n                    case 'personal_sign': {\n                        result = yield this.handleSign(payload);\n                        break;\n                    }\n                    case 'eth_sign':\n                        throw dist.ethErrors.rpc.methodNotFound('Method Not Supported: eth_sign has been disabled');\n                    case 'eth_sendTransaction':\n                        result = yield this.handleSendTransaction(payload);\n                        break;\n                    case 'wallet_sendMultiCallTransaction':\n                        result = yield this.handleSendBatchTransaction(payload);\n                        break;\n                    case 'eth_signTransaction':\n                    case 'eth_sendRawTransaction': {\n                        throw dist.ethErrors.rpc.methodNotSupported('Method Not Supported: ' + payload.method);\n                    }\n                    case 'eth_sendUserOperation':\n                        result = yield this.handleSendUserOperation(payload);\n                        break;\n                    case 'eth_estimateUserOperationGas':\n                    case 'eth_getUserOperationByHash':\n                    case 'eth_getUserOperationReceipt':\n                    case 'eth_supportedEntryPoints':\n                        result = yield this.handleBundler(payload);\n                        break;\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message\n                        ? response.error.message\n                        : 'Request failed';\n                    throw dist.ethErrors.rpc.internal(errorMessage);\n                }\n                if (response)\n                    return response.result;\n                return result;\n            }\n            catch (error) {\n                throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n            }\n        });\n    }\n    bloctoApi(url, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { walletServer, blockchainName, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const sessionId = ((_a = getAccountStorage(sessionKeyEnv)) === null || _a === void 0 ? void 0 : _a.code) || '';\n            if (!sessionId) {\n                throw dist.ethErrors.provider.unauthorized();\n            }\n            return fetch(`${walletServer}/api/${blockchainName}${url}`, Object.assign({ headers: {\n                    'Content-Type': 'application/json',\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Session-Identifier': sessionId,\n                } }, options))\n                .then((response) => responseSessionGuard(response, sessionKeyEnv, () => {\n                var _a;\n                (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));\n            }))\n                .catch((e) => {\n                if ((e === null || e === void 0 ? void 0 : e.error_code) === 'unsupported_method') {\n                    throw dist.ethErrors.rpc.methodNotSupported('Method Not Supported: ' + e.message);\n                }\n                else {\n                    throw dist.ethErrors.rpc.server({\n                        code: -32005,\n                        message: `Blocto server error: ${e.message}`,\n                    });\n                }\n            });\n        });\n    }\n    responseListener(frame, objectKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            return new Promise((resolve, reject) => addSelfRemovableHandler('message', (event, removeEventListener) => {\n                const e = event;\n                if (e.origin === walletServer &&\n                    e.data.type === 'ETH:FRAME:RESPONSE') {\n                    if (e.data.status === 'APPROVED') {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        resolve(e.data[objectKey]);\n                    }\n                    if (e.data.status === 'DECLINED') {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        if (e.data.errorCode === 'incorrect_session_id') {\n                            this.handleDisconnect();\n                        }\n                        reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));\n                    }\n                }\n                if (e.data.type === 'ETH:FRAME:CLOSE') {\n                    removeEventListener();\n                    detatchFrame(frame);\n                    reject(dist.ethErrors.provider.userRejectedRequest('User declined the request'));\n                }\n            }));\n        });\n    }\n    setIframe(url, blockchain) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof window === 'undefined') {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: 'Blocto SDK only works in browser environment',\n                });\n            }\n            const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const frame = createFrame(`${walletServer}/${this.appId}/${blockchain || blockchainName}${url}`);\n            attachFrame(frame);\n            return frame;\n        });\n    }\n    // eip-1102 alias\n    // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    enable(email) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof window === 'undefined') {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: 'Blocto SDK only works in browser environment',\n                });\n            }\n            const { walletServer, blockchainName, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) {\n                if (this.existedSDK.chainId !== this.chainId) {\n                    yield this.existedSDK.request({\n                        method: 'wallet_addEthereumChain',\n                        params: [{ chainId: this.chainId }],\n                    });\n                    yield this.existedSDK.request({\n                        method: 'wallet_switchEthereumChain',\n                        params: [{ chainId: this.chainId }],\n                    });\n                    setEvmAddress(sessionKeyEnv, blockchainName, [this.existedSDK.address]);\n                }\n                return new Promise((resolve, reject) => \n                // add a small delay to make sure the network has been switched\n                setTimeout(() => this.existedSDK.enable().then(resolve).catch(reject), 10));\n            }\n            const address = getEvmAddress(sessionKeyEnv, blockchainName);\n            if (address) {\n                return new Promise((resolve) => {\n                    resolve(address);\n                });\n            }\n            const params = new URLSearchParams();\n            params.set('l6n', window.location.origin);\n            params.set('v', SDK_VERSION);\n            params.set('q', `${window.location.pathname}${window.location.search}`);\n            const emailParam = email && isEmail(email) ? `/${email}` : '';\n            const loginFrame = yield this.setIframe(`/authn${emailParam}?${params.toString()}`);\n            return new Promise((resolve, reject) => {\n                addSelfRemovableHandler('message', (event, removeListener) => {\n                    var _a, _b;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === 'ETH:FRAME:RESPONSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener) => listener({ chainId: this.chainId }));\n                            setAccountStorage(sessionKeyEnv, {\n                                code: e.data.code,\n                                evm: {\n                                    [blockchainName]: [e.data.addr],\n                                },\n                            }, e.data.exp);\n                            if ((_b = e.data) === null || _b === void 0 ? void 0 : _b.isAccountChanged) {\n                                postMessage({\n                                    originChain: CHAIN.ETHEREUM,\n                                    type: 'BLOCTO_SDK:ACCOUNT_CHANGED',\n                                });\n                            }\n                            addSelfRemovableHandler('message', (event, removeListener) => {\n                                var _a, _b, _c;\n                                const messageEvent = event;\n                                const isAccountChanged = ((_a = messageEvent.data) === null || _a === void 0 ? void 0 : _a.type) === 'BLOCTO_SDK:ACCOUNT_CHANGED';\n                                const isAnotherChain = ((_b = messageEvent.data) === null || _b === void 0 ? void 0 : _b.originChain) !== CHAIN.ETHEREUM;\n                                if (isAccountChanged) {\n                                    (_c = this.eventListeners) === null || _c === void 0 ? void 0 : _c.accountsChanged.forEach((listener) => listener([e.data.addr]));\n                                }\n                                if (isAccountChanged && isAnotherChain) {\n                                    this.handleDisconnect();\n                                    removeListener();\n                                }\n                            });\n                            resolve([e.data.addr]);\n                        }\n                        if (e.data.type === 'ETH:FRAME:CLOSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(dist.ethErrors.provider.userRejectedRequest());\n                        }\n                    }\n                });\n            });\n        });\n    }\n    fetchAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { blockchainName, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const { accounts } = yield this.bloctoApi(`/accounts`);\n            setEvmAddress(sessionKeyEnv, blockchainName, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return fetch(this.rpc, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(Object.assign({ id: 1, jsonrpc: '2.0' }, payload)),\n            })\n                .then((response) => response.json())\n                .catch((e) => {\n                throw dist.ethErrors.rpc.internal(e);\n            });\n        });\n    }\n    handleSign({ method, params }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let message = '';\n            if (Array.isArray(params)) {\n                if (method === 'personal_sign') {\n                    message = isHexString(params[0])\n                        ? params[0].slice(2)\n                        : utf8ToHex(params[0]);\n                }\n                else if ([\n                    'eth_signTypedData',\n                    'eth_signTypedData_v3',\n                    'eth_signTypedData_v4',\n                ].includes(method)) {\n                    message = params[1];\n                    const { domain } = JSON.parse(message);\n                    if (isHexString(domain.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must be a number`);\n                    }\n                    if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must match the active chainId \"${parseChainId(this.chainId)}\"`);\n                    }\n                }\n            }\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { signatureId } = yield this.bloctoApi(`/user-signature`, { method: 'POST', body: JSON.stringify({ method, message }) });\n            const signFrame = yield this.setIframe(`/user-signature/${signatureId}`);\n            return this.responseListener(signFrame, 'signature');\n        });\n    }\n    handleSwitchChain(targetChainId) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!targetChainId) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            const { walletServer, blockchainName, sessionKeyEnv, switchableNetwork } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const oldAccount = (_a = getEvmAddress(sessionKeyEnv, blockchainName)) === null || _a === void 0 ? void 0 : _a[0];\n            const oldChainId = parseChainId(this.chainId);\n            const newChainId = parseChainId(targetChainId);\n            if (oldChainId === newChainId) {\n                return null;\n            }\n            if (!switchableNetwork[newChainId]) {\n                throw dist.ethErrors.provider.custom({\n                    code: 4902,\n                    message: `Unrecognized chain ID \"${newChainId}\". Try adding the chain using wallet_addEthereumChain first.`,\n                });\n            }\n            this.networkVersion = `${newChainId}`;\n            this.chainId = `0x${newChainId.toString(16)}`;\n            this.rpc = switchableNetwork[newChainId].rpc_url;\n            this._blocto = Object.assign(Object.assign({}, this._blocto), { blockchainName: '', networkType: '' });\n            if (!oldAccount) {\n                (_b = this.eventListeners) === null || _b === void 0 ? void 0 : _b.chainChanged.forEach((listener) => listener(this.chainId));\n                yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                return null;\n            }\n            // Go login flow when switching to a different blocto server\n            if (switchableNetwork[newChainId].wallet_web_url !==\n                switchableNetwork[oldChainId].wallet_web_url) {\n                return this.enable()\n                    .then(([newAccount]) => {\n                    var _a;\n                    if (newAccount !== oldAccount) {\n                        (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.accountsChanged.forEach((listener) => listener([newAccount]));\n                    }\n                    this.eventListeners.chainChanged.forEach((listener) => listener(this.chainId));\n                    return null;\n                })\n                    .catch((error) => {\n                    this.networkVersion = `${oldChainId}`;\n                    this.chainId = `0x${oldChainId.toString(16)}`;\n                    this.rpc = switchableNetwork[oldChainId].rpc_url;\n                    this._blocto = Object.assign(Object.assign({}, this._blocto), { blockchainName: '', networkType: '' });\n                    __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                    throw error;\n                });\n            }\n            const switchChainFrame = yield this.setIframe(`/switch-chain?to=${switchableNetwork[newChainId].name}`, switchableNetwork[oldChainId].name);\n            return new Promise((resolve, reject) => {\n                addSelfRemovableHandler('message', (event, removeListener) => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === 'ETH:FRAME:RESPONSE') {\n                            removeListener();\n                            detatchFrame(switchChainFrame);\n                            if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.addr) && oldAccount) {\n                                setAccountStorage(sessionKeyEnv, {\n                                    code: (_b = e.data) === null || _b === void 0 ? void 0 : _b.code,\n                                    evm: {\n                                        [switchableNetwork[newChainId].name]: [e.data.addr],\n                                    },\n                                }, (_c = e.data) === null || _c === void 0 ? void 0 : _c.exp);\n                                if (e.data.addr !== oldAccount) {\n                                    (_d = this.eventListeners) === null || _d === void 0 ? void 0 : _d.accountsChanged.forEach((listener) => listener([e.data.addr]));\n                                }\n                            }\n                            (_e = this.eventListeners) === null || _e === void 0 ? void 0 : _e.chainChanged.forEach((listener) => listener(this.chainId));\n                            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                            resolve(null);\n                        }\n                        if (e.data.type === 'ETH:FRAME:CLOSE') {\n                            removeListener();\n                            detatchFrame(switchChainFrame);\n                            if ((_f = e.data) === null || _f === void 0 ? void 0 : _f.hasApprovedSwitchChain) {\n                                (_g = this.eventListeners) === null || _g === void 0 ? void 0 : _g.chainChanged.forEach((listener) => listener(this.chainId));\n                                removeAllEvmAddress(sessionKeyEnv);\n                                (_h = this.eventListeners) === null || _h === void 0 ? void 0 : _h.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));\n                                __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                                resolve(null);\n                            }\n                            else {\n                                this.networkVersion = `${oldChainId}`;\n                                this.chainId = `0x${oldChainId.toString(16)}`;\n                                this.rpc = switchableNetwork[oldChainId].rpc_url;\n                                this._blocto = Object.assign(Object.assign({}, this._blocto), { blockchainName: '', networkType: '' });\n                                __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                                reject(dist.ethErrors.provider.userRejectedRequest());\n                            }\n                        }\n                    }\n                });\n            });\n        });\n    }\n    handleSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { isValid, invalidMsg } = isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0]);\n            if (!isValid) {\n                throw dist.ethErrors.rpc.invalidParams(invalidMsg);\n            }\n            return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_createAuthzFrame).call(this, payload.params);\n        });\n    }\n    handleSendBatchTransaction(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            let originalParams, revertFlag;\n            if (Array.isArray(payload.params) && payload.params.length >= 2) {\n                [originalParams, revertFlag] = payload.params;\n            }\n            else {\n                originalParams = payload.params;\n                revertFlag = false;\n            }\n            const revert = revertFlag ? revertFlag : false;\n            const { isValid, invalidMsg } = isValidTransactions(originalParams);\n            if (!isValid) {\n                throw dist.ethErrors.rpc.invalidParams(invalidMsg);\n            }\n            return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_createAuthzFrame).call(this, originalParams, revert);\n        });\n    }\n    handleSendUserOperation(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { authorizationId } = yield this.bloctoApi(`/user-operation`, {\n                method: 'POST',\n                body: JSON.stringify(payload.params),\n            });\n            const userOPFrame = yield this.setIframe(`/user-operation/${authorizationId}`);\n            return this.responseListener(userOPFrame, 'userOpHash');\n        });\n    }\n    handleBundler(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return this.bloctoApi(`/rpc/bundler`, {\n                method: 'POST',\n                body: JSON.stringify(Object.assign({ id: 1, jsonrpc: '2.0' }, payload)),\n            });\n        });\n    }\n    handleDisconnect() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) {\n                return this.existedSDK.request({ method: 'wallet_disconnect' });\n            }\n            const { sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            removeAllEvmAddress(sessionKeyEnv);\n            (_b = this.eventListeners) === null || _b === void 0 ? void 0 : _b.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));\n        });\n    }\n    loadSwitchableNetwork(networkList) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // setup switchable list if user set networkList\n            if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {\n                const listToAdd = networkList.map(({ chainId, rpcUrls }) => {\n                    if (!chainId)\n                        throw dist.ethErrors.rpc.invalidParams('Empty chainId');\n                    const parsedChainId = `${parseChainId(chainId)}`;\n                    // skip if chainId already exists\n                    if (this._blocto.switchableNetwork[parsedChainId])\n                        return null;\n                    const parsedRpc = (rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls[0]) || ETH_RPC_LIST[parsedChainId];\n                    if (!parsedRpc)\n                        throw dist.ethErrors.rpc.invalidParams('rpcUrls required');\n                    return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_addToSwitchable).call(this, {\n                        chainId: parsedChainId,\n                        rpcUrls: [parsedRpc],\n                    });\n                });\n                return Promise.all(listToAdd).then(() => null);\n            }\n            else {\n                throw dist.ethErrors.rpc.invalidParams('Empty networkList');\n            }\n        });\n    }\n    supportChainList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const supportNetworkList = yield getEvmSupport().catch((e) => {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Get blocto server failed: ${e.message}`,\n                });\n            });\n            return Object.keys(supportNetworkList).map((chainId) => {\n                const { display_name } = supportNetworkList[chainId];\n                return {\n                    chainId,\n                    chainName: display_name,\n                };\n            });\n        });\n    }\n    on(event, listener) {\n        var _a;\n        if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto)\n            this.existedSDK.on(event, listener);\n        super.on(event, listener);\n    }\n    removeListener(event, listener) {\n        var _a;\n        if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto)\n            this.existedSDK.off(event, listener);\n        super.removeListener(event, listener);\n    }\n}\n_EthereumProvider_instances = new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((_a = this._blocto) === null || _a === void 0 ? void 0 : _a.unloadedNetwork) {\n            yield this.loadSwitchableNetwork(this._blocto.unloadedNetwork);\n            delete this._blocto.unloadedNetwork;\n        }\n        if (this._blocto.sessionKeyEnv &&\n            this._blocto.walletServer &&\n            this._blocto.blockchainName &&\n            this._blocto.networkType &&\n            this._blocto.switchableNetwork) {\n            return this._blocto;\n        }\n        const supportNetworkList = yield getEvmSupport().catch((e) => {\n            throw dist.ethErrors.provider.custom({\n                code: 1001,\n                message: `Get blocto server failed: ${e.message}`,\n            });\n        });\n        const { chain_id, name, network_type, blocto_service_environment, display_name, } = (_b = supportNetworkList[this.networkVersion]) !== null && _b !== void 0 ? _b : {};\n        if (!chain_id) {\n            throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${this.networkVersion} might not be supported yet.`);\n        }\n        const walletServer = this.injectedWalletServer ||\n            ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto = Object.assign(Object.assign({}, this._blocto), { sessionKeyEnv: ETH_SESSION_KEY_MAPPING[blocto_service_environment], walletServer, blockchainName: name, networkType: network_type, switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), { [chain_id]: {\n                    name,\n                    display_name,\n                    network_type,\n                    wallet_web_url: walletServer,\n                    rpc_url: this.rpc,\n                } }) });\n        return this._blocto;\n    });\n}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable({ chainId, rpcUrls, }) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n        const supportNetworkList = yield getEvmSupport().catch((e) => {\n            throw dist.ethErrors.provider.custom({\n                code: 1001,\n                message: `Get blocto server failed: ${e.message}`,\n            });\n        });\n        const { chain_id, name, display_name, network_type, blocto_service_environment, } = (_a = supportNetworkList[chainId]) !== null && _a !== void 0 ? _a : {};\n        if (!chain_id)\n            throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${chainId} might not be supported yet.`);\n        const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto.switchableNetwork[chain_id] = {\n            name,\n            display_name,\n            network_type,\n            wallet_web_url,\n            rpc_url: rpcUrls[0],\n        };\n    });\n}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched() {\n    var _a;\n    if (((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) &&\n        parseChainId(this.existedSDK.chainId) !== parseChainId(this.chainId)) {\n        throw dist.ethErrors.provider.chainDisconnected();\n    }\n}, _EthereumProvider_createAuthzFrame = function _EthereumProvider_createAuthzFrame(params, revert = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { authorizationId } = yield this.bloctoApi(`/authz`, {\n            method: 'POST',\n            body: JSON.stringify([params, revert]),\n        });\n        const iframeParams = new URLSearchParams();\n        iframeParams.set('l6n', window.location.origin);\n        iframeParams.set('q', `${window.location.pathname}${window.location.search}`);\n        const authzFrame = yield this.setIframe(`/authz/${authorizationId}?${iframeParams.toString()}`);\n        return this.responseListener(authzFrame, 'txHash');\n    });\n};\n\nconst checkMessagePayloadFormat = (payload) => {\n    var _a, _b;\n    const formattedPayload = Object.assign({}, payload);\n    const { message, nonce, address, application, chainId } = payload;\n    if (typeof message !== 'string') {\n        formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : '';\n    }\n    if (typeof nonce !== 'string') {\n        formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : '';\n    }\n    if (address && typeof address !== 'boolean') {\n        formattedPayload.address = !!address;\n    }\n    if (application && typeof application !== 'boolean') {\n        formattedPayload.application = !!application;\n    }\n    if (chainId && typeof chainId !== 'boolean') {\n        formattedPayload.chainId = !!chainId;\n    }\n    return formattedPayload;\n};\nclass AptosProvider extends BloctoProvider {\n    get existedSDK() {\n        if (typeof window === 'undefined')\n            return undefined;\n        return window.bloctoAptos;\n    }\n    constructor({ chainId, server, appId }) {\n        super();\n        this.publicKey = [];\n        this.authKey = '';\n        this.off = this.removeListener;\n        invariant(chainId, \"'chainId' is required\");\n        invariant(appId, 'It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.');\n        this.chainId = chainId;\n        this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];\n        this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];\n        this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];\n        const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];\n        this.appId = appId || DEFAULT_APP_ID;\n        this.server = server || defaultServer || '';\n    }\n    get publicAccount() {\n        var _a;\n        return {\n            address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,\n            publicKey: this.publicKey.length ? this.publicKey : null,\n            // @todo: provide authkey\n            authKey: null,\n            minKeysRequired: 2,\n        };\n    }\n    network() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                name: this.networkName,\n                api: this.api,\n                chainId: this.chainId.toString(),\n            };\n        });\n    }\n    isConnected() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            return !!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length);\n        });\n    }\n    signTransaction(transaction) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                return this.existedSDK.signTransaction(transaction);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error('Fail to get account');\n            }\n            throw new Error('signTransaction method not supported.');\n        });\n    }\n    disconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                yield this.existedSDK.disconnect();\n                return;\n            }\n            removeChainAddress(this.sessionKey, CHAIN.APTOS);\n            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener) => listener({\n                code: 4900,\n                message: 'Wallet disconnected',\n            }));\n        });\n    }\n    signAndSubmitTransaction(transaction, txOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                return this.existedSDK.signAndSubmitTransaction(transaction, txOptions);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error('Fail to get account');\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || '';\n            const { authorizationId } = yield fetch(`${this.server}/api/aptos/authz`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    'Blocto-Session-Identifier': sessionId,\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions)),\n            }).then((response) => responseSessionGuard(response, this.sessionKey));\n            if (typeof window === 'undefined') {\n                throw new Error('Currently only supported in browser');\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/aptos/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject) => addSelfRemovableHandler('message', (event, removeEventListener) => {\n                const e = event;\n                if (e.origin === this.server &&\n                    e.data.type === 'APTOS:FRAME:RESPONSE') {\n                    if (e.data.status === 'APPROVED') {\n                        removeEventListener();\n                        detatchFrame(authzFrame);\n                        resolve({ hash: e.data.txHash });\n                    }\n                    if (e.data.status === 'DECLINED') {\n                        removeEventListener();\n                        detatchFrame(authzFrame);\n                        if (e.data.errorCode === 'incorrect_session_id') {\n                            this.disconnect();\n                        }\n                        reject(new Error(e.data.errorMessage));\n                    }\n                }\n            }));\n        });\n    }\n    signMessage(payload) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const formattedPayload = checkMessagePayloadFormat(payload);\n            if (this.existedSDK) {\n                return this.existedSDK.signMessage(formattedPayload);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error('Fail to get account');\n            }\n            if (typeof window === 'undefined') {\n                throw new Error('Currently only supported in browser');\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || '';\n            const { signatureId } = yield fetch(`${this.server}/api/aptos/user-signature`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    'Blocto-Session-Identifier': sessionId,\n                },\n                body: JSON.stringify(formattedPayload),\n            }).then((response) => responseSessionGuard(response, this.sessionKey));\n            const url = `${this.server}/${this.appId}/aptos/user-signature/${signatureId}`;\n            const signFrame = createFrame(url);\n            attachFrame(signFrame);\n            return new Promise((resolve, reject) => addSelfRemovableHandler('message', (event, removeEventListener) => {\n                const e = event;\n                if (e.origin === this.server &&\n                    e.data.type === 'APTOS:FRAME:RESPONSE') {\n                    if (e.data.status === 'APPROVED') {\n                        removeEventListener();\n                        detatchFrame(signFrame);\n                        resolve(e.data);\n                    }\n                    if (e.data.status === 'DECLINED') {\n                        removeEventListener();\n                        detatchFrame(signFrame);\n                        if (e.data.errorCode === 'incorrect_session_id') {\n                            this.disconnect();\n                        }\n                        reject(new Error(e.data.errorMessage));\n                    }\n                }\n            }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                return new Promise((resolve, reject) => \n                // add a small delay to make sure the network has been switched\n                setTimeout(() => this.existedSDK.connect().then(resolve).catch(reject), 10));\n            }\n            return new Promise((resolve, reject) => {\n                var _a, _b;\n                if (typeof window === 'undefined') {\n                    return reject('Currently only supported in browser');\n                }\n                if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {\n                    return resolve({\n                        address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,\n                        publicKey: this.publicKey,\n                        authKey: null,\n                        minKeysRequired: 2,\n                    });\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/aptos/authn?l6n=${location}&v=${SDK_VERSION}}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler('message', (event, removeListener) => __awaiter(this, void 0, void 0, function* () {\n                    var _c, _d, _e, _f;\n                    const e = event;\n                    if (e.origin === this.server) {\n                        if (e.data.type === 'APTOS:FRAME:RESPONSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            setAccountStorage(this.sessionKey, {\n                                code: e.data.code,\n                                accounts: {\n                                    [CHAIN.APTOS]: [e.data.addr],\n                                },\n                            }, e.data.exp);\n                            if ((_c = e.data) === null || _c === void 0 ? void 0 : _c.isAccountChanged) {\n                                postMessage({\n                                    originChain: CHAIN.APTOS,\n                                    type: 'BLOCTO_SDK:ACCOUNT_CHANGED',\n                                });\n                            }\n                            addSelfRemovableHandler('message', (event, removeListener) => {\n                                var _a, _b;\n                                const messageEvent = event;\n                                if (((_a = messageEvent.data) === null || _a === void 0 ? void 0 : _a.type) === 'BLOCTO_SDK:ACCOUNT_CHANGED' &&\n                                    ((_b = messageEvent.data) === null || _b === void 0 ? void 0 : _b.originChain) !== CHAIN.APTOS) {\n                                    this.disconnect();\n                                    removeListener();\n                                }\n                            });\n                            if ((_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d.length) {\n                                try {\n                                    const { public_keys: publicKeys } = yield fetch(`${this.server}/blocto/aptos/accounts/${(_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]}`).then((response) => response.json());\n                                    this.publicKey = publicKeys || [];\n                                    resolve({\n                                        address: ((_f = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _f === void 0 ? void 0 : _f[0]) || '',\n                                        publicKey: this.publicKey,\n                                        authKey: null,\n                                        minKeysRequired: 2,\n                                    });\n                                }\n                                catch (err) {\n                                    return reject(e);\n                                }\n                            }\n                            else {\n                                // @todo: better error\n                                return reject();\n                            }\n                        }\n                        if (e.data.type === 'APTOS:FRAME:CLOSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(new Error('User declined the login request'));\n                        }\n                    }\n                }));\n            });\n        });\n    }\n    fetchAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || '';\n            const { accounts } = yield fetch(`${this.server}/api/aptos/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    'Blocto-Session-Identifier': sessionId,\n                },\n            }).then((response) => responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);\n            return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || '';\n        });\n    }\n    on(event, listener) {\n        if (this.existedSDK)\n            this.existedSDK.on(event, listener);\n        super.on(event, listener);\n    }\n    removeListener(event, listener) {\n        if (this.existedSDK)\n            this.existedSDK.off(event, listener);\n        super.removeListener(event, listener);\n    }\n}\n\nclass BloctoSDK {\n    constructor({ appId, ethereum, aptos }) {\n        if (ethereum) {\n            this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), { appId }));\n        }\n        if (aptos) {\n            this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), { appId }));\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJsb2N0by9zZGsvZGlzdC9ibG9jdG8tc2RrLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZLGtFQUFrRTtBQUN0RixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsaUJBQWlCLFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0EsK0VBQStFLGVBQWUsT0FBTztBQUNyRztBQUNBO0FBQ0EseUVBQXlFLFlBQVksT0FBTztBQUM1RjtBQUNBO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmxvY3RvL3Nkay9kaXN0L2Jsb2N0by1zZGsubW9kdWxlLmpzPzI0NzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVmVyc2lvbjogMC4xMC4yIC0gTWF5IDMsIDIwMjQgMDQ6MzI6MjkgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLy8gaW5zdGVhZCBpbnZhcmlhbnQgZnJvbSBwYWNrYWdlLCBzaW5jZSBhbGwgZXJyb3Igd2lsbCB0aHJvdyBvbiBwcm9kdWN0aW9uXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KTtcbiAgICB9XG59XG5cbnZhciBLRVlfU0VTU0lPTjtcbihmdW5jdGlvbiAoS0VZX1NFU1NJT04pIHtcbiAgICBLRVlfU0VTU0lPTltcInByb2RcIl0gPSBcIkJMT0NUT19TREtcIjtcbiAgICBLRVlfU0VTU0lPTltcImRldlwiXSA9IFwiQkxPQ1RPX1NES19ERVZcIjtcbiAgICBLRVlfU0VTU0lPTltcInN0YWdpbmdcIl0gPSBcIkJMT0NUT19TREtfU1RBR0lOR1wiO1xufSkoS0VZX1NFU1NJT04gfHwgKEtFWV9TRVNTSU9OID0ge30pKTtcbnZhciBDSEFJTjtcbihmdW5jdGlvbiAoQ0hBSU4pIHtcbiAgICBDSEFJTltcIkVUSEVSRVVNXCJdID0gXCJldGhlcmV1bVwiO1xuICAgIENIQUlOW1wiQVBUT1NcIl0gPSBcImFwdG9zXCI7XG59KShDSEFJTiB8fCAoQ0hBSU4gPSB7fSkpO1xuLyogZXRoIHNlcmllcyBjb25zdGFudHMgYmVnaW4gKi9cbmNvbnN0IEVUSF9SUENfTElTVCA9IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBsaXN0IG9mIHB1YmxpYyBSUEMgZW5kcG9pbnRzIHRoYXQgd2Uga25vd24gdG8gYmUgd29ya2luZ1xuICAgIC8vIFVzZWQgdG8gaGVscCBkZXZlbG9wZXJzIGRpZCBub3Qgc2V0IHVwIHRoZWlyIG93biBSUEMgZW5kcG9pbnRzXG4gICAgLy8gQlNDIG1haW5uZXRcbiAgICA1NjogJ2h0dHBzOi8vYnNjLWRhdGFzZWVkMS5iaW5hbmNlLm9yZycsXG4gICAgLy8gQlNDIHRlc3RuZXRcbiAgICA5NzogJ2h0dHBzOi8vZGF0YS1zZWVkLXByZWJzYy0xLXMxLmJpbmFuY2Uub3JnOjg1NDUnLFxuICAgIC8vIFBvbHlnb24gTWFpbm5ldFxuICAgIDEzNzogJ2h0dHBzOi8vcnBjLW1haW5uZXQubWF0aWN2aWdpbC5jb20vJyxcbiAgICAvLyBQb2x5Z29uIEFtb3kgVGVzdG5ldFxuICAgIDgwMDAyOiAnaHR0cHM6Ly9ycGMtYW1veS5wb2x5Z29uLnRlY2hub2xvZ3kvJyxcbiAgICAvLyBBdmFsYW5jaGUgTWFpbm5ldFxuICAgIDQzMTE0OiAnaHR0cHM6Ly9hcGkuYXZheC5uZXR3b3JrL2V4dC9iYy9DL3JwYycsXG4gICAgLy8gQXZhbGFuY2hlIEZ1amkgVGVzdG5ldFxuICAgIDQzMTEzOiAnaHR0cHM6Ly9hcGkuYXZheC10ZXN0Lm5ldHdvcmsvZXh0L2JjL0MvcnBjJyxcbiAgICAvLyBBcmJpdHJ1bSBNYWlubmV0XG4gICAgNDIxNjE6ICdodHRwczovL2FyYjEuYXJiaXRydW0uaW8vcnBjJyxcbiAgICAvLyBBcmJpdHJ1bSBTZXBvbGlhIFRlc3RuZXRcbiAgICA0MjE2MTQ6ICdodHRwczovL2FyYml0cnVtLXNlcG9saWEuYmxvY2twaS5uZXR3b3JrL3YxL3JwYy9wdWJsaWMnLFxuICAgIC8vIE9wdGltaXNtIE1haW5uZXRcbiAgICAxMDogJ2h0dHBzOi8vbWFpbm5ldC5vcHRpbWlzbS5pbycsXG4gICAgLy8gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0XG4gICAgMTExNTU0MjA6ICdodHRwczovL3NlcG9saWEub3B0aW1pc20uaW8nLFxuICAgIC8vIEJhc2UgTWFpbm5ldFxuICAgIDg0NTM6ICdodHRwczovL21haW5uZXQuYmFzZS5vcmcnLFxuICAgIC8vIEJhc2UgU2Vwb2xpYSBUZXN0bmV0XG4gICAgODQ1MzI6ICdodHRwczovL3NlcG9saWEuYmFzZS5vcmcnLFxuICAgIC8vIFpvcmFcbiAgICA3Nzc3Nzc3OiAnaHR0cHM6Ly9ycGMuem9yYS5lbmVyZ3knLFxuICAgIC8vIFpvcmEgU2Vwb2xpYSBUZXN0bmV0XG4gICAgOTk5OTk5OTk5OiAnaHR0cHM6Ly9zZXBvbGlhLnJwYy56b3JhLmVuZXJneScsXG4gICAgLy8gU2Nyb2xsXG4gICAgNTM0MzUyOiAnaHR0cHM6Ly9ycGMuc2Nyb2xsLmlvJyxcbiAgICAvLyBTY3JvbGwgU2Vwb2xpYSBUZXN0bmV0XG4gICAgNTM0MzUxOiAnaHR0cHM6Ly9zZXBvbGlhLXJwYy5zY3JvbGwuaW8nLFxuICAgIC8vIExpbmVhXG4gICAgNTkxNDQ6ICdodHRwczovL3JwYy5saW5lYS5idWlsZCcsXG4gICAgLy8gekthdGFuYSBTZXBvbGlhIFRlc3RuZXRcbiAgICAxMjYxMTIwOiAnaHR0cHM6Ly9ycGMuc3RhcnRhbGUuY29tL3prYXRhbmEnLFxuICAgIC8vIEJsYXN0XG4gICAgODE0NTc6ICdodHRwczovL3JwYy5ibGFzdC5pbycsXG4gICAgLy8gQmxhc3QgU2Vwb2xpYSBUZXN0bmV0XG4gICAgMTY4NTg3NzczOiAnaHR0cHM6Ly9zZXBvbGlhLmJsYXN0LmlvJ1xufTtcbmNvbnN0IEVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIHByb2Q6ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBzdGFnaW5nOiAnaHR0cHM6Ly93YWxsZXQtdjItc3RhZ2luZy5ibG9jdG8uYXBwJyxcbiAgICBkZXY6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG59O1xuY29uc3QgRVRIX1NFU1NJT05fS0VZX01BUFBJTkcgPSB7XG4gICAgcHJvZDogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBzdGFnaW5nOiBLRVlfU0VTU0lPTi5zdGFnaW5nLFxuICAgIGRldjogS0VZX1NFU1NJT04uZGV2LFxufTtcbi8qIGV0aCBzZXJpZXMgY29uc3RhbnRzIGVuZCAqL1xuLyogYXB0b3MgY29uc3RhbnRzIGJlZ2luICovXG5jb25zdCBBUFRfU0VTU0lPTl9LRVlfTUFQUElORyA9IHtcbiAgICAxOiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgIDI6IEtFWV9TRVNTSU9OLmRldixcbiAgICAzOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgNDogS0VZX1NFU1NJT04uZGV2LFxuICAgIDU6IEtFWV9TRVNTSU9OLnN0YWdpbmcsXG59O1xuY29uc3QgQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIC8vIE1BSU5ORVRcbiAgICAxOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgLy8gVEVTVE5FVFxuICAgIDI6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gREVWTkVUXG4gICAgMzogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBURVNUSU5HXG4gICAgNDogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBQUkVNQUlOTkVUXG4gICAgNTogJ2h0dHBzOi8vd2FsbGV0LXYyLXN0YWdpbmcuYmxvY3RvLmFwcCcsXG59O1xudmFyIFdhbGxldEFkYXB0ZXJOZXR3b3JrO1xuKGZ1bmN0aW9uIChXYWxsZXRBZGFwdGVyTmV0d29yaykge1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiTWFpbm5ldFwiXSA9IFwibWFpbm5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiVGVzdG5ldFwiXSA9IFwidGVzdG5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiRGV2bmV0XCJdID0gXCJkZXZuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RpbmdcIl0gPSBcInRlc3RpbmdcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlByZW1haW5uZXRcIl0gPSBcInByZW1haW5uZXRcIjtcbn0pKFdhbGxldEFkYXB0ZXJOZXR3b3JrIHx8IChXYWxsZXRBZGFwdGVyTmV0d29yayA9IHt9KSk7XG5jb25zdCBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HID0ge1xuICAgIDE6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLk1haW5uZXQsXG4gICAgMjogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdG5ldCxcbiAgICAzOiBXYWxsZXRBZGFwdGVyTmV0d29yay5EZXZuZXQsXG4gICAgNDogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdGluZyxcbiAgICA1OiBXYWxsZXRBZGFwdGVyTmV0d29yay5QcmVtYWlubmV0LFxufTtcbmNvbnN0IEFQVF9DSEFJTl9JRF9SUENfTUFQUElORyA9IHtcbiAgICAxOiAnaHR0cHM6Ly9mdWxsbm9kZS5tYWlubmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDI6ICdodHRwczovL2Z1bGxub2RlLnRlc3RuZXQuYXB0b3NsYWJzLmNvbS92MScsXG4gICAgMzogJ2h0dHBzOi8vZnVsbG5vZGUuZGV2bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDQ6ICcnLFxuICAgIDU6ICdodHRwczovL3ByZW1haW5uZXQuYXB0b3NkZXYuY29tL3YxJyxcbn07XG4vKiBhcHRvcyBjb25zdGFudHMgZW5kICovXG5jb25zdCBFSVAxMTkzX0VWRU5UUyA9IFtcbiAgICAnY29ubmVjdCcsXG4gICAgJ2Rpc2Nvbm5lY3QnLFxuICAgICdtZXNzYWdlJyxcbiAgICAnY2hhaW5DaGFuZ2VkJyxcbiAgICAnYWNjb3VudHNDaGFuZ2VkJyxcbl07XG4vLyBQcmVzZXJ2ZSBsb2dpbiBmb3IgMSBkYXlcbmNvbnN0IExPR0lOX1BFUlNJU1RJTkdfVElNRSA9IDg2NDAwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfQVBQX0lEID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG4vLyBXaWxsIGluamVjdCB0aGUgdmVyc2lvbiBvZiB0aGUgU0RLIGJ5IHJvbGx1cCB2ZXJzaW9uSW5qZWN0b3IgZHVyaW5nIGJ1aWxkIHRpbWVcbmNvbnN0IFNES19WRVJTSU9OID0gJzAuMTAuMic7XG5cbi8vIFRoZSByb290IGNsYXNzIGZvciBhbGwgcHJvdmlkZXJzXG5jbGFzcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNCbG9jdG8gPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgLy8gYWxpYXMgcmVtb3ZlTGlzdGVuZXJcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLnJlbW92ZUxpc3RlbmVyO1xuICAgICAgICAvLyBpbml0IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBFSVAxMTkzX0VWRU5UUy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwSWQgPSBERUZBVUxUX0FQUF9JRDtcbiAgICB9XG4gICAgLy8gaW1wbGVtZW50IGJ5IGNoaWxkcmVuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IH0pO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFFSVAxMTkzX0VWRU5UUy5pbmNsdWRlcyhldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBAdG9kbzogaW1wbGVtZW50IGl0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgb25jZSgpIHsgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IElGUkFNRV9TVFlMRSA9ICd3aWR0aDoxMDB2dztoZWlnaHQ6MTAwJTtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7ei1pbmRleDoyMTQ3NDgzNjQ2O2JvcmRlcjpub25lO2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvci1zY2hlbWU6bGlnaHQ7aW5zZXQ6MHB4O2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6YXV0bzsnO1xuZnVuY3Rpb24gY3JlYXRlRnJhbWUodXJsKSB7XG4gICAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybCk7XG4gICAgZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsIElGUkFNRV9TVFlMRSk7XG4gICAgcmV0dXJuIGZyYW1lO1xufVxuZnVuY3Rpb24gYXR0YWNoRnJhbWUoZnJhbWUpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZyYW1lKTtcbn1cbmZ1bmN0aW9uIGRldGF0Y2hGcmFtZShmcmFtZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmcmFtZSAmJiBmcmFtZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZyYW1lKTtcbiAgICB9XG59XG5cbnZhciBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlciA9IChldmVudFR5cGUsIGhhbmRsZXIsIHRhcmdldCA9IHdpbmRvdykgPT4ge1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBoYW5kbGVyKGUsIHJlbW92ZUV2ZW50TGlzdGVuZXIpO1xuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbn07XG5cbmNvbnN0IGlzU3RvcmFnZVN1cHBvcnRlZCA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnbG9jYWxfc3RvcmFnZV9zdXBwb3J0ZWQnLCAnMScpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbG9jYWxfc3RvcmFnZV9zdXBwb3J0ZWQnKTtcbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09ICcxJztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuY2xhc3MgTWVtb3J5U3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpc1trZXldIHx8IG51bGw7XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2tleV07XG4gICAgfVxufVxuY29uc3QgbWVtb3J5U3RvcmFnZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93Lm1lbW9yeVN0b3JhZ2UgOiBuZXcgTWVtb3J5U3RvcmFnZSgpO1xuXG5jb25zdCBzdG9yYWdlID0gaXNTdG9yYWdlU3VwcG9ydGVkKCkgPyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UgOiBtZW1vcnlTdG9yYWdlO1xuY29uc3QgZ2V0SXRlbSA9IChrZXksIGRlZmF1bHRWYWx1ZSA9IG51bGwpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSkpIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKFN5bnRheEVycm9yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgfVxufTtcbmNvbnN0IHNldEl0ZW0gPSAoa2V5LCB2YWx1ZSkgPT4gc3RvcmFnZS5zZXRJdGVtKGtleSwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbmNvbnN0IHJlbW92ZUl0ZW0gPSAoa2V5KSA9PiB7XG4gICAgc2V0SXRlbShrZXksICcnKTsgLy8gRHVlIHRvIHNvbWUgdmVyc2lvbnMgb2YgYnJvd3NlciBidWcgY2FuJ3QgcmVtb3ZlSXRlbSBjb3JyZWN0bHkuXG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0tFWV9TRVNTSU9OfSBrZXkgLSBrZXkgdG8gcmV0cmlldmUgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtQcm92aWRlclNlc3Npb24gfCBudWxsfSBQcm92aWRlclNlc3Npb24gfCBudWxsXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCBQcm92aWRlclNlc3Npb24gZnJvbSBzdG9yYWdlLlxuICogSWYgdGhlIGRhdGEgaXMgZXhwaXJlZCwgd2lsbCByZW1vdmUgdGhlIGRhdGEgYW5kIHJldHVybiBudWxsXG4gKi9cbmNvbnN0IGdldEFjY291bnRTdG9yYWdlID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IHJhd0FjY291bnRTdG9yYWdlID0gZ2V0SXRlbShrZXksIG51bGwpO1xuICAgIGlmICghcmF3QWNjb3VudFN0b3JhZ2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIGNvbXBhcmUgdGhlIGV4cGlyeSB0aW1lIG9mIHRoZSBpdGVtIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IHJhd0FjY291bnRTdG9yYWdlLmV4cGlyeSB8fFxuICAgICAgICByYXdBY2NvdW50U3RvcmFnZS52ICE9PSBTREtfVkVSU0lPTikge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGE7XG59O1xuLyoqXG4gIEBwYXJhbSB7S0VZX1NFU1NJT059IGtleSAtIGtleSB0byBzdG9yZSB0aGUgZGF0YVxuICBAcGFyYW0ge1Byb3ZpZGVyU2Vzc2lvbn0gZGF0YSAtIE9ubHkgdGhlIHBhcnQgb2YgUHJvdmlkZXJTZXNzaW9uIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICBAcGFyYW0ge251bWJlcn0gZXhwaXJ5IC0gZXhwaXJ5IHRpbWUgb2YgdGhlIGRhdGFcbiovXG5jb25zdCBzZXRBY2NvdW50U3RvcmFnZSA9IChrZXksIGRhdGEsIGV4cGlyeSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHJhd0FjY291bnRTdG9yYWdlID0gZ2V0SXRlbShrZXkpO1xuICAgIGNvbnN0IG5ld0FjY291bnRTdG9yYWdlID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBjb2RlOiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNvZGUpIHx8ICgoX2EgPSByYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpLFxuICAgICAgICAgICAgYWNjb3VudHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2NvdW50cyksIGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5hY2NvdW50cyksXG4gICAgICAgICAgICBldm06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9jID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ldm0pLCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuZXZtKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwaXJ5OiBleHBpcnkgfHxcbiAgICAgICAgICAgIChyYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZXhwaXJ5KSB8fFxuICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBMT0dJTl9QRVJTSVNUSU5HX1RJTUUsXG4gICAgICAgIHY6IFNES19WRVJTSU9OLFxuICAgIH07XG4gICAgc2V0SXRlbShrZXksIG5ld0FjY291bnRTdG9yYWdlKTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgZ2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoISgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkpIHtcbiAgICAgICAgcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgoX2MgPSAoX2IgPSBnZXRBY2NvdW50U3RvcmFnZShrZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjb3VudHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tjaGFpbl0pIHx8IG51bGw7XG59O1xuY29uc3Qgc2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4sIGFjY291bnQpID0+IHtcbiAgICBzZXRBY2NvdW50U3RvcmFnZShrZXksIHsgYWNjb3VudHM6IHsgW2NoYWluXTogYWNjb3VudCB9IH0pO1xuICAgIHJldHVybjtcbn07XG5jb25zdCByZW1vdmVDaGFpbkFkZHJlc3MgPSAoa2V5LCBjaGFpbikgPT4ge1xuICAgIHNldEFjY291bnRTdG9yYWdlKGtleSwgeyBhY2NvdW50czogeyBbY2hhaW5dOiB1bmRlZmluZWQgfSB9KTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgZ2V0RXZtQWRkcmVzcyA9IChrZXksIGNoYWluKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKCEoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2Uoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoKF9jID0gKF9iID0gZ2V0QWNjb3VudFN0b3JhZ2Uoa2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2bSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2NoYWluXSkgfHwgbnVsbDtcbn07XG5jb25zdCBzZXRFdm1BZGRyZXNzID0gKGtleSwgY2hhaW4sIGFjY291bnRzKSA9PiB7XG4gICAgc2V0QWNjb3VudFN0b3JhZ2Uoa2V5LCB7IGV2bTogeyBbY2hhaW5dOiBhY2NvdW50cyB9IH0pO1xuICAgIHJldHVybjtcbn07XG5jb25zdCByZW1vdmVBbGxFdm1BZGRyZXNzID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IG5ld0FjY291bnRTdG9yYWdlID0gZ2V0SXRlbShrZXkpO1xuICAgIGlmICghbmV3QWNjb3VudFN0b3JhZ2UpXG4gICAgICAgIHJldHVybjtcbiAgICBuZXdBY2NvdW50U3RvcmFnZS5kYXRhLmV2bSA9IHt9O1xuICAgIHNldEl0ZW0oa2V5LCBuZXdBY2NvdW50U3RvcmFnZSk7XG4gICAgcmV0dXJuO1xufTtcblxuZnVuY3Rpb24gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIGtleSwgZGlzY29ubmVjdEhhbmRsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlKSB8fCAndW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgZS5lcnJvcl9jb2RlID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmVycm9yX2NvZGU7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGlzRW1haWwgPSAodmFsdWUpID0+IC9cXFMrQFxcUytcXC5cXFMrLy50ZXN0KHZhbHVlKTtcblxudmFyIEVSUk9SX01FU1NBR0U7XG4oZnVuY3Rpb24gKEVSUk9SX01FU1NBR0UpIHtcbiAgICBFUlJPUl9NRVNTQUdFW1wiSU5WQUxJRF9UUkFOU0FDVElPTlwiXSA9IFwiSW52YWxpZCB0cmFuc2FjdGlvblwiO1xuICAgIEVSUk9SX01FU1NBR0VbXCJJTlZBTElEX1RSQU5TQUNUSU9OU1wiXSA9IFwiSW52YWxpZCB0cmFuc2FjdGlvbnNcIjtcbiAgICBFUlJPUl9NRVNTQUdFW1wiSU5WQUxJRF9UUkFOU0FDVElPTl9WQUxVRVwiXSA9IFwiVHJhbnNhY3Rpb24gcGFyYW1zIFxcXCJ2YWx1ZVxcXCIgc2hvdWxkIGJlIGhleC1lbmNvZGVkIHN0cmluZ1wiO1xufSkoRVJST1JfTUVTU0FHRSB8fCAoRVJST1JfTUVTU0FHRSA9IHt9KSk7XG5cbnZhciBnbG9iYWwkMSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxudmFyIGxvb2t1cCA9IFtdO1xudmFyIHJldkxvb2t1cCA9IFtdO1xudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbnZhciBpbml0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXQgKCkge1xuICBpbml0ZWQgPSB0cnVlO1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMDtcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cbiAgdmFyIEwgPSAwO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz09JztcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9JztcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7XG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYztcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7XG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufVxuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwkMS5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwkMS5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHJ1ZTtcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xua01heExlbmd0aCgpO1xuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyOyAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgcmV0dXJuIGFyclxufTtcblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59O1xuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXk7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSA7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufTtcblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7XG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGg7IC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5O1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKTtcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pO1xuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbmZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59O1xuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7XG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7XG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMDtcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMDtcbiAgZW5kID4+Pj0gMDtcbiAgdGhpc1N0YXJ0ID4+Pj0gMDtcbiAgdGhpc0VuZCA+Pj49IDA7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwO1xuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyO1xuICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXg7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn07XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHZhciBpID0gc3RhcnQ7XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDA7XG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIHN0YXJ0ID0gfn5zdGFydDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuO1xuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwO1xuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgdmFyIG5ld0J1ZjtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn07XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICB2YXIgbXVsID0gMTtcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTtcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59O1xuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogODtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBsZW5cbn07XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTU7XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgdmFyIGk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IGludGVybmFsSXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2c7XG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJyk7XG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9JztcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgdmFyIGNvZGVQb2ludDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG87XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoaSA9IGMgPj4gODtcbiAgICBsbyA9IGMgJSAyNTY7XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuY29uc3QgaXNIZXhTdHJpbmcgPSAoaGV4KSA9PiB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyAmJiAvXjB4WzAtOUEtRmEtZl0qJC8udGVzdChoZXgpO1xuY29uc3QgdXRmOFRvSGV4ID0gKHN0cikgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuY29uc3QgaXNWYWxpZFRyYW5zYWN0aW9uID0gKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fFxuICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb24gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICEoJ2Zyb20nIGluIHRyYW5zYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgaW52YWxpZE1zZzogRVJST1JfTUVTU0FHRS5JTlZBTElEX1RSQU5TQUNUSU9OIH07XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi52YWx1ZSAmJiAhaXNIZXhTdHJpbmcodHJhbnNhY3Rpb24udmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNc2c6IEVSUk9SX01FU1NBR0UuSU5WQUxJRF9UUkFOU0FDVElPTl9WQUxVRSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xufTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGludmFsaWRNc2c6IEVSUk9SX01FU1NBR0UuSU5WQUxJRF9UUkFOU0FDVElPTlMgfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCBpbnZhbGlkTXNnIH0gPSBpc1ZhbGlkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zW2ldKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkLCBpbnZhbGlkTXNnIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xufTtcblxuZnVuY3Rpb24gZ2V0RXZtU3VwcG9ydCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmtzIH0gPSB5aWVsZCBmZXRjaCgnaHR0cHM6Ly9hcGkuYmxvY3RvLmFwcC9uZXR3b3Jrcy9ldm0nKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgY29uc3QgZXZtU3VwcG9ydE1hcCA9IG5ldHdvcmtzLnJlZHVjZSgoYSwgdikgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYSksIHsgW3YuY2hhaW5faWRdOiB2IH0pKSwge30pO1xuICAgICAgICByZXR1cm4gZXZtU3VwcG9ydE1hcDtcbiAgICB9KTtcbn1cblxudmFyIGRpc3QgPSB7fTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxudmFyIGNsYXNzZXMgPSB7fTtcblxudmFyIGZhc3RTYWZlU3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuc3RyaW5naWZ5W1wiZGVmYXVsdFwiXSA9IHN0cmluZ2lmeTtcbnN0cmluZ2lmeS5zdGFibGUgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnk7XG52YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gJ1suLi5dJztcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSAnW0NpcmN1bGFyXSc7XG52YXIgYXJyID0gW107XG52YXIgcmVwbGFjZXJTdGFjayA9IFtdO1xuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gIHJldHVybiB7XG4gICAgZGVwdGhMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgfTtcbn1cblxuLy8gUmVndWxhciBzdHJpbmdpZnlcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICB9XG4gIGRlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJyk7XG4gIH0gZmluYWxseSB7XG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc2V0UmVwbGFjZShyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xuICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHtcbiAgICAgICAgdmFsdWU6IHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZXJTdGFjay5wdXNoKFt2YWwsIGssIHJlcGxhY2VdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2tdID0gcmVwbGFjZTtcbiAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICBkZXB0aCArPSAxO1xuICB2YXIgaTtcbiAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgfVxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmo7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMTtcbiAgdmFyIGk7XG4gIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgcGFyZW50W2tdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cbn1cblxuLy8gd3JhcHMgcmVwbGFjZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHZhbHVlcyB3ZSBjb3VsZG4ndCByZXBsYWNlXG4vLyBhbmQgbWFyayB0aGVtIGFzIHJlcGxhY2VkIHZhbHVlXG5mdW5jdGlvbiByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSB7XG4gIHJlcGxhY2VyID0gdHlwZW9mIHJlcGxhY2VyICE9PSAndW5kZWZpbmVkJyA/IHJlcGxhY2VyIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV07XG4gICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgdmFsID0gcGFydFsyXTtcbiAgICAgICAgICByZXBsYWNlclN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc2VzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5jbGFzc2VzLkV0aGVyZXVtUHJvdmlkZXJFcnJvciA9IGNsYXNzZXMuRXRoZXJldW1ScGNFcnJvciA9IHZvaWQgMDtcbnZhciBmYXN0X3NhZmVfc3RyaW5naWZ5XzEgPSBmYXN0U2FmZVN0cmluZ2lmeTtcbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEpTT04gUlBDIDIuMCBlcnJvcnMgYW5kIEV0aGVyZXVtIFJQQyBlcnJvcnNcbiAqIHBlciBFSVAtMTQ3NC5cbiAqIFBlcm1pdHMgYW55IGludGVnZXIgZXJyb3IgY29kZS5cbiAqL1xudmFyIEV0aGVyZXVtUnBjRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoRXRoZXJldW1ScGNFcnJvciwgX0Vycm9yKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFdGhlcmV1bVJwY0Vycm9yKTtcbiAgZnVuY3Rpb24gRXRoZXJldW1ScGNFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdGhlcmV1bVJwY0Vycm9yKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIGFsbCBwdWJsaWMgY2xhc3MgcHJvcGVydGllcy5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhFdGhlcmV1bVJwY0Vycm9yLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvciwgb21pdHRpbmdcbiAgICAgKiBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBmYXN0X3NhZmVfc3RyaW5naWZ5XzFbXCJkZWZhdWx0XCJdKHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEV0aGVyZXVtUnBjRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuY2xhc3Nlcy5FdGhlcmV1bVJwY0Vycm9yID0gRXRoZXJldW1ScGNFcnJvcjtcbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9ycyBwZXIgRUlQLTExOTMuXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gKi9cbnZhciBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdGhlcmV1bVJwY0Vycm9yKSB7XG4gIF9pbmhlcml0cyhFdGhlcmV1bVByb3ZpZGVyRXJyb3IsIF9FdGhlcmV1bVJwY0Vycm9yKTtcbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoRXRoZXJldW1Qcm92aWRlckVycm9yKTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFdGhlcmV1bSBQcm92aWRlciBKU09OLVJQQyBlcnJvci5cbiAgICogYGNvZGVgIG11c3QgYmUgYW4gaW50ZWdlciBpbiB0aGUgMTAwMCA8PSA0OTk5IHJhbmdlLlxuICAgKi9cbiAgZnVuY3Rpb24gRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoZXJldW1Qcm92aWRlckVycm9yKTtcbiAgICBpZiAoIWlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogMTAwMCA8PSBjb2RlIDw9IDQ5OTknKTtcbiAgICB9XG4gICAgcmV0dXJuIF9zdXBlcjIuY2FsbCh0aGlzLCBjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG59KEV0aGVyZXVtUnBjRXJyb3IpO1xuY2xhc3Nlcy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBFdGhlcmV1bVByb3ZpZGVyRXJyb3I7XG4vLyBJbnRlcm5hbFxuZnVuY3Rpb24gaXNWYWxpZEV0aFByb3ZpZGVyQ29kZShjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDQ5OTk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09ICdbQ2lyY3VsYXJdJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgdXRpbHMgPSB7fTtcblxudmFyIGVycm9yQ29uc3RhbnRzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvckNvbnN0YW50cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXJyb3JDb25zdGFudHMuZXJyb3JWYWx1ZXMgPSBlcnJvckNvbnN0YW50cy5lcnJvckNvZGVzID0gdm9pZCAwO1xuZXJyb3JDb25zdGFudHMuZXJyb3JDb2RlcyA9IHtcbiAgcnBjOiB7XG4gICAgaW52YWxpZElucHV0OiAtMzIwMDAsXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogLTMyMDAxLFxuICAgIHJlc291cmNlVW5hdmFpbGFibGU6IC0zMjAwMixcbiAgICB0cmFuc2FjdGlvblJlamVjdGVkOiAtMzIwMDMsXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiAtMzIwMDQsXG4gICAgbGltaXRFeGNlZWRlZDogLTMyMDA1LFxuICAgIHBhcnNlOiAtMzI3MDAsXG4gICAgaW52YWxpZFJlcXVlc3Q6IC0zMjYwMCxcbiAgICBtZXRob2ROb3RGb3VuZDogLTMyNjAxLFxuICAgIGludmFsaWRQYXJhbXM6IC0zMjYwMixcbiAgICBpbnRlcm5hbDogLTMyNjAzXG4gIH0sXG4gIHByb3ZpZGVyOiB7XG4gICAgdXNlclJlamVjdGVkUmVxdWVzdDogNDAwMSxcbiAgICB1bmF1dGhvcml6ZWQ6IDQxMDAsXG4gICAgdW5zdXBwb3J0ZWRNZXRob2Q6IDQyMDAsXG4gICAgZGlzY29ubmVjdGVkOiA0OTAwLFxuICAgIGNoYWluRGlzY29ubmVjdGVkOiA0OTAxXG4gIH1cbn07XG5lcnJvckNvbnN0YW50cy5lcnJvclZhbHVlcyA9IHtcbiAgJy0zMjcwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci4gQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuJ1xuICB9LFxuICAnLTMyNjAwJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC4nXG4gIH0sXG4gICctMzI2MDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS4nXG4gIH0sXG4gICctMzI2MDInOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykuJ1xuICB9LFxuICAnLTMyNjAzJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuJ1xuICB9LFxuICAnLTMyMDAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGlucHV0LidcbiAgfSxcbiAgJy0zMjAwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnUmVzb3VyY2Ugbm90IGZvdW5kLidcbiAgfSxcbiAgJy0zMjAwMic6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnUmVzb3VyY2UgdW5hdmFpbGFibGUuJ1xuICB9LFxuICAnLTMyMDAzJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdUcmFuc2FjdGlvbiByZWplY3RlZC4nXG4gIH0sXG4gICctMzIwMDQnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ01ldGhvZCBub3Qgc3VwcG9ydGVkLidcbiAgfSxcbiAgJy0zMjAwNSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnUmVxdWVzdCBsaW1pdCBleGNlZWRlZC4nXG4gIH0sXG4gICc0MDAxJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LidcbiAgfSxcbiAgJzQxMDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgbWVzc2FnZTogJ1RoZSByZXF1ZXN0ZWQgYWNjb3VudCBhbmQvb3IgbWV0aG9kIGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLidcbiAgfSxcbiAgJzQyMDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgbWVzc2FnZTogJ1RoZSByZXF1ZXN0ZWQgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBFdGhlcmV1bSBwcm92aWRlci4nXG4gIH0sXG4gICc0OTAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy4nXG4gIH0sXG4gICc0OTAxJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNwZWNpZmllZCBjaGFpbi4nXG4gIH1cbn07XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9IHZvaWQgMDtcbiAgdmFyIGVycm9yX2NvbnN0YW50c18xID0gZXJyb3JDb25zdGFudHM7XG4gIHZhciBjbGFzc2VzXzEgPSBjbGFzc2VzO1xuICB2YXIgRkFMTEJBQ0tfRVJST1JfQ09ERSA9IGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludGVybmFsO1xuICB2YXIgRkFMTEJBQ0tfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBlcnJvciBtZXNzYWdlLiBUaGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0Lic7XG4gIHZhciBGQUxMQkFDS19FUlJPUiA9IHtcbiAgICBjb2RlOiBGQUxMQkFDS19FUlJPUl9DT0RFLFxuICAgIG1lc3NhZ2U6IGdldE1lc3NhZ2VGcm9tQ29kZShGQUxMQkFDS19FUlJPUl9DT0RFKVxuICB9O1xuICBleHBvcnRzLkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFID0gJ1Vuc3BlY2lmaWVkIHNlcnZlciBlcnJvci4nO1xuICAvKipcbiAgICogR2V0cyB0aGUgbWVzc2FnZSBmb3IgYSBnaXZlbiBjb2RlLCBvciBhIGZhbGxiYWNrIG1lc3NhZ2UgaWYgdGhlIGNvZGUgaGFzXG4gICAqIG5vIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSB7XG4gICAgdmFyIGZhbGxiYWNrTWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRkFMTEJBQ0tfTUVTU0FHRTtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgdmFyIGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoaGFzS2V5KGVycm9yX2NvbnN0YW50c18xLmVycm9yVmFsdWVzLCBjb2RlU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10ubWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZTtcbiAgfVxuICBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGdldE1lc3NhZ2VGcm9tQ29kZTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAgICogQSBjb2RlIGlzIG9ubHkgdmFsaWQgaWYgaXQgaGFzIGEgbWVzc2FnZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRDb2RlKGNvZGUpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgaWYgKGVycm9yX2NvbnN0YW50c18xLmVycm9yVmFsdWVzW2NvZGVTdHJpbmddKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cG9ydHMuaXNWYWxpZENvZGUgPSBpc1ZhbGlkQ29kZTtcbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGVycm9yIHRvIGFuIEV0aGVyZXVtIEpTT04gUlBDLWNvbXBhdGlibGUgZXJyb3Igb2JqZWN0LlxuICAgKiBNZXJlbHkgY29waWVzIHRoZSBnaXZlbiBlcnJvcidzIHZhbHVlcyBpZiBpdCBpcyBhbHJlYWR5IGNvbXBhdGlibGUuXG4gICAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgb24gdGhlXG4gICAqIHJldHVybmVkIG9iamVjdCdzIGRhdGEub3JpZ2luYWxFcnJvciBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRmYWxsYmFja0Vycm9yID0gX3JlZi5mYWxsYmFja0Vycm9yLFxuICAgICAgZmFsbGJhY2tFcnJvciA9IF9yZWYkZmFsbGJhY2tFcnJvciA9PT0gdm9pZCAwID8gRkFMTEJBQ0tfRVJST1IgOiBfcmVmJGZhbGxiYWNrRXJyb3IsXG4gICAgICBfcmVmJHNob3VsZEluY2x1ZGVTdGEgPSBfcmVmLnNob3VsZEluY2x1ZGVTdGFjayxcbiAgICAgIHNob3VsZEluY2x1ZGVTdGFjayA9IF9yZWYkc2hvdWxkSW5jbHVkZVN0YSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHNob3VsZEluY2x1ZGVTdGE7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIWZhbGxiYWNrRXJyb3IgfHwgIU51bWJlci5pc0ludGVnZXIoZmFsbGJhY2tFcnJvci5jb2RlKSB8fCB0eXBlb2YgZmFsbGJhY2tFcnJvci5tZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS4nKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvci5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSB7fTtcbiAgICBpZiAoZXJyb3IgJiYgX3R5cGVvZihlcnJvcikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSAmJiBoYXNLZXkoZXJyb3IsICdjb2RlJykgJiYgaXNWYWxpZENvZGUoZXJyb3IuY29kZSkpIHtcbiAgICAgIHZhciBfZXJyb3IgPSBlcnJvcjtcbiAgICAgIHNlcmlhbGl6ZWQuY29kZSA9IF9lcnJvci5jb2RlO1xuICAgICAgaWYgKF9lcnJvci5tZXNzYWdlICYmIHR5cGVvZiBfZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gX2Vycm9yLm1lc3NhZ2U7XG4gICAgICAgIGlmIChoYXNLZXkoX2Vycm9yLCAnZGF0YScpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZC5kYXRhID0gX2Vycm9yLmRhdGE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IGdldE1lc3NhZ2VGcm9tQ29kZShzZXJpYWxpemVkLmNvZGUpO1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZC5jb2RlID0gZmFsbGJhY2tFcnJvci5jb2RlO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAoX2EgPSBlcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2U7XG4gICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBmYWxsYmFja0Vycm9yLm1lc3NhZ2U7XG4gICAgICBzZXJpYWxpemVkLmRhdGEgPSB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgc3RhY2sgPSAoX2IgPSBlcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YWNrO1xuICAgIGlmIChzaG91bGRJbmNsdWRlU3RhY2sgJiYgZXJyb3IgJiYgc3RhY2sgJiYgdHlwZW9mIHN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gc2VyaWFsaXplRXJyb3I7XG4gIC8vIEludGVybmFsXG4gIGZ1bmN0aW9uIGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAtMzIwOTkgJiYgY29kZSA8PSAtMzIwMDA7XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiBfdHlwZW9mKGVycm9yKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgZnVuY3Rpb24gaGFzS2V5KG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH1cbn0pKHV0aWxzKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9ICEwLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgZXJyb3JzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvcnMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9ycy5ldGhFcnJvcnMgPSB2b2lkIDA7XG52YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbnZhciB1dGlsc18xID0gdXRpbHM7XG52YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbmVycm9ycy5ldGhFcnJvcnMgPSB7XG4gIHJwYzoge1xuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBQYXJzZSAoLTMyNzAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnZhbGlkUmVxdWVzdDogZnVuY3Rpb24gaW52YWxpZFJlcXVlc3QoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUGFyYW1zICgtMzI2MDIpIGVycm9yLlxuICAgICAqL1xuICAgIGludmFsaWRQYXJhbXM6IGZ1bmN0aW9uIGludmFsaWRQYXJhbXMoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXRob2ROb3RGb3VuZDogZnVuY3Rpb24gbWV0aG9kTm90Rm91bmQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgICAqL1xuICAgIGludGVybmFsOiBmdW5jdGlvbiBpbnRlcm5hbChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgICAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAtMzIwOTkgPD0gLTMyMDA1IF0gcmFuZ2UuXG4gICAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICAgKi9cbiAgICBzZXJ2ZXI6IGZ1bmN0aW9uIHNlcnZlcihvcHRzKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgX3R5cGVvZihvcHRzKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBvcHRzLmNvZGU7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZElucHV0OiBmdW5jdGlvbiBpbnZhbGlkSW5wdXQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRJbnB1dCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAgICovXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogZnVuY3Rpb24gcmVzb3VyY2VOb3RGb3VuZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBVbmF2YWlsYWJsZSAoLTMyMDAyKSBlcnJvci5cbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiBmdW5jdGlvbiByZXNvdXJjZVVuYXZhaWxhYmxlKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFRyYW5zYWN0aW9uIFJlamVjdGVkICgtMzIwMDMpIGVycm9yLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IGZ1bmN0aW9uIHRyYW5zYWN0aW9uUmVqZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAgICovXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiBmdW5jdGlvbiBtZXRob2ROb3RTdXBwb3J0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKi9cbiAgICBsaW1pdEV4Y2VlZGVkOiBmdW5jdGlvbiBsaW1pdEV4Y2VlZGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpO1xuICAgIH1cbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICAgKi9cbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiBmdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiBmdW5jdGlvbiB1bmF1dGhvcml6ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbnN1cHBvcnRlZCBNZXRob2QgKDQyMDApIGVycm9yLlxuICAgICAqL1xuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiBmdW5jdGlvbiB1bnN1cHBvcnRlZE1ldGhvZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gY2hhaW5EaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgICAqL1xuICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKG9wdHMpIHtcbiAgICAgIGlmICghb3B0cyB8fCBfdHlwZW9mKG9wdHMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gb3B0cy5jb2RlLFxuICAgICAgICBtZXNzYWdlID0gb3B0cy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gb3B0cy5kYXRhO1xuICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG4gIH1cbn07XG4vLyBJbnRlcm5hbFxuZnVuY3Rpb24gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICB2YXIgX3BhcnNlT3B0cyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHMyID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0cywgMiksXG4gICAgbWVzc2FnZSA9IF9wYXJzZU9wdHMyWzBdLFxuICAgIGRhdGEgPSBfcGFyc2VPcHRzMlsxXTtcbiAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gIHZhciBfcGFyc2VPcHRzMyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHM0ID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0czMsIDIpLFxuICAgIG1lc3NhZ2UgPSBfcGFyc2VPcHRzNFswXSxcbiAgICBkYXRhID0gX3BhcnNlT3B0czRbMV07XG4gIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcbiAgaWYgKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gYXJnLmRhdGE7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21lc3NhZ2UgfHwgdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSBleHBvcnRzLmV0aEVycm9ycyA9IGV4cG9ydHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbiAgdmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUnBjRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJldW1Qcm92aWRlckVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgdmFyIHV0aWxzXzEgPSB1dGlscztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5zZXJpYWxpemVFcnJvcjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNzYWdlRnJvbUNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGU7XG4gICAgfVxuICB9KTtcbiAgdmFyIGVycm9yc18xID0gZXJyb3JzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJldGhFcnJvcnNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZXJyb3JzXzEuZXRoRXJyb3JzO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlcnJvckNvZGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXM7XG4gICAgfVxuICB9KTtcbn0pKGRpc3QpO1xuXG52YXIgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzLCBfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQsIF9FdGhlcmV1bVByb3ZpZGVyX2NyZWF0ZUF1dGh6RnJhbWU7XG5mdW5jdGlvbiBwYXJzZUNoYWluSWQoY2hhaW5JZCkge1xuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY2hhaW5JZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhaW5JZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChjaGFpbklkLCAxMCk7XG59XG5jbGFzcyBFdGhlcmV1bVByb3ZpZGVyIGV4dGVuZHMgQmxvY3RvUHJvdmlkZXIge1xuICAgIGdldCBleGlzdGVkU0RLKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd2luZG93LmV0aGVyZXVtO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gJzEnOyAvLyBzYW1lIGFzIGNoYWluSWQgYnV0IGluIGRlY2ltYWxcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLnJlbW92ZUxpc3RlbmVyO1xuICAgICAgICB0aGlzLmluamVjdGVkV2FsbGV0U2VydmVyID0gY29uZmlnLndhbGxldFNlcnZlcjtcbiAgICAgICAgdGhpcy5fYmxvY3RvID0ge1xuICAgICAgICAgICAgc2Vzc2lvbktleUVudjogS0VZX1NFU1NJT04ucHJvZCxcbiAgICAgICAgICAgIHdhbGxldFNlcnZlcjogdGhpcy5pbmplY3RlZFdhbGxldFNlcnZlciB8fCAnJyxcbiAgICAgICAgICAgIGJsb2NrY2hhaW5OYW1lOiAnJyxcbiAgICAgICAgICAgIG5ldHdvcmtUeXBlOiAnJyxcbiAgICAgICAgICAgIHN3aXRjaGFibGVOZXR3b3JrOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGNvbmZpZy5hcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICAgICAgaWYgKCdjaGFpbklkJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgcnBjIH0gPSBjb25maWc7XG4gICAgICAgICAgICBpbnZhcmlhbnQoY2hhaW5JZCwgXCInY2hhaW5JZCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKGNoYWluSWQpfWA7XG4gICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChjaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgIC8vIHNldHVwIHJwY1xuICAgICAgICAgICAgdGhpcy5ycGMgPSBycGMgfHwgRVRIX1JQQ19MSVNUW3RoaXMubmV0d29ya1ZlcnNpb25dO1xuICAgICAgICAgICAgaW52YXJpYW50KHRoaXMucnBjLCBcIidycGMnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0Q2hhaW5JZCwgc3dpdGNoYWJsZUNoYWlucyB9ID0gY29uZmlnO1xuICAgICAgICAgICAgaW52YXJpYW50KGRlZmF1bHRDaGFpbklkLCBcIidkZWZhdWx0Q2hhaW5JZCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKGRlZmF1bHRDaGFpbklkKX1gO1xuICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQoZGVmYXVsdENoYWluSWQpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgLy8gZ2V0IGNvbmZpZyBmcm9tIHN3aXRjaGFibGVDaGFpbnMgYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IGNoYWluQ29uZmlnID0gc3dpdGNoYWJsZUNoYWlucy5maW5kKChjaGFpbikgPT4gcGFyc2VDaGFpbklkKGNoYWluLmNoYWluSWQpID09PSBwYXJzZUNoYWluSWQoZGVmYXVsdENoYWluSWQpKTtcbiAgICAgICAgICAgIGlmICghY2hhaW5Db25maWcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAxMDAxLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ2hhaW4gJHtkZWZhdWx0Q2hhaW5JZH0gaXMgbm90IGluIHN3aXRjaGFibGVDaGFpbnMgbGlzdGAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJwYyA9ICgoX2EgPSBjaGFpbkNvbmZpZy5ycGNVcmxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pIHx8IEVUSF9SUENfTElTVFt0aGlzLm5ldHdvcmtWZXJzaW9uXTtcbiAgICAgICAgICAgIGludmFyaWFudCh0aGlzLnJwYywgXCIncnBjJyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2N0by51bmxvYWRlZE5ldHdvcmsgPSBzd2l0Y2hhYmxlQ2hhaW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERFUFJFQ0FURUQgQVBJOiBzZWUgaHR0cHM6Ly9kb2NzLm1ldGFtYXNrLmlvL2d1aWRlL2V0aGVyZXVtLXByb3ZpZGVyLmh0bWwjZXRoZXJldW0tc2VuZC1kZXByZWNhdGVkXG4gICAgc2VuZChtZXRob2RPclBheWxvYWQsIHBhcmFtc09yQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZSB0eXBlIDE6IGFyZzEgLSBKU09OLVJQQyBwYXlsb2FkLCBhcmcyIC0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgLy8gZXRoZXJldW0uc2VuZChwYXlsb2FkOiBKc29uUnBjUmVxdWVzdCwgY2FsbGJhY2s6IEpzb25ScGNDYWxsYmFjayk6IHZvaWQ7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaWduYXR1cmUgaXMgZXhhY3RseSBsaWtlIGV0aGVyZXVtLnNlbmRBc3luYygpXG4gICAgICAgICAgICAgICAgY2FzZSBwYXJhbXNPckNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyhtZXRob2RPclBheWxvYWQsIHBhcmFtc09yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZSB0eXBlIDI6IGFyZzEgLSBKU09OLVJQQyBtZXRob2QgbmFtZSwgYXJnMiAtIHBhcmFtcyBhcnJheTtcbiAgICAgICAgICAgICAgICAvLyBldGhlcmV1bS5zZW5kKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM/OiBBcnJheTx1bmtub3duPik6IFByb21pc2U8SnNvblJwY1Jlc3BvbnNlPjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBpcyBsaWtlIGFuIGFzeW5jIGV0aGVyZXVtLnNlbmRBc3luYygpIHdpdGggbWV0aG9kIGFuZCBwYXJhbXMgYXMgYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYSBKU09OLVJQQyBwYXlsb2FkIGFuZCBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZW9mIG1ldGhvZE9yUGF5bG9hZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwYXJhbXNPckNhbGxiYWNrKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RPclBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc09yQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZSB0eXBlIDM6IGFyZzEgLSBKU09OLVJQQyBwYXlsb2FkKHNob3VsZCBiZSBzeW5jaHJvbm91cyBtZXRob2RzKVxuICAgICAgICAgICAgICAgIC8vIGV0aGVyZXVtLnNlbmQocGF5bG9hZDogSnNvblJwY1JlcXVlc3QpOiB1bmtub3duO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGVuYWJsZXMgeW91IHRvIGNhbGwgc29tZSB0eXBlIG9mIFJQQyBtZXRob2RzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMobWV0aG9kT3JQYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERFUFJFQ0FURUQgQVBJOiBzZWUgaHR0cHM6Ly9kb2NzLm1ldGFtYXNrLmlvL2d1aWRlL2V0aGVyZXVtLXByb3ZpZGVyLmh0bWwjbGVnYWN5LW1ldGhvZHMgaW1wbGVtZW50YXRpb25cbiAgICAvLyB3ZWIzIHYxLnggQmF0Y2hSZXF1ZXN0IHN0aWxsIGRlcGVuZHMgb24gaXQgc28gd2UgbmVlZCB0byBpbXBsZW1lbnQgYW55d2F5IMKvXFxfKOODhClfL8KvXG4gICAgc2VuZEFzeW5jKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0ZVJlcXVlc3RzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5yZWR1Y2UoKGFjYywgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Muc2VuZFJlcXVlc3RzLnB1c2goKF9hID0gcmVxdWVzdC5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Mub3RoZXJSZXF1ZXN0cy5wdXNoKHRoaXMucmVxdWVzdChyZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7IHNlbmRSZXF1ZXN0czogW10sIG90aGVyUmVxdWVzdHM6IFtdIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VSZXNwb25zZShpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpdGVtLmlkKSxcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogaXRlbS5tZXRob2QsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZXMocGF5bG9hZCwgcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkUmVzcG9uc2VzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAxO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUmVzcG9uc2UgPSBjcmVhdGVCYXNlUmVzcG9uc2UoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUmVzcG9uc2UucmVzdWx0ID0gcmVzcG9uc2VzWzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3BvbnNlLmVycm9yID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZXNbMF0uc3RhdHVzICE9PSAnZnVsZmlsbGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlc1swXS5yZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VJbmRleCA8IHJlc3BvbnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlUmVzcG9uc2UucmVzdWx0ID0gcmVzcG9uc2VzW3Jlc3BvbnNlSW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VSZXNwb25zZS5lcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlc1tyZXNwb25zZUluZGV4XS5zdGF0dXMgIT09ICdmdWxmaWxsZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlc1tyZXNwb25zZUluZGV4XS5yZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRSZXNwb25zZXMucHVzaChiYXNlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzZWRSZXNwb25zZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVSZXF1ZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB3ZWIzIHYxLnggY29uY2F0IGJhdGNoZWQgSlNPTi1SUEMgcmVxdWVzdHMgdG8gYW4gYXJyYXksIGhhbmRsZSBpdCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzZW5kUmVxdWVzdHMsIG90aGVyUmVxdWVzdHMgfSA9IHNlcGFyYXRlUmVxdWVzdHMocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdHJhbnNhY3Rpb25zIGFuZCBzZW5kIGJhdGNoIHdpdGggY3VzdG9tIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFJlcVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc2VuZE11bHRpQ2FsbFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW3NlbmRSZXF1ZXN0cywgZmFsc2VdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1NlbmRSZXF1ZXN0c0VtcHR5ID0gc2VuZFJlcXVlc3RzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRCYXNlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxQcm9taXNlID0gaXNTZW5kUmVxdWVzdHNFbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbLi4ub3RoZXJSZXF1ZXN0c11cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3RoaXMucmVxdWVzdChiYXRjaFJlcVBheWxvYWQpLCAuLi5vdGhlclJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSByZXNwb25zZSB3aGVuIGFsbCByZXF1ZXN0IGFyZSBleGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQoYWxsUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlbmRSZXF1ZXN0c0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2VzLm1hcCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoKChfYSA9IHBheWxvYWRbaW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpIHx8IGlkQmFzZSArIGluZGV4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcGF5bG9hZFtpbmRleF0ubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXNwb25zZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLnN0YXR1cyAhPT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGVuZ3RoUmVzcG9uc2UgPSBwcm9jZXNzUmVzcG9uc2VzKHBheWxvYWQsIHJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShvcmlnaW5hbExlbmd0aFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgaWQ6IE51bWJlcihwYXlsb2FkLmlkKSB9KSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2sgb3IgcmV0dXJuIHByb21pc2UsIGRlcGRlbmRzIG9uIGNhbGxiYWNrIGFyZyBnaXZlbiBvciBub3RcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kaW5nIHVzZXJPcGVyYXRpb24gdXNpbmcgQmxvY3RvIFNESy5cbiAgICAgKiBAcGFyYW0ge0lVc2VyT3BlcmF0aW9ufSB1c2VyT3AgLSB1c2VyT3BlcmF0aW9uIG9iamVjdFxuICAgICAqIEByZW1hcmtzIE5vIG5lZWQgdG8gaW5jbHVkZSBub25jZSwgaW5pdENvZGUsIGFuZCBzaWduYXR1cmUgYXMgcGFyYW1ldGVycyB3aGVuIHVzaW5nIEJsb2N0b1NESyB0byBzZW5kIHVzZXJPcGVyYXRpb24uXG4gICAgICogVGhlc2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSB1c2VyT3BlcmF0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBzZW5kVXNlck9wZXJhdGlvbih1c2VyT3ApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kVXNlck9wZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdXNlck9wXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB3ZWIzLmpzIHY0IGJhdGNoIGVudHJ5IHBvaW50XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyhwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5tZXRob2QpKVxuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCgpO1xuICAgICAgICAgICAgY29uc3QgeyBibG9ja2NoYWluTmFtZSwgc3dpdGNoYWJsZU5ldHdvcmssIHNlc3Npb25LZXlFbnYgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLmV4aXN0ZWRTREspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2MgPSAoX2IgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGlzdGVkU0RLLnJlcXVlc3QocGF5bG9hZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQoKF9hID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLmNoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZCgoX2IgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0uY2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IChfYyA9IHN3aXRjaGFibGVOZXR3b3JrID09PSBudWxsIHx8IHN3aXRjaGFibGVOZXR3b3JrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzd2l0Y2hhYmxlTmV0d29ya1t0aGlzLm5ldHdvcmtWZXJzaW9uXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ldGhvZCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB1c2VyIHRvIGJlIGNvbm5lY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9jaGFpbklkJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICduZXRfdmVyc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29ya1ZlcnNpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkU3dpdGNoYWJsZU5ldHdvcmsoKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpIHx8IFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZXRoX2Jsb2NrTnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWIzX2NsaWVudFZlcnNpb24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9jYWxsJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKChfZCA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5lcnJvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsYmFjayhudWxsLCByZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTd2l0Y2hDaGFpbigoX2YgPSAoX2UgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jaGFpbklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X2Rpc2Nvbm5lY3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZXRoX2FjY291bnRzJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52LCBibG9ja2NoYWluTmFtZSkgfHwgW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWV0aG9kIHRoYXQgcmVxdWlyZXMgdXNlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgICAgICAgIGlmICghZ2V0RXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52LCBibG9ja2NoYWluTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IChfZyA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ1swXTtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfcmVxdWVzdEFjY291bnRzJyAmJiBpc0VtYWlsKGVtYWlsKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZShlbWFpbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmZldGNoQWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfY29pbmJhc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoX2ggPSBnZXRFdm1BZGRyZXNzKHNlc3Npb25LZXlFbnYsIGJsb2NrY2hhaW5OYW1lKSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGVyc29uYWxfc2lnbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2lnbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCgnTWV0aG9kIE5vdCBTdXBwb3J0ZWQ6IGV0aF9zaWduIGhhcyBiZWVuIGRpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X3NlbmRNdWx0aUNhbGxUcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgnTWV0aG9kIE5vdCBTdXBwb3J0ZWQ6ICcgKyBwYXlsb2FkLm1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NlbmRVc2VyT3BlcmF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZFVzZXJPcGVyYXRpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX2VzdGltYXRlVXNlck9wZXJhdGlvbkdhcyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9nZXRVc2VyT3BlcmF0aW9uQnlIYXNoJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX2dldFVzZXJPcGVyYXRpb25SZWNlaXB0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3N1cHBvcnRlZEVudHJ5UG9pbnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlQnVuZGxlcihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmICFyZXNwb25zZS5yZXN1bHQgJiYgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdSZXF1ZXN0IGZhaWxlZCc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBibG9jdG9BcGkodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2FsbGV0U2VydmVyLCBibG9ja2NoYWluTmFtZSwgc2Vzc2lvbktleUVudiB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHNlc3Npb25LZXlFbnYpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBpZiAoIXNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGAke3dhbGxldFNlcnZlcn0vYXBpLyR7YmxvY2tjaGFpbk5hbWV9JHt1cmx9YCwgT2JqZWN0LmFzc2lnbih7IGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSB9LCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCBzZXNzaW9uS2V5RW52LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihkaXN0LmV0aEVycm9ycy5wcm92aWRlci5kaXNjb25uZWN0ZWQoKSkpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuZXJyb3JfY29kZSkgPT09ICd1bnN1cHBvcnRlZF9tZXRob2QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoJ01ldGhvZCBOb3QgU3VwcG9ydGVkOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5zZXJ2ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogLTMyMDA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEJsb2N0byBzZXJ2ZXIgZXJyb3I6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzcG9uc2VMaXN0ZW5lcihmcmFtZSwgb2JqZWN0S2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gd2FsbGV0U2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS5kYXRhW29iamVjdEtleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuc3RhdHVzID09PSAnREVDTElORUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdFVEg6RlJBTUU6Q0xPU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoJ1VzZXIgZGVjbGluZWQgdGhlIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0SWZyYW1lKHVybCwgYmxvY2tjaGFpbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Jsb2N0byBTREsgb25seSB3b3JrcyBpbiBicm93c2VyIGVudmlyb25tZW50JyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgd2FsbGV0U2VydmVyLCBibG9ja2NoYWluTmFtZSB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBjcmVhdGVGcmFtZShgJHt3YWxsZXRTZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vJHtibG9ja2NoYWluIHx8IGJsb2NrY2hhaW5OYW1lfSR7dXJsfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZWlwLTExMDIgYWxpYXNcbiAgICAvLyBERVBSRUNBVEVEIEFQSTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvYmxvYi9tYXN0ZXIvRUlQUy9laXAtMTEwMi5tZFxuICAgIGVuYWJsZShlbWFpbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAxMDAxLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQmxvY3RvIFNESyBvbmx5IHdvcmtzIGluIGJyb3dzZXIgZW52aXJvbm1lbnQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIsIGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5RW52IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5leGlzdGVkU0RLKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leGlzdGVkU0RLLmNoYWluSWQgIT09IHRoaXMuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXhpc3RlZFNESy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW3sgY2hhaW5JZDogdGhpcy5jaGFpbklkIH1dLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52LCBibG9ja2NoYWluTmFtZSwgW3RoaXMuZXhpc3RlZFNESy5hZGRyZXNzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzbWFsbCBkZWxheSB0byBtYWtlIHN1cmUgdGhlIG5ldHdvcmsgaGFzIGJlZW4gc3dpdGNoZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZXhpc3RlZFNESy5lbmFibGUoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCksIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0RXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52LCBibG9ja2NoYWluTmFtZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgnbDZuJywgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCd2JywgU0RLX1ZFUlNJT04pO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgncScsIGAke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX0ke3dpbmRvdy5sb2NhdGlvbi5zZWFyY2h9YCk7XG4gICAgICAgICAgICBjb25zdCBlbWFpbFBhcmFtID0gZW1haWwgJiYgaXNFbWFpbChlbWFpbCkgPyBgLyR7ZW1haWx9YCA6ICcnO1xuICAgICAgICAgICAgY29uc3QgbG9naW5GcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvYXV0aG4ke2VtYWlsUGFyYW19PyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gd2FsbGV0U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdFVEg6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHsgY2hhaW5JZDogdGhpcy5jaGFpbklkIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBY2NvdW50U3RvcmFnZShzZXNzaW9uS2V5RW52LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGUuZGF0YS5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldm06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtibG9ja2NoYWluTmFtZV06IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5kYXRhLmV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYiA9IGUuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlzQWNjb3VudENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luQ2hhaW46IENIQUlOLkVUSEVSRVVNLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0JMT0NUT19TREs6QUNDT1VOVF9DSEFOR0VEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQWNjb3VudENoYW5nZWQgPSAoKF9hID0gbWVzc2FnZUV2ZW50LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ0JMT0NUT19TREs6QUNDT1VOVF9DSEFOR0VEJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBbm90aGVyQ2hhaW4gPSAoKF9iID0gbWVzc2FnZUV2ZW50LmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcmlnaW5DaGFpbikgIT09IENIQUlOLkVUSEVSRVVNO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY2NvdW50Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY291bnRzQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoW2UuZGF0YS5hZGRyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FjY291bnRDaGFuZ2VkICYmIGlzQW5vdGhlckNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtlLmRhdGEuYWRkcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5RW52IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2FjY291bnRzYCk7XG4gICAgICAgICAgICBzZXRFdm1BZGRyZXNzKHNlc3Npb25LZXlFbnYsIGJsb2NrY2hhaW5OYW1lLCBhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMucnBjLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IGlkOiAxLCBqc29ucnBjOiAnMi4wJyB9LCBwYXlsb2FkKSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2lnbih7IG1ldGhvZCwgcGFyYW1zIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BlcnNvbmFsX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBpc0hleFN0cmluZyhwYXJhbXNbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1swXS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1dGY4VG9IZXgocGFyYW1zWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoW1xuICAgICAgICAgICAgICAgICAgICAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICAgICAgICAgICAgICAgICAgICAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuICAgICAgICAgICAgICAgICAgICAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxuICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbWFpbiB9ID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGRvbWFpbi5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFByb3ZpZGVkIGNoYWluSWQgXCIke2RvbWFpbi5jaGFpbklkfVwiIG11c3QgYmUgYSBudW1iZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VDaGFpbklkKGRvbWFpbi5jaGFpbklkKSAhPT0gcGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBQcm92aWRlZCBjaGFpbklkIFwiJHtkb21haW4uY2hhaW5JZH1cIiBtdXN0IG1hdGNoIHRoZSBhY3RpdmUgY2hhaW5JZCBcIiR7cGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlSWQgfSA9IHlpZWxkIHRoaXMuYmxvY3RvQXBpKGAvdXNlci1zaWduYXR1cmVgLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG1ldGhvZCwgbWVzc2FnZSB9KSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25GcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvdXNlci1zaWduYXR1cmUvJHtzaWduYXR1cmVJZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIoc2lnbkZyYW1lLCAnc2lnbmF0dXJlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTd2l0Y2hDaGFpbih0YXJnZXRDaGFpbklkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldENoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIsIGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5RW52LCBzd2l0Y2hhYmxlTmV0d29yayB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgb2xkQWNjb3VudCA9IChfYSA9IGdldEV2bUFkZHJlc3Moc2Vzc2lvbktleUVudiwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgICAgICBjb25zdCBvbGRDaGFpbklkID0gcGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCk7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGFpbklkID0gcGFyc2VDaGFpbklkKHRhcmdldENoYWluSWQpO1xuICAgICAgICAgICAgaWYgKG9sZENoYWluSWQgPT09IG5ld0NoYWluSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3dpdGNoYWJsZU5ldHdvcmtbbmV3Q2hhaW5JZF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtuZXdDaGFpbklkfVwiLiBUcnkgYWRkaW5nIHRoZSBjaGFpbiB1c2luZyB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbiBmaXJzdC5gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke25ld0NoYWluSWR9YDtcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7bmV3Q2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbbmV3Q2hhaW5JZF0ucnBjX3VybDtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2N0byA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYmxvY3RvKSwgeyBibG9ja2NoYWluTmFtZTogJycsIG5ldHdvcmtUeXBlOiAnJyB9KTtcbiAgICAgICAgICAgIGlmICghb2xkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGFpbkNoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRoaXMuY2hhaW5JZCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdvIGxvZ2luIGZsb3cgd2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJlbnQgYmxvY3RvIHNlcnZlclxuICAgICAgICAgICAgaWYgKHN3aXRjaGFibGVOZXR3b3JrW25ld0NoYWluSWRdLndhbGxldF93ZWJfdXJsICE9PVxuICAgICAgICAgICAgICAgIHN3aXRjaGFibGVOZXR3b3JrW29sZENoYWluSWRdLndhbGxldF93ZWJfdXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKFtuZXdBY2NvdW50XSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdBY2NvdW50ICE9PSBvbGRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudHNDaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihbbmV3QWNjb3VudF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke29sZENoYWluSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtvbGRDaGFpbklkLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW29sZENoYWluSWRdLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2N0byA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYmxvY3RvKSwgeyBibG9ja2NoYWluTmFtZTogJycsIG5ldHdvcmtUeXBlOiAnJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaENoYWluRnJhbWUgPSB5aWVsZCB0aGlzLnNldElmcmFtZShgL3N3aXRjaC1jaGFpbj90bz0ke3N3aXRjaGFibGVOZXR3b3JrW25ld0NoYWluSWRdLm5hbWV9YCwgc3dpdGNoYWJsZU5ldHdvcmtbb2xkQ2hhaW5JZF0ubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gd2FsbGV0U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdFVEg6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoc3dpdGNoQ2hhaW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRyKSAmJiBvbGRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHNlc3Npb25LZXlFbnYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IChfYiA9IGUuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldm06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3dpdGNoYWJsZU5ldHdvcmtbbmV3Q2hhaW5JZF0ubmFtZV06IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAoX2MgPSBlLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmFkZHIgIT09IG9sZEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hY2NvdW50c0NoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKFtlLmRhdGEuYWRkcl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2UgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2hhaW5DaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzd2l0Y2hDaGFpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9mID0gZS5kYXRhKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaGFzQXBwcm92ZWRTd2l0Y2hDaGFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2cgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuY2hhaW5DaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsRXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9oID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmRpc2Nvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtvbGRDaGFpbklkfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7b2xkQ2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGMgPSBzd2l0Y2hhYmxlTmV0d29ya1tvbGRDaGFpbklkXS5ycGNfdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9jdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0byksIHsgYmxvY2tjaGFpbk5hbWU6ICcnLCBuZXR3b3JrVHlwZTogJycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgaW52YWxpZE1zZyB9ID0gaXNWYWxpZFRyYW5zYWN0aW9uKChfYSA9IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoaW52YWxpZE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jcmVhdGVBdXRoekZyYW1lKS5jYWxsKHRoaXMsIHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFBhcmFtcywgcmV2ZXJ0RmxhZztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQucGFyYW1zKSAmJiBwYXlsb2FkLnBhcmFtcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIFtvcmlnaW5hbFBhcmFtcywgcmV2ZXJ0RmxhZ10gPSBwYXlsb2FkLnBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsUGFyYW1zID0gcGF5bG9hZC5wYXJhbXM7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0RmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV2ZXJ0ID0gcmV2ZXJ0RmxhZyA/IHJldmVydEZsYWcgOiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgaW52YWxpZE1zZyB9ID0gaXNWYWxpZFRyYW5zYWN0aW9ucyhvcmlnaW5hbFBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhpbnZhbGlkTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NyZWF0ZUF1dGh6RnJhbWUpLmNhbGwodGhpcywgb3JpZ2luYWxQYXJhbXMsIHJldmVydCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLW9wZXJhdGlvbmAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJPUEZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLW9wZXJhdGlvbi8ke2F1dGhvcml6YXRpb25JZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIodXNlck9QRnJhbWUsICd1c2VyT3BIYXNoJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVCdW5kbGVyKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2N0b0FwaShgL3JwYy9idW5kbGVyYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBpZDogMSwganNvbnJwYzogJzIuMCcgfSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuZXhpc3RlZFNESykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhpc3RlZFNESy5yZXF1ZXN0KHsgbWV0aG9kOiAnd2FsbGV0X2Rpc2Nvbm5lY3QnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uS2V5RW52IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZW1vdmVBbGxFdm1BZGRyZXNzKHNlc3Npb25LZXlFbnYpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCgpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkU3dpdGNoYWJsZU5ldHdvcmsobmV0d29ya0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHN3aXRjaGFibGUgbGlzdCBpZiB1c2VyIHNldCBuZXR3b3JrTGlzdFxuICAgICAgICAgICAgaWYgKG5ldHdvcmtMaXN0ID09PSBudWxsIHx8IG5ldHdvcmtMaXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXR3b3JrTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9BZGQgPSBuZXR3b3JrTGlzdC5tYXAoKHsgY2hhaW5JZCwgcnBjVXJscyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hhaW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCdFbXB0eSBjaGFpbklkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZENoYWluSWQgPSBgJHtwYXJzZUNoYWluSWQoY2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBjaGFpbklkIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ibG9jdG8uc3dpdGNoYWJsZU5ldHdvcmtbcGFyc2VkQ2hhaW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUnBjID0gKHJwY1VybHMgPT09IG51bGwgfHwgcnBjVXJscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcnBjVXJsc1swXSkgfHwgRVRIX1JQQ19MSVNUW3BhcnNlZENoYWluSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJwYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCdycGNVcmxzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBwYXJzZWRDaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJsczogW3BhcnNlZFJwY10sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsaXN0VG9BZGQpLnRoZW4oKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnRW1wdHkgbmV0d29ya0xpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cHBvcnRDaGFpbkxpc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0TmV0d29ya0xpc3QgPSB5aWVsZCBnZXRFdm1TdXBwb3J0KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAxMDAxLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgR2V0IGJsb2N0byBzZXJ2ZXIgZmFpbGVkOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3VwcG9ydE5ldHdvcmtMaXN0KS5tYXAoKGNoYWluSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRpc3BsYXlfbmFtZSB9ID0gc3VwcG9ydE5ldHdvcmtMaXN0W2NoYWluSWRdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluTmFtZTogZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmV4aXN0ZWRTREspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Jsb2N0bylcbiAgICAgICAgICAgIHRoaXMuZXhpc3RlZFNESy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5leGlzdGVkU0RLKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNCbG9jdG8pXG4gICAgICAgICAgICB0aGlzLmV4aXN0ZWRTREsub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxufVxuX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcyA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5fYmxvY3RvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5sb2FkZWROZXR3b3JrKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmxvYWRTd2l0Y2hhYmxlTmV0d29yayh0aGlzLl9ibG9jdG8udW5sb2FkZWROZXR3b3JrKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ibG9jdG8udW5sb2FkZWROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ibG9jdG8uc2Vzc2lvbktleUVudiAmJlxuICAgICAgICAgICAgdGhpcy5fYmxvY3RvLndhbGxldFNlcnZlciAmJlxuICAgICAgICAgICAgdGhpcy5fYmxvY3RvLmJsb2NrY2hhaW5OYW1lICYmXG4gICAgICAgICAgICB0aGlzLl9ibG9jdG8ubmV0d29ya1R5cGUgJiZcbiAgICAgICAgICAgIHRoaXMuX2Jsb2N0by5zd2l0Y2hhYmxlTmV0d29yaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2N0bztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdXBwb3J0TmV0d29ya0xpc3QgPSB5aWVsZCBnZXRFdm1TdXBwb3J0KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgR2V0IGJsb2N0byBzZXJ2ZXIgZmFpbGVkOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGNoYWluX2lkLCBuYW1lLCBuZXR3b3JrX3R5cGUsIGJsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50LCBkaXNwbGF5X25hbWUsIH0gPSAoX2IgPSBzdXBwb3J0TmV0d29ya0xpc3RbdGhpcy5uZXR3b3JrVmVyc2lvbl0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICBpZiAoIWNoYWluX2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZChgR2V0IHN1cHBvcnQgY2hhaW4gZmFpbGVkOiAke3RoaXMubmV0d29ya1ZlcnNpb259IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgeWV0LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldFNlcnZlciA9IHRoaXMuaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIgfHxcbiAgICAgICAgICAgIEVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HW2Jsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50XTtcbiAgICAgICAgdGhpcy5fYmxvY3RvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9ibG9jdG8pLCB7IHNlc3Npb25LZXlFbnY6IEVUSF9TRVNTSU9OX0tFWV9NQVBQSU5HW2Jsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50XSwgd2FsbGV0U2VydmVyLCBibG9ja2NoYWluTmFtZTogbmFtZSwgbmV0d29ya1R5cGU6IG5ldHdvcmtfdHlwZSwgc3dpdGNoYWJsZU5ldHdvcms6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYmxvY3RvLnN3aXRjaGFibGVOZXR3b3JrKSwgeyBbY2hhaW5faWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya190eXBlLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXRfd2ViX3VybDogd2FsbGV0U2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBycGNfdXJsOiB0aGlzLnJwYyxcbiAgICAgICAgICAgICAgICB9IH0pIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY3RvO1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlKHsgY2hhaW5JZCwgcnBjVXJscywgfSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHN1cHBvcnROZXR3b3JrTGlzdCA9IHlpZWxkIGdldEV2bVN1cHBvcnQoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAxMDAxLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBHZXQgYmxvY3RvIHNlcnZlciBmYWlsZWQ6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIGRpc3BsYXlfbmFtZSwgbmV0d29ya190eXBlLCBibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCwgfSA9IChfYSA9IHN1cHBvcnROZXR3b3JrTGlzdFtjaGFpbklkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgIGlmICghY2hhaW5faWQpXG4gICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZChgR2V0IHN1cHBvcnQgY2hhaW4gZmFpbGVkOiAke2NoYWluSWR9IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgeWV0LmApO1xuICAgICAgICBjb25zdCB3YWxsZXRfd2ViX3VybCA9IEVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HW2Jsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50XTtcbiAgICAgICAgdGhpcy5fYmxvY3RvLnN3aXRjaGFibGVOZXR3b3JrW2NoYWluX2lkXSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgICBuZXR3b3JrX3R5cGUsXG4gICAgICAgICAgICB3YWxsZXRfd2ViX3VybCxcbiAgICAgICAgICAgIHJwY191cmw6IHJwY1VybHNbMF0sXG4gICAgICAgIH07XG4gICAgfSk7XG59LCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSB0aGlzLmV4aXN0ZWRTREspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Jsb2N0bykgJiZcbiAgICAgICAgcGFyc2VDaGFpbklkKHRoaXMuZXhpc3RlZFNESy5jaGFpbklkKSAhPT0gcGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCkpIHtcbiAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQoKTtcbiAgICB9XG59LCBfRXRoZXJldW1Qcm92aWRlcl9jcmVhdGVBdXRoekZyYW1lID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfY3JlYXRlQXV0aHpGcmFtZShwYXJhbXMsIHJldmVydCA9IHRydWUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC9hdXRoemAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoW3BhcmFtcywgcmV2ZXJ0XSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpZnJhbWVQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmcmFtZVBhcmFtcy5zZXQoJ2w2bicsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICBpZnJhbWVQYXJhbXMuc2V0KCdxJywgYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfSR7d2luZG93LmxvY2F0aW9uLnNlYXJjaH1gKTtcbiAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvYXV0aHovJHthdXRob3JpemF0aW9uSWR9PyR7aWZyYW1lUGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIoYXV0aHpGcmFtZSwgJ3R4SGFzaCcpO1xuICAgIH0pO1xufTtcblxuY29uc3QgY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdCA9IChwYXlsb2FkKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBmb3JtYXR0ZWRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCk7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBub25jZSwgYWRkcmVzcywgYXBwbGljYXRpb24sIGNoYWluSWQgfSA9IHBheWxvYWQ7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JtYXR0ZWRQYXlsb2FkLm1lc3NhZ2UgPSAoX2EgPSBTdHJpbmcobWVzc2FnZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5vbmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JtYXR0ZWRQYXlsb2FkLm5vbmNlID0gKF9iID0gU3RyaW5nKG5vbmNlKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzICYmIHR5cGVvZiBhZGRyZXNzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5hZGRyZXNzID0gISFhZGRyZXNzO1xuICAgIH1cbiAgICBpZiAoYXBwbGljYXRpb24gJiYgdHlwZW9mIGFwcGxpY2F0aW9uICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5hcHBsaWNhdGlvbiA9ICEhYXBwbGljYXRpb247XG4gICAgfVxuICAgIGlmIChjaGFpbklkICYmIHR5cGVvZiBjaGFpbklkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5jaGFpbklkID0gISFjaGFpbklkO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkUGF5bG9hZDtcbn07XG5jbGFzcyBBcHRvc1Byb3ZpZGVyIGV4dGVuZHMgQmxvY3RvUHJvdmlkZXIge1xuICAgIGdldCBleGlzdGVkU0RLKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd2luZG93LmJsb2N0b0FwdG9zO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQsIHNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IFtdO1xuICAgICAgICB0aGlzLmF1dGhLZXkgPSAnJztcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLnJlbW92ZUxpc3RlbmVyO1xuICAgICAgICBpbnZhcmlhbnQoY2hhaW5JZCwgXCInY2hhaW5JZCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIGludmFyaWFudChhcHBJZCwgJ0l0IGlzIG5lY2Vzc2FyeSB0byBpbnRlcmFjdCB3aXRoIEJsb2N0byB3YWxsZXQgdmlhIHlvdXIgYXBwIGlkLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9kZXZlbG9wZXJzLmJsb2N0by5hcHAgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgdGhpcy5uZXR3b3JrTmFtZSA9IEFQVF9DSEFJTl9JRF9OQU1FX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIHRoaXMuYXBpID0gQVBUX0NIQUlOX0lEX1JQQ19NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICB0aGlzLnNlc3Npb25LZXkgPSBBUFRfU0VTU0lPTl9LRVlfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNlcnZlciA9IEFQVF9DSEFJTl9JRF9TRVJWRVJfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlciB8fCBkZWZhdWx0U2VydmVyIHx8ICcnO1xuICAgIH1cbiAgICBnZXQgcHVibGljQWNjb3VudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSB8fCBudWxsLFxuICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleS5sZW5ndGggPyB0aGlzLnB1YmxpY0tleSA6IG51bGwsXG4gICAgICAgICAgICAvLyBAdG9kbzogcHJvdmlkZSBhdXRoa2V5XG4gICAgICAgICAgICBhdXRoS2V5OiBudWxsLFxuICAgICAgICAgICAgbWluS2V5c1JlcXVpcmVkOiAyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5ldHdvcmtOYW1lLFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhISgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0ZWRTREspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGlzdGVkU0RLLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduVHJhbnNhY3Rpb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5leGlzdGVkU0RLLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUyk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgIGNvZGU6IDQ5MDAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1dhbGxldCBkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4aXN0ZWRTREsuc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9hcHRvcy9hdXRoemAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uKSwgdHhPcHRpb25zKSksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IGNyZWF0ZUZyYW1lKGAke3RoaXMuc2VydmVyfS8ke3RoaXMuYXBwSWR9L2FwdG9zL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGhhc2g6IGUuZGF0YS50eEhhc2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFBheWxvYWQgPSBjaGVja01lc3NhZ2VQYXlsb2FkRm9ybWF0KHBheWxvYWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4aXN0ZWRTREsuc2lnbk1lc3NhZ2UoZm9ybWF0dGVkUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvdXNlci1zaWduYXR1cmVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZm9ybWF0dGVkUGF5bG9hZCksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vYXB0b3MvdXNlci1zaWduYXR1cmUvJHtzaWduYXR1cmVJZH1gO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0gY3JlYXRlRnJhbWUodXJsKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0ZWRTREspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc21hbGwgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIHN3aXRjaGVkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmV4aXN0ZWRTREsuY29ubmVjdCgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoKF9iID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9hcHRvcy9hdXRobj9sNm49JHtsb2NhdGlvbn0mdj0ke1NES19WRVJTSU9OfX1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDSEFJTi5BUFRPU106IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5kYXRhLmV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYyA9IGUuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlzQWNjb3VudENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luQ2hhaW46IENIQUlOLkFQVE9TLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0JMT0NUT19TREs6QUNDT1VOVF9DSEFOR0VEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBtZXNzYWdlRXZlbnQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnQkxPQ1RPX1NESzpBQ0NPVU5UX0NIQU5HRUQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gbWVzc2FnZUV2ZW50LmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcmlnaW5DaGFpbikgIT09IENIQUlOLkFQVE9TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9kID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHB1YmxpY19rZXlzOiBwdWJsaWNLZXlzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYmxvY3RvL2FwdG9zL2FjY291bnRzLyR7KF9lID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF19YCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHB1YmxpY0tleXMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoKF9mID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZbMF0pIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5LZXlzUmVxdWlyZWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbzogYmV0dGVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVc2VyIGRlY2xpbmVkIHRoZSBsb2dpbiByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEFkZHJlc3MoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL2FwdG9zL2FjY291bnRzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBjaGVjayB0aGUgZXhpc3RlbmNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLUFwcGxpY2F0aW9uLUlkZW50aWZpZXInOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLVNlc3Npb24tSWRlbnRpZmllcic6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIHNldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TLCBhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzID09PSBudWxsIHx8IGFjY291bnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY2NvdW50c1swXSkgfHwgJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhpc3RlZFNESylcbiAgICAgICAgICAgIHRoaXMuZXhpc3RlZFNESy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhpc3RlZFNESylcbiAgICAgICAgICAgIHRoaXMuZXhpc3RlZFNESy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG59XG5cbmNsYXNzIEJsb2N0b1NESyB7XG4gICAgY29uc3RydWN0b3IoeyBhcHBJZCwgZXRoZXJldW0sIGFwdG9zIH0pIHtcbiAgICAgICAgaWYgKGV0aGVyZXVtKSB7XG4gICAgICAgICAgICB0aGlzLmV0aGVyZXVtID0gbmV3IEV0aGVyZXVtUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldGhlcmV1bSksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHRvcykge1xuICAgICAgICAgICAgdGhpcy5hcHRvcyA9IG5ldyBBcHRvc1Byb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXB0b3MpLCB7IGFwcElkIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgQmxvY3RvU0RLIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@blocto/sdk/dist/blocto-sdk.module.js\n"));

/***/ })

}]);